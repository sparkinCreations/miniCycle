/**
 * Namespace Tests
 *
 * Tests for the miniCycle namespace module (window.miniCycle.*)
 * Verifies API structure, backward compatibility, and feature parity
 *
 * @version 1.357
 * @module tests/namespace
 */

export async function runNamespaceTests(resultsDiv, isPartOfSuite = false) {
    resultsDiv.innerHTML = '<h2>üéØ Namespace Tests</h2>';
    let passed = { count: 0 }, total = { count: 0 };

    // ‚úÖ Early check: Ensure window.miniCycle exists
    if (!window.miniCycle) {
        resultsDiv.innerHTML += '<div class="result fail">‚ùå CRITICAL: window.miniCycle namespace not found. Namespace module may not have loaded.</div>';
        resultsDiv.innerHTML += '<h3 style="color: red">‚úÖ Results: 0/1 tests passed (0%)</h3>';
        return { passed: 0, total: 1 };
    }

    // üîí SAVE REAL APP DATA before tests
    let savedRealData = {};
    if (!isPartOfSuite) {
        const protectedKeys = ['miniCycleData', 'miniCycleForceFullVersion'];
        protectedKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value !== null) {
                savedRealData[key] = value;
            }
        });
        console.log('üîí Saved original localStorage for namespace tests');
    }

    // Helper to restore original data
    function restoreOriginalData() {
        if (!isPartOfSuite) {
            localStorage.clear();
            Object.keys(savedRealData).forEach(key => {
                localStorage.setItem(key, savedRealData[key]);
            });
            console.log('‚úÖ Namespace tests completed - original localStorage restored');
        }
    }

    async function test(name, testFn) {
        total.count++;

        // Save state before test
        const savedLocalStorage = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('miniCycle')) {
                savedLocalStorage[key] = localStorage.getItem(key);
            }
        }

        try {
            // Run test
            await testFn();

            // Test passed
            passed.count++;
            resultsDiv.innerHTML += `<div class="result pass">‚úÖ ${name}</div>`;
        } catch (error) {
            resultsDiv.innerHTML += `<div class="result fail">‚ùå ${name}: ${error.message}</div>`;
            console.error(`Test "${name}" failed:`, error);
        } finally {
            // Restore localStorage
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('miniCycle')) {
                    localStorage.removeItem(key);
                }
            });
            Object.keys(savedLocalStorage).forEach(key => {
                localStorage.setItem(key, savedLocalStorage[key]);
            });

            // Clear deprecation warnings cache
            if (window.miniCycle?._deprecationWarnings) {
                window.miniCycle._deprecationWarnings.clear();
            }
        }
    }

    // ============================================
    // STRUCTURE TESTS
    // ============================================

    await test('window.miniCycle namespace exists', async () => {
        if (!window.miniCycle) {
            throw new Error('window.miniCycle namespace not found');
        }
    });

    await test('window.miniCycle has version property', async () => {
        if (!window.miniCycle.version) {
            throw new Error('version property missing');
        }
        if (typeof window.miniCycle.version !== 'string') {
            throw new Error('version should be a string');
        }
    });

    await test('window.miniCycle has state namespace', async () => {
        if (!window.miniCycle.state) {
            throw new Error('state namespace missing');
        }
        if (typeof window.miniCycle.state !== 'object') {
            throw new Error('state should be an object');
        }
    });

    await test('window.miniCycle has tasks namespace', async () => {
        if (!window.miniCycle.tasks) {
            throw new Error('tasks namespace missing');
        }
        if (typeof window.miniCycle.tasks !== 'object') {
            throw new Error('tasks should be an object');
        }
    });

    await test('window.miniCycle has cycles namespace', async () => {
        if (!window.miniCycle.cycles) {
            throw new Error('cycles namespace missing');
        }
        if (typeof window.miniCycle.cycles !== 'object') {
            throw new Error('cycles should be an object');
        }
    });

    await test('window.miniCycle has ui namespace', async () => {
        if (!window.miniCycle.ui) {
            throw new Error('ui namespace missing');
        }
        if (typeof window.miniCycle.ui !== 'object') {
            throw new Error('ui should be an object');
        }
    });

    await test('window.miniCycle has utils namespace', async () => {
        if (!window.miniCycle.utils) {
            throw new Error('utils namespace missing');
        }
        if (typeof window.miniCycle.utils !== 'object') {
            throw new Error('utils should be an object');
        }
    });

    await test('window.miniCycle has features namespace', async () => {
        if (!window.miniCycle.features) {
            throw new Error('features namespace missing');
        }
        if (typeof window.miniCycle.features !== 'object') {
            throw new Error('features should be an object');
        }
    });

    // ============================================
    // STATE API TESTS
    // ============================================

    await test('state.get() method exists', async () => {
        if (typeof window.miniCycle.state.get !== 'function') {
            throw new Error('state.get should be a function');
        }
    });

    await test('state.update() method exists', async () => {
        if (typeof window.miniCycle.state.update !== 'function') {
            throw new Error('state.update should be a function');
        }
    });

    await test('state.isReady() method exists', async () => {
        if (typeof window.miniCycle.state.isReady !== 'function') {
            throw new Error('state.isReady should be a function');
        }
    });

    await test('state.getActiveCycle() method exists', async () => {
        if (typeof window.miniCycle.state.getActiveCycle !== 'function') {
            throw new Error('state.getActiveCycle should be a function');
        }
    });

    await test('state.getTasks() method exists', async () => {
        if (typeof window.miniCycle.state.getTasks !== 'function') {
            throw new Error('state.getTasks should be a function');
        }
    });

    await test('state.debug() method exists', async () => {
        if (typeof window.miniCycle.state.debug !== 'function') {
            throw new Error('state.debug should be a function');
        }
    });

    // ============================================
    // TASKS API TESTS
    // ============================================

    await test('tasks.add() method exists', async () => {
        if (typeof window.miniCycle.tasks.add !== 'function') {
            throw new Error('tasks.add should be a function');
        }
    });

    await test('tasks.edit() method exists', async () => {
        if (typeof window.miniCycle.tasks.edit !== 'function') {
            throw new Error('tasks.edit should be a function');
        }
    });

    await test('tasks.delete() method exists', async () => {
        if (typeof window.miniCycle.tasks.delete !== 'function') {
            throw new Error('tasks.delete should be a function');
        }
    });

    await test('tasks.validate() method exists', async () => {
        if (typeof window.miniCycle.tasks.validate !== 'function') {
            throw new Error('tasks.validate should be a function');
        }
    });

    await test('tasks.render() method exists', async () => {
        if (typeof window.miniCycle.tasks.render !== 'function') {
            throw new Error('tasks.render should be a function');
        }
    });

    await test('tasks.refresh() method exists', async () => {
        if (typeof window.miniCycle.tasks.refresh !== 'function') {
            throw new Error('tasks.refresh should be a function');
        }
    });

    await test('tasks.moveToCompleted() method exists', async () => {
        if (typeof window.miniCycle.tasks.moveToCompleted !== 'function') {
            throw new Error('tasks.moveToCompleted should be a function');
        }
    });

    await test('tasks.moveToActive() method exists', async () => {
        if (typeof window.miniCycle.tasks.moveToActive !== 'function') {
            throw new Error('tasks.moveToActive should be a function');
        }
    });

    // ============================================
    // CYCLES API TESTS
    // ============================================

    await test('cycles.create() method exists', async () => {
        if (typeof window.miniCycle.cycles.create !== 'function') {
            throw new Error('cycles.create should be a function');
        }
    });

    await test('cycles.switch() method exists', async () => {
        if (typeof window.miniCycle.cycles.switch !== 'function') {
            throw new Error('cycles.switch should be a function');
        }
    });

    await test('cycles.delete() method exists', async () => {
        if (typeof window.miniCycle.cycles.delete !== 'function') {
            throw new Error('cycles.delete should be a function');
        }
    });

    await test('cycles.rename() method exists', async () => {
        if (typeof window.miniCycle.cycles.rename !== 'function') {
            throw new Error('cycles.rename should be a function');
        }
    });

    await test('cycles.load() method exists', async () => {
        if (typeof window.miniCycle.cycles.load !== 'function') {
            throw new Error('cycles.load should be a function');
        }
    });

    await test('cycles.list() method exists', async () => {
        if (typeof window.miniCycle.cycles.list !== 'function') {
            throw new Error('cycles.list should be a function');
        }
    });

    await test('cycles.check() method exists', async () => {
        if (typeof window.miniCycle.cycles.check !== 'function') {
            throw new Error('cycles.check should be a function');
        }
    });

    await test('cycles.incrementCount() method exists', async () => {
        if (typeof window.miniCycle.cycles.incrementCount !== 'function') {
            throw new Error('cycles.incrementCount should be a function');
        }
    });

    // ============================================
    // UI API TESTS
    // ============================================

    await test('ui.notifications namespace exists', async () => {
        if (!window.miniCycle.ui.notifications) {
            throw new Error('ui.notifications missing');
        }
    });

    await test('ui.notifications.show() method exists', async () => {
        if (typeof window.miniCycle.ui.notifications.show !== 'function') {
            throw new Error('ui.notifications.show should be a function');
        }
    });

    await test('ui.notifications.showWithTip() method exists', async () => {
        if (typeof window.miniCycle.ui.notifications.showWithTip !== 'function') {
            throw new Error('ui.notifications.showWithTip should be a function');
        }
    });

    await test('ui.modals namespace exists', async () => {
        if (!window.miniCycle.ui.modals) {
            throw new Error('ui.modals missing');
        }
    });

    await test('ui.modals.confirm() method exists', async () => {
        if (typeof window.miniCycle.ui.modals.confirm !== 'function') {
            throw new Error('ui.modals.confirm should be a function');
        }
    });

    await test('ui.modals.prompt() method exists', async () => {
        if (typeof window.miniCycle.ui.modals.prompt !== 'function') {
            throw new Error('ui.modals.prompt should be a function');
        }
    });

    await test('ui.modals.closeAll() method exists', async () => {
        if (typeof window.miniCycle.ui.modals.closeAll !== 'function') {
            throw new Error('ui.modals.closeAll should be a function');
        }
    });

    await test('ui.loader namespace exists', async () => {
        if (!window.miniCycle.ui.loader) {
            throw new Error('ui.loader missing');
        }
    });

    await test('ui.loader.show() method exists', async () => {
        if (typeof window.miniCycle.ui.loader.show !== 'function') {
            throw new Error('ui.loader.show should be a function');
        }
    });

    await test('ui.loader.hide() method exists', async () => {
        if (typeof window.miniCycle.ui.loader.hide !== 'function') {
            throw new Error('ui.loader.hide should be a function');
        }
    });

    await test('ui.loader.with() method exists', async () => {
        if (typeof window.miniCycle.ui.loader.with !== 'function') {
            throw new Error('ui.loader.with should be a function');
        }
    });

    await test('ui.progress namespace exists', async () => {
        if (!window.miniCycle.ui.progress) {
            throw new Error('ui.progress missing');
        }
    });

    await test('ui.progress.update() method exists', async () => {
        if (typeof window.miniCycle.ui.progress.update !== 'function') {
            throw new Error('ui.progress.update should be a function');
        }
    });

    // ============================================
    // UTILS API TESTS
    // ============================================

    await test('utils.dom namespace exists', async () => {
        if (!window.miniCycle.utils.dom) {
            throw new Error('utils.dom missing');
        }
    });

    await test('utils.dom.addListener() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.addListener !== 'function') {
            throw new Error('utils.dom.addListener should be a function');
        }
    });

    await test('utils.dom.removeListener() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.removeListener !== 'function') {
            throw new Error('utils.dom.removeListener should be a function');
        }
    });

    await test('utils.dom.getById() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.getById !== 'function') {
            throw new Error('utils.dom.getById should be a function');
        }
    });

    await test('utils.dom.queryAll() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.queryAll !== 'function') {
            throw new Error('utils.dom.queryAll should be a function');
        }
    });

    await test('utils.dom.addClass() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.addClass !== 'function') {
            throw new Error('utils.dom.addClass should be a function');
        }
    });

    await test('utils.dom.removeClass() method exists', async () => {
        if (typeof window.miniCycle.utils.dom.removeClass !== 'function') {
            throw new Error('utils.dom.removeClass should be a function');
        }
    });

    await test('utils.storage namespace exists', async () => {
        if (!window.miniCycle.utils.storage) {
            throw new Error('utils.storage missing');
        }
    });

    await test('utils.storage.get() method exists', async () => {
        if (typeof window.miniCycle.utils.storage.get !== 'function') {
            throw new Error('utils.storage.get should be a function');
        }
    });

    await test('utils.storage.set() method exists', async () => {
        if (typeof window.miniCycle.utils.storage.set !== 'function') {
            throw new Error('utils.storage.set should be a function');
        }
    });

    await test('utils.storage.remove() method exists', async () => {
        if (typeof window.miniCycle.utils.storage.remove !== 'function') {
            throw new Error('utils.storage.remove should be a function');
        }
    });

    await test('utils.json namespace exists', async () => {
        if (!window.miniCycle.utils.json) {
            throw new Error('utils.json missing');
        }
    });

    await test('utils.json.parse() method exists', async () => {
        if (typeof window.miniCycle.utils.json.parse !== 'function') {
            throw new Error('utils.json.parse should be a function');
        }
    });

    await test('utils.json.stringify() method exists', async () => {
        if (typeof window.miniCycle.utils.json.stringify !== 'function') {
            throw new Error('utils.json.stringify should be a function');
        }
    });

    await test('utils.sanitize() method exists', async () => {
        if (typeof window.miniCycle.utils.sanitize !== 'function') {
            throw new Error('utils.sanitize should be a function');
        }
    });

    await test('utils.escape() method exists', async () => {
        if (typeof window.miniCycle.utils.escape !== 'function') {
            throw new Error('utils.escape should be a function');
        }
    });

    await test('utils.generateId() method exists', async () => {
        if (typeof window.miniCycle.utils.generateId !== 'function') {
            throw new Error('utils.generateId should be a function');
        }
    });

    await test('utils.generateHashId() method exists', async () => {
        if (typeof window.miniCycle.utils.generateHashId !== 'function') {
            throw new Error('utils.generateHashId should be a function');
        }
    });

    await test('utils.debounce() method exists', async () => {
        if (typeof window.miniCycle.utils.debounce !== 'function') {
            throw new Error('utils.debounce should be a function');
        }
    });

    await test('utils.throttle() method exists', async () => {
        if (typeof window.miniCycle.utils.throttle !== 'function') {
            throw new Error('utils.throttle should be a function');
        }
    });

    // ============================================
    // FUNCTIONAL TESTS
    // ============================================

    await test('utils.sanitize() sanitizes input correctly', async () => {
        const input = '<script>alert("xss")</script>Hello';
        const result = window.miniCycle.utils.sanitize(input, 100);
        if (typeof result !== 'string') {
            throw new Error('sanitize should return a string');
        }
    });

    await test('utils.escape() escapes HTML correctly', async () => {
        const html = '<div>Test & "quotes"</div>';
        const result = window.miniCycle.utils.escape(html);
        if (typeof result !== 'string') {
            throw new Error('escape should return a string');
        }
        if (result.includes('<div>')) {
            throw new Error('HTML tags should be escaped');
        }
    });

    await test('utils.generateId() generates unique IDs', async () => {
        const id1 = window.miniCycle.utils.generateId();
        const id2 = window.miniCycle.utils.generateId();
        if (id1 === id2) {
            throw new Error('Generated IDs should be unique');
        }
    });

    await test('utils.generateHashId() generates consistent hashes', async () => {
        const hash1 = window.miniCycle.utils.generateHashId('test-string');
        const hash2 = window.miniCycle.utils.generateHashId('test-string');
        if (hash1 !== hash2) {
            throw new Error('Hash should be consistent for same input');
        }
    });

    await test('utils.json.parse() handles invalid JSON gracefully', async () => {
        const result = window.miniCycle.utils.json.parse('invalid json', { default: true });
        if (result.default !== true) {
            throw new Error('Should return default value for invalid JSON');
        }
    });

    await test('utils.json.stringify() handles objects', async () => {
        const obj = { test: 'value', number: 123 };
        const result = window.miniCycle.utils.json.stringify(obj);
        if (typeof result !== 'string') {
            throw new Error('stringify should return a string');
        }
        if (!result.includes('test')) {
            throw new Error('stringify should include object properties');
        }
    });

    await test('utils.storage operations work', async () => {
        // Set
        const setResult = window.miniCycle.utils.storage.set('test-key', 'test-value');

        // Get
        const getValue = window.miniCycle.utils.storage.get('test-key');
        if (getValue !== 'test-value') {
            throw new Error('Storage get should return stored value');
        }

        // Remove
        window.miniCycle.utils.storage.remove('test-key');
        const afterRemove = window.miniCycle.utils.storage.get('test-key', 'default');
        if (afterRemove !== 'default') {
            throw new Error('Storage should return default after remove');
        }
    });

    await test('utils.dom.getById() returns element', async () => {
        // Create test element
        const testDiv = document.createElement('div');
        testDiv.id = 'test-namespace-element';
        document.body.appendChild(testDiv);

        try {
            const element = window.miniCycle.utils.dom.getById('test-namespace-element');
            if (element !== testDiv) {
                throw new Error('getById should return the correct element');
            }
        } finally {
            document.body.removeChild(testDiv);
        }
    });

    await test('utils.dom.addClass/removeClass work', async () => {
        const testDiv = document.createElement('div');
        document.body.appendChild(testDiv);

        try {
            window.miniCycle.utils.dom.addClass(testDiv, 'test-class');
            if (!testDiv.classList.contains('test-class')) {
                throw new Error('addClass should add class');
            }

            window.miniCycle.utils.dom.removeClass(testDiv, 'test-class');
            if (testDiv.classList.contains('test-class')) {
                throw new Error('removeClass should remove class');
            }
        } finally {
            document.body.removeChild(testDiv);
        }
    });

    await test('utils.debounce() debounces function calls', async () => {
        let callCount = 0;
        const fn = () => { callCount++; };
        const debounced = window.miniCycle.utils.debounce(fn, 50);

        // Call multiple times
        debounced();
        debounced();
        debounced();

        // Should not execute yet
        if (callCount !== 0) {
            throw new Error('Debounced function should not execute immediately');
        }

        // Wait for debounce
        await new Promise(resolve => setTimeout(resolve, 100));

        // Should execute once
        if (callCount !== 1) {
            throw new Error(`Debounced function should execute once, got ${callCount}`);
        }
    });

    await test('utils.throttle() throttles function calls', async () => {
        let callCount = 0;
        const fn = () => { callCount++; };
        const throttled = window.miniCycle.utils.throttle(fn, 50);

        // Call multiple times
        throttled();
        throttled();
        throttled();

        // Should execute once immediately
        if (callCount !== 1) {
            throw new Error(`Throttled function should execute once, got ${callCount}`);
        }
    });

    // ============================================
    // BACKWARD COMPATIBILITY TESTS
    // ============================================

    await test('backward compatibility: window.showNotification still exists', async () => {
        if (typeof window.showNotification !== 'function') {
            throw new Error('window.showNotification should still exist for backward compatibility');
        }
    });

    await test('backward compatibility: window.addTask still exists', async () => {
        if (typeof window.addTask !== 'function') {
            throw new Error('window.addTask should still exist for backward compatibility');
        }
    });

    await test('backward compatibility: window.sanitizeInput still exists', async () => {
        if (typeof window.sanitizeInput !== 'function') {
            throw new Error('window.sanitizeInput should still exist for backward compatibility');
        }
    });

    // ============================================
    // DEPRECATION WARNING TESTS
    // ============================================

    // TODO: Add deprecation warning tests after ensuring basic functionality works
    // These tests require mocking console.warn which may interfere with test execution

    // ============================================
    // RESULTS
    // ============================================

    restoreOriginalData();

    const percentage = total.count > 0 ? Math.round((passed.count / total.count) * 100) : 0;
    const resultColor = percentage === 100 ? 'green' : percentage >= 70 ? 'orange' : 'red';

    resultsDiv.innerHTML += `<h3 style="color: ${resultColor}">‚úÖ Results: ${passed.count}/${total.count} tests passed (${percentage}%)</h3>`;

    return { passed: passed.count, total: total.count };
}
