miniCycle Modularization Guide 

# Mini Cycle Modularization Guide v2.0

## The Problem

Your app currently has everything in one 3000+ line file. Functions directly access global variables, DOM elements, and localStorage, making testing impossible and maintenance difficult.

## The Solution: Dependency Injection Pattern

Based on the successful `cycleLoader` implementation, this is the recommended approach for all new modules.

### ✅ The Recommended Pattern

```javascript
// utilities/notificationModule.js

// 1. Define dependencies object
const Deps = {
  showNotification: null,
  createElement: null,
  querySelector: null,
  // ... all external dependencies
};

// 2. Setup function
function setNotificationDependencies(overrides = {}) {
  Object.assign(Deps, overrides);
}

// 3. Assertion helper
function assertInjected(name, fn) {
  if (typeof fn !== 'function') {
    throw new Error(`notificationModule: missing dependency ${name}`);
  }
}

// 4. Module functions use injected dependencies
function displayTaskNotification(message) {
  assertInjected('showNotification', Deps.showNotification);
  assertInjected('createElement', Deps.createElement);
  
  // Use injected functions instead of globals
  const element = Deps.createElement('div');
  Deps.showNotification(message, 'success');
}

// 5. Clean exports
export {
  displayTaskNotification,
  setNotificationDependencies,
  // ... other public functions
};
```

### Integration Pattern

```javascript
// In main script
try {
  const notifMod = await import('./utilities/notificationModule.js');
  
  // Set up dependencies BEFORE using module
  notifMod.setNotificationDependencies({
    showNotification: showNotification,
    createElement: document.createElement.bind(document),
    querySelector: document.querySelector.bind(document),
  });
  
  // Now safe to use
  notifMod.displayTaskNotification('Task completed!');
} catch (e) {
  console.error('❌ Module import failed:', e);
}
```

## Why This Pattern Works

**✅ Testable**: Inject mock dependencies for testing  
**✅ Explicit**: All dependencies are clearly defined  
**✅ Reliable**: Fails fast with clear error messages  
**✅ Reusable**: Same module, different contexts  
**✅ Maintainable**: Changes to dependencies don’t break the module

## Previous Approaches (Avoid These)

### ❌ Direct Global Access (Current State)

```javascript
// Don't do this anymore
function updateStats() {
  const tasks = document.querySelectorAll('.task'); // Global DOM access
  localStorage.setItem('stats', JSON.stringify(data)); // Global storage
  showNotification('Updated!'); // Global function call
}
```

### ❌ Window Object Probing

```javascript
// Better than direct globals, but still fragile
function updateStats() {
  const showNotif = window.showNotification || (() => {});
  const storage = window.localStorage || mockStorage;
  // Still couples to global window object
}
```

## Refactor Plan

### Phase 1: High-Impact Modules

**Priority: Start with modules that have clear boundaries**

1. **Notification System** - `showNotifications`, `dragNotifications`
1. **Status Panel** - `updateStatusPanel`, `showStatsPanel`
1. **Storage Utilities** - All localStorage operations
1. **Task Operations** - `addTask`, `deleteTask`, `updateTask`

### Phase 2: UI Modules

1. **Theme System** - Theme switching and unlocks
1. **Modal System** - All popup/modal functionality
1. **Menu System** - Settings and context menus

### Phase 3: Complex Features

1. **Recurring Tasks** - Already partially modular
1. **Drag and Drop** - Touch and mouse handlers
1. **Achievement System** - Milestones and unlocks

## Implementation Steps

### For Each Module:

**1. Identify Dependencies**

```javascript
// List everything the module needs from outside
const Deps = {
  // DOM access
  querySelector: null,
  createElement: null,
  
  // Other modules
  showNotification: null,
  saveData: null,
  
  // External data
  getCurrentUser: null,
};
```

**2. Create Setup Function**

```javascript
function setModuleDependencies(overrides = {}) {
  Object.assign(Deps, overrides);
}
```

**3. Add Assertions**

```javascript
function assertInjected(name, fn) {
  if (typeof fn !== 'function') {
    throw new Error(`moduleName: missing dependency ${name}`);
  }
}
```

**4. Update Functions**

```javascript
// Replace this:
const element = document.querySelector('.task');

// With this:
assertInjected('querySelector', Deps.querySelector);
const element = Deps.querySelector('.task');
```

**5. Export Clean API**

```javascript
export {
  mainFunction,
  setModuleDependencies,
  // Don't export internal functions
};
```

## Integration Template

Use this template for integrating each new module:

```javascript
// In main script
async function initializeModule(modulePath, dependencies) {
  try {
    const module = await import(modulePath);
    module.setDependencies(dependencies);
    return module;
  } catch (e) {
    console.error(`❌ Failed to initialize ${modulePath}:`, e);
    return null;
  }
}

// Usage
const notifModule = await initializeModule('./utilities/notificationModule.js', {
  showNotification: showNotification,
  createElement: document.createElement.bind(document),
});
```

## Testing Benefits

With this pattern, testing becomes straightforward:

```javascript
// Test without real DOM or dependencies
import { displayTaskNotification, setNotificationDependencies } from './notificationModule.js';

// Mock dependencies
const mockDeps = {
  showNotification: jest.fn(),
  createElement: jest.fn(() => ({ /* mock element */ })),
};

setNotificationDependencies(mockDeps);
displayTaskNotification('test');

// Assert mock was called correctly
expect(mockDeps.showNotification).toHaveBeenCalledWith('test', 'success');
```

## Success Metrics

You’ll know modularization is working when:

- ✅ Functions no longer directly access `document` or `window`
- ✅ Each module has clear, documented dependencies
- ✅ You can test module logic without a browser
- ✅ New features can be developed as separate modules
- ✅ Code changes don’t ripple across unrelated functions

## Next Steps

1. **Start with Notification Module** - It’s small and has clear boundaries
1. **Use this as a template** for all subsequent modules
1. **Update this guide** based on what you learn during implementation
1. **Gradually migrate** existing functions to use the new pattern

Remember: **This pattern is based on your successful cycleLoader implementation.** You’ve already proven it works - now apply it consistently across your codebase.