# Service Worker Update Strategy

**Version:** 1.330 (January 2025)
**Last Updated:** October 2025
**Problem Solved:** Users with old cached service workers and modules not receiving updates

---

## üéØ The Problem

### Original Issue (v1.326)
Users had old service workers that:
- Were cached by the browser (preventing updates)
- Didn't have `updateViaCache: 'none'`
- Never detected new versions (missing periodic update checks)

### Additional Issue Discovered (v1.329-1.330)
**Module Cache Duplication:**
- Dynamic imports loaded modules **without** version parameters
- HTML loaded modules **with** version parameters (`?v=1.329`)
- Result: Two cache entries per module (e.g., `notifications.js` AND `notifications.js?v=1.329`)
- Service worker cached both versions
- Users stuck on old cached modules even when HTML version incremented

**Example of the problem:**
```javascript
// HTML loaded (versioned):
<script src="utilities/notifications.js?v=1.329"></script>

// Dynamic import (un-versioned):
await import('./utilities/notifications.js');  // ‚ùå Different URL!

// Result: Both URLs cached separately, updates don't propagate
```

**Root Cause:** Inconsistent URL patterns across import methods created duplicate cache entries that persisted across version updates.

---

## ‚úÖ The Solution (4-Part Strategy)

### **1. version.js - Single Source of Truth (NEW in v1.330)**
```javascript
// version.js - Auto-generated by update-version.sh
self.APP_VERSION = '1.330';

// Make available in browser window context
if (typeof window !== 'undefined') {
  window.APP_VERSION = self.APP_VERSION;
}
```

**Why:**
- Provides **one** version number used by all contexts
- Service worker uses `importScripts('./version.js')`
- Browser window loads via `<script src="./version.js"></script>`
- Ensures version consistency across all module imports

### **2. Versioned Module Imports with withV() Helper**
```javascript
// miniCycle-scripts.js - Load version helper
const withV = (path) => `${path}?v=${window.APP_VERSION}`;

// Exception: appInit must stay un-versioned (singleton pattern)
const { appInit } = await import('./utilities/appInitialization.js');

// All other modules use versioned imports
const { MiniCycleNotifications } = await import(withV('./utilities/notifications.js'));
// Loads: ./utilities/notifications.js?v=1.330
```

**Why:**
- Every module import uses **same versioned URL** as HTML
- Version increment invalidates **all** module caches simultaneously
- No duplicate cache entries (one URL per module)

### **3. Version Parameter on SW URL**
```javascript
const SW_VERSION = '1330'; // Increment this when updating SW
navigator.serviceWorker.register(`./service-worker.js?v=${SW_VERSION}`, {
  updateViaCache: 'none'  // Prevents browser caching
});
```

**Why:** Changing the URL forces browser to fetch new file (bypasses cache).

### **4. Automatic Old SW Cleanup**
```javascript
// Detect and remove old service workers without version parameter
const existingRegistrations = await navigator.serviceWorker.getRegistrations();
for (const reg of existingRegistrations) {
  const scriptURL = reg.active?.scriptURL || reg.waiting?.scriptURL || reg.installing?.scriptURL;
  if (scriptURL && scriptURL.includes('service-worker.js') && !scriptURL.includes('?v=')) {
    await reg.unregister();
    // Prompt user to reload once
  }
}
```

**Why:** Automatically migrates users from old system to new system.

### **5. Periodic Update Checks**
```javascript
// Check for updates every 60 seconds
setInterval(() => {
  if (!document.hidden && registration) {
    registration.update();
  }
}, 60000);

// Also check when user switches back to tab
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && registration) {
    registration.update();
  }
});
```

**Why:** Ensures users see updates within 60 seconds of deployment.

---

## üìã What Happens for Existing Users

### **First Visit After v1.326 Deploy:**

1. **Page loads** with old service worker
2. **Detection:** Script finds old SW (no `?v=` parameter)
3. **Cleanup:** Unregisters old SW automatically
4. **Notification:** User sees one-time update prompt:
   - Title: "üîÑ Important App Update"
   - Message: Explains this is a one-time migration
   - Buttons: "Reload Now" or "Later"
5. **User reloads** ‚Üí New SW installs with version parameter
6. **Future updates** now work automatically (60-second checks)

### **All Future Visits:**

1. **Page loads** with new versioned SW
2. **Background checks** every 60 seconds + on tab focus
3. **Update detected** ‚Üí Two-step confirmation:
   - Step 1: "Prepare Update" (installs in background)
   - Step 2: "Reload Now" or "Later" (user controls timing)
4. **No forced reload** unless user confirms

---

## üîß Server Configuration (Optional but Recommended)

Add these headers to `service-worker.js`:

### Apache (.htaccess)
```apache
<Files "service-worker.js">
  Header set Cache-Control "no-cache, no-store, must-revalidate"
  Header set Pragma "no-cache"
  Header set Expires "0"
</Files>
```

### Nginx
```nginx
location /service-worker.js {
  add_header Cache-Control "no-cache, no-store, must-revalidate";
  add_header Pragma "no-cache";
  add_header Expires "0";
}
```

**Why:** Prevents CDNs/proxies from caching the SW file (defense in depth).

---

## üöÄ Deploying Future Updates

### When you update service-worker.js:

1. **Increment version in service-worker.js:**
   ```javascript
   var APP_VERSION = '1.327';
   var CACHE_VERSION = 'v104';
   ```

2. **Increment SW_VERSION in miniCycle.html:**
   ```javascript
   const SW_VERSION = '1327';
   ```

3. **Deploy both files together**

4. **Users get updates within 60 seconds:**
   - Background check detects new `?v=1327` URL
   - New SW installs
   - User sees two-step confirmation
   - User controls when to reload

---

## üìä Update Timeline

| Time | What Happens |
|------|--------------|
| **T+0s** | Deploy v1.327 to server |
| **T+30s** | User's browser checks for update (periodic or visibility check) |
| **T+32s** | Browser fetches `service-worker.js?v=1327` |
| **T+33s** | New SW installs in background |
| **T+34s** | User sees "Prepare Update" modal |
| **User clicks** | "Prepare Update" ‚Üí Update installs |
| **User clicks** | "Reload Now" ‚Üí Page reloads with new SW |

**Total time to notification:** ~30-60 seconds
**User has full control:** Yes, can delay reload

---

## üõ°Ô∏è Safeguards

1. **sessionStorage flag** prevents repeated migration prompts
2. **`refreshing` flag** prevents multiple simultaneous reloads
3. **User confirmation** required before any reload
4. **Fallback to browser confirm** if modal not available
5. **Old SW cleanup** only runs once per user

---

## üîç Debugging

### Check current SW version in console:
```javascript
navigator.serviceWorker.getRegistration().then(reg => {
  console.log('Active SW:', reg.active?.scriptURL);
});
```

### Force update check:
```javascript
navigator.serviceWorker.getRegistration().then(reg => {
  reg.update();
});
```

### Check for old SW:
```javascript
navigator.serviceWorker.getRegistrations().then(regs => {
  regs.forEach(reg => {
    const url = reg.active?.scriptURL;
    console.log('SW URL:', url);
    console.log('Has version?', url?.includes('?v='));
  });
});
```

---

## üìù Key Files

- **miniCycle.html** (lines 114-280): SW registration and update logic
- **service-worker.js** (lines 1-5): APP_VERSION and CACHE_VERSION
- **docs/SERVICE_WORKER_UPDATE_STRATEGY.md**: This document

---

## ‚úÖ Success Criteria

- [x] Users automatically migrate from old SW to new SW
- [x] Updates detected within 60 seconds
- [x] User controls when page reloads
- [x] Two-step confirmation (Prepare ‚Üí Reload)
- [x] No forced reloads
- [x] Works for all existing users automatically
- [x] Future updates work reliably

---

## üéì Lessons Learned

### Service Worker Updates (v1.326)
1. **Service worker file caching** is a real problem - always use `updateViaCache: 'none'`
2. **Version parameters** force browsers to fetch new files
3. **Automatic cleanup** handles migration gracefully
4. **Periodic checks** ensure users see updates quickly
5. **User control** improves UX (no surprise reloads)
6. **One-time migration** is acceptable if well-communicated

### Module Cache Duplication (v1.329-1.330)
7. **Dynamic imports MUST use same URL as static imports** - inconsistent URLs create duplicates
8. **ES6 modules cache by exact URL** - `module.js` and `module.js?v=1` are DIFFERENT cache entries
9. **Service workers cache both versions** - leading to "stuck on old version" even after updates
10. **withV() helper prevents duplicates** - centralized versioning ensures consistency
11. **version.js single source of truth** - one file to update, propagates everywhere
12. **appInit singleton exception** - some modules need un-versioned imports to share state
13. **Testing in production revealed the issue** - local development masks caching problems

### Key Insight
**The cache duplication was invisible until production:**
- Development: Hard refresh (`Cmd+Shift+R`) bypasses cache, masks problem
- Production: Users never hard refresh, cache persists indefinitely
- Solution: Versioned imports + increment on every deploy = forced cache refresh

---

**Status:** ‚úÖ Deployed in v1.330
**Last Updated:** October 2025
**Next Review:** Monitor production cache hits/misses
