<!DOCTYPE html>
<html lang="en" role="document">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="../assets/images/logo/taskcycle_logo_blackandwhite_transparent.png" />
  <title>Task Whack-a-Order - Mini Game</title>
  <style>
    /* üåê Game Layout */
body {
  font-family: 'Poppins', sans-serif;
  background: rgb(177, 177, 177);
  margin: 0;
  padding: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}

/* üéÆ Game Container */
.game-container {
  background: rgb(87, 137, 172);
  padding: 30px 40px;
  border: solid 2px rgba(0, 0, 0, 0.474);
  border-radius: 16px;
  box-shadow: 0 12px 28px rgba(0, 0, 0, 0.15);
  text-align: center;
  max-width: 650px;
  width: 100%;
  transition: transform 0.3s ease;
}
.game-container:hover {
  transform: scale(1.01);
}

/* üß† Header */
h1 {
  color: #2a2e47;
  font-size: 26px;
  margin-bottom: 12px;
}

/* üéöÔ∏è Difficulty Selector */
.difficulty-selector {
  margin: 15px 0;
  display: flex;
  gap: 10px;
  justify-content: center;
}
.difficulty-btn {
  padding: 8px 16px;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  color: white;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.3s ease;
}
.difficulty-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}
.difficulty-btn.active {
  background: #4c79ff;
  border-color: #4c79ff;
  box-shadow: 0 4px 12px rgba(76, 121, 255, 0.4);
}

/* üìã Instructions & Score */
#instructions {
  margin-bottom: 10px;
  color: #f2f1f1;
  font-size: 14px;
}
#scoreboard {
  font-size: 16px;
  font-weight: 500;
  color: #f6f6f6;
  margin-bottom: 16px;
}

/* ‚¨ú Task Field */
#taskWindow {
  position: relative;
  width: 100%;
  height: 320px;
  border: 2px dashed #ccc;
  border-radius: 12px;
  overflow: hidden;
  margin-bottom: 16px;
  background: linear-gradient(white, rgb(187, 211, 247));
}

/* üü¶ Task Buttons */
.task-btn {
  position: absolute;
  padding: 10px 14px;
  background: #4c79ff;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
.task-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(76, 121, 255, 0.4);
}
.task-btn.clicked {
  background: #28a745;
  cursor: default;
  animation: successPulse 0.4s ease;
}
.task-btn:focus {
  outline: 3px solid yellow;
  outline-offset: 2px;
}

/* ‚ú® Animations */
@keyframes successPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes particle {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--tx), var(--ty)) scale(0);
    opacity: 0;
  }
}

/* üí¨ Feedback Text */
.feedback {
  font-size: 18px;
  font-weight: bold;
  color: #444;
  margin-top: 12px;
  min-height: 24px;
  animation: fadeIn 0.4s ease;
}
.feedback.success {
  color: #28a745;
}
.feedback.error {
  color: #ff4d4d;
}

/* üéâ Particle Effect */
.particle {
  position: absolute;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  pointer-events: none;
  animation: particle 0.8s ease-out forwards;
}

/* üîÅ Restart Button */
#restartBtn {
  display: none;
  margin: 14px auto 0 auto;
  padding: 10px 20px;
  font-size: 15px;
  border: none;
  background: #ff4d4d;
  color: white;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
}
#restartBtn:hover {
  background: #e04343;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(255, 77, 77, 0.4);
}

/* üèÜ Leaderboard */
#leaderboard {
  margin-top: 20px;
  font-size: 14px;
  color: #2a2e47;
  background: rgba(255, 255, 255, 0.2);
  padding: 12px;
  border-radius: 8px;
}
#leaderboard div {
  margin: 4px 0;
}

/* üîô Back Button */
#back-to-minicycle {
  margin-top: 24px;
  padding: 10px 18px;
  font-size: 15px;
  background: #333;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
}
#back-to-minicycle:hover {
  background: #222;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
  </style>
</head>
<body>
  <main role="main">
    <div class="game-container" aria-label="Whack-a-Order Mini Game">
    <h1>Task Whack-a-Order</h1>

    <!-- Difficulty Selector -->
    <div class="difficulty-selector">
      <button class="difficulty-btn active" data-difficulty="easy">Easy</button>
      <button class="difficulty-btn" data-difficulty="normal">Normal</button>
      <button class="difficulty-btn" data-difficulty="hard">Hard</button>
    </div>

    <div id="instructions">
      Click the tasks in the correct order (1, 2, 3, ...). They will move faster each round!
    </div>
    <div id="scoreboard" aria-live="polite">Round: 1 | Score: 0</div>
    <!-- Task Window Container -->
    <div id="taskWindow" aria-label="Task field"></div>
    <div class="feedback" id="feedback" aria-live="polite"></div>
    <button id="restartBtn" aria-label="Restart Game">Restart Game</button>
    <!-- Leaderboard Display -->
    <div id="leaderboard">
      <div><strong>Your Best (Easy):</strong></div>
      <div>Highest Round: <span id="bestRound">0</span></div>
      <div>Fastest Time: <span id="bestTime">--</span> seconds</div>
    </div>
    <button id="back-to-minicycle" aria-label="Go back to miniCycle">Back to miniCycle</button>
  </div>

  <script>
    /***** Difficulty Settings *****/
    const DIFFICULTY_SETTINGS = {
      easy: {
        baseSpeed: 80,        // Base velocity multiplier
        speedIncrease: 10,    // Speed increase per round
        maxRounds: 10,
        label: 'Easy'
      },
      normal: {
        baseSpeed: 120,
        speedIncrease: 15,
        maxRounds: 10,
        label: 'Normal'
      },
      hard: {
        baseSpeed: 160,
        speedIncrease: 20,
        maxRounds: 15,
        label: 'Hard'
      }
    };

    let currentDifficulty = 'easy';

    /***** Schema 2.5 Integration *****/
    function getSchema25Data() {
      try {
        // Debug: Show current origin and localStorage contents
        console.log('üîç Current origin:', window.location.origin);
        console.log('üîç localStorage keys:', Object.keys(localStorage));

        const rawData = localStorage.getItem("miniCycleData");
        console.log('üîç Raw miniCycleData:', rawData ? `${rawData.length} chars` : 'null');

        if (!rawData) {
          console.warn('‚ö†Ô∏è Schema 2.5 data not found - localStorage is empty or key missing');
          console.warn('üí° Make sure you are running the game from the same origin as miniCycle');
          console.warn('üí° Expected: same protocol, domain, and port (e.g., http://localhost:8080)');
          return null;
        }

        const schemaData = JSON.parse(rawData);
        if (!schemaData) {
          console.warn('‚ö†Ô∏è Schema 2.5 data parsed as null/undefined');
          return null;
        }

        // Schema version is stored as string "2.5" not number
        console.log('üîç Schema version found:', schemaData.schemaVersion, typeof schemaData.schemaVersion);
        if (schemaData.schemaVersion !== "2.5") {
          console.warn('‚ö†Ô∏è Schema outdated:', schemaData.schemaVersion, '(expected "2.5")');
          return null;
        }
        console.log('‚úÖ Schema 2.5 data loaded successfully');
        return schemaData;
      } catch (error) {
        console.error('‚ùå Error reading Schema 2.5 data:', error);
        return null;
      }
    }

    function saveGameStatsToSchema25(difficulty, round, time) {
      try {
        const schemaData = getSchema25Data();
        if (!schemaData) {
          console.warn('‚ö†Ô∏è Cannot save stats - no Schema 2.5 data');
          return false;
        }

        // Ensure settings object exists
        if (!schemaData.settings) {
          schemaData.settings = {};
        }

        // Initialize game stats if not exists
        if (!schemaData.settings.gameStats) {
          schemaData.settings.gameStats = {
            taskOrderGame: {
              easy: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 },
              normal: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 },
              hard: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 }
            }
          };
        }

        // Ensure taskOrderGame exists
        if (!schemaData.settings.gameStats.taskOrderGame) {
          schemaData.settings.gameStats.taskOrderGame = {
            easy: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 },
            normal: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 },
            hard: { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 }
          };
        }

        // Ensure this difficulty exists
        if (!schemaData.settings.gameStats.taskOrderGame[difficulty]) {
          schemaData.settings.gameStats.taskOrderGame[difficulty] = {
            bestRound: 0,
            bestTime: Infinity,
            gamesPlayed: 0
          };
        }

        const stats = schemaData.settings.gameStats.taskOrderGame[difficulty];

        // Update stats
        if (round > stats.bestRound) stats.bestRound = round;
        if (time < stats.bestTime) stats.bestTime = time;
        stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
        stats.lastPlayed = Date.now();

        // Save back to localStorage
        localStorage.setItem("miniCycleData", JSON.stringify(schemaData));
        console.log('‚úÖ Game stats saved to Schema 2.5:', { difficulty, round, time, gamesPlayed: stats.gamesPlayed });
        return true;
      } catch (error) {
        console.error('‚ùå Error saving game stats:', error);
        return false;
      }
    }

    function loadGameStatsFromSchema25(difficulty) {
      try {
        const schemaData = getSchema25Data();
        if (!schemaData || !schemaData.settings.gameStats?.taskOrderGame) {
          return { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 };
        }
        return schemaData.settings.gameStats.taskOrderGame[difficulty] ||
               { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 };
      } catch (error) {
        console.error('‚ùå Error loading game stats:', error);
        return { bestRound: 0, bestTime: Infinity, gamesPlayed: 0 };
      }
    }

    /***** Game Setup *****/
    // Retrieve task names from Schema 2.5
    function getTaskNames() {
      const schemaData = getSchema25Data();
      if (!schemaData) {
        console.warn('‚ö†Ô∏è Using fallback tasks - Schema 2.5 data not available');
        return [];
      }

      const activeCycleId = schemaData.appState?.activeCycleId;
      if (!activeCycleId) {
        console.warn('‚ö†Ô∏è No active cycle found');
        return [];
      }

      // Schema 2.5 structure: cycles is nested in data.cycles
      const currentCycle = schemaData.data?.cycles?.[activeCycleId];
      if (!currentCycle || !Array.isArray(currentCycle.tasks)) {
        console.warn('‚ö†Ô∏è No tasks found in active cycle:', activeCycleId);
        console.warn('Available cycles:', Object.keys(schemaData.data?.cycles || {}));
        return [];
      }

      const names = currentCycle.tasks
        .map(task => task.text)
        .filter(text => text && text.trim() !== "");

      console.log(`‚úÖ Loaded ${names.length} tasks from Schema 2.5 (cycle: ${activeCycleId})`);
      return names;
    }

    // Use fallback tasks if none are found
    let tasks = getTaskNames();
    if (tasks.length === 0) {
      tasks = [
        "Inspect Part", "Check Serial", "Verify Job", "Record Number",
        "Update Log", "Order Supplies", "Calibrate Tool", "Review Report",
        "Confirm Specs", "Test Output", "Schedule Meeting", "File Report"
      ];
      console.log('‚ÑπÔ∏è Using fallback tasks');
    }

    let round = 1;
    let score = 0;
    let expectedOrder = 1;
    let gameActive = true;
    let gameStartTime = null;

    const taskWindow = document.getElementById("taskWindow");
    const feedbackEl = document.getElementById("feedback");
    const scoreboardEl = document.getElementById("scoreboard");
    const restartBtn = document.getElementById("restartBtn");
    const bestRoundEl = document.getElementById("bestRound");
    const bestTimeEl = document.getElementById("bestTime");
    const backToMiniCycle = document.getElementById("back-to-minicycle");
    const difficultyButtons = document.querySelectorAll('.difficulty-btn');

    let currentTasks = [];
    let movementAnimationFrame = null;
    let lastTimestamp = null;

    /***** Difficulty Selection *****/
    difficultyButtons.forEach(btn => {
      btn.addEventListener('click', function() {
        if (!gameActive && round > 1) {
          // Don't allow difficulty change mid-game
          return;
        }

        difficultyButtons.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        currentDifficulty = this.dataset.difficulty;

        // Update leaderboard display
        updateLeaderboardDisplay();

        // Restart game with new difficulty
        if (round > 1) {
          restartGame();
        }
      });
    });

    /***** Particle Effects *****/
    function createParticles(x, y, color) {
      const particleCount = 12;
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.background = color;
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';

        const angle = (Math.PI * 2 * i) / particleCount;
        const distance = 50 + Math.random() * 50;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;

        particle.style.setProperty('--tx', tx + 'px');
        particle.style.setProperty('--ty', ty + 'px');

        taskWindow.appendChild(particle);

        setTimeout(() => particle.remove(), 800);
      }
    }

    /***** Leaderboard Functions *****/
    function updateLeaderboard(currentRound, elapsedTime) {
      saveGameStatsToSchema25(currentDifficulty, currentRound, elapsedTime);
      updateLeaderboardDisplay();
    }

    function updateLeaderboardDisplay() {
      const stats = loadGameStatsFromSchema25(currentDifficulty);
      const difficultyLabel = DIFFICULTY_SETTINGS[currentDifficulty].label;

      document.querySelector('#leaderboard strong').textContent =
        `Your Best (${difficultyLabel}):`;
      bestRoundEl.textContent = stats.bestRound;
      bestTimeEl.textContent = stats.bestTime === Infinity ? "--" :
        Math.floor(stats.bestTime / 1000);
    }

    /***** Game Functions *****/
    function startRound() {
      if (round === 1) {
        gameStartTime = Date.now();
      }
      clearTasks();
      feedbackEl.textContent = "";
      feedbackEl.className = "feedback";
      expectedOrder = 1;
      scoreboardEl.textContent = `Round: ${round} | Score: ${score}`;

      // Randomly select up to 10 tasks
      let roundTasks = shuffleArray(tasks);
      if (roundTasks.length > 10) {
        roundTasks = roundTasks.slice(0, 10);
      }
      currentTasks = roundTasks.map((task, index) => ({
        order: index + 1,
        text: task
      }));

      // Create moving buttons for each task
      currentTasks.forEach(taskObj => {
        createMovingTaskButton(taskObj);
      });

      // Start the animation loop
      lastTimestamp = null;
      startMovement();
    }

    // Create a task button with difficulty-based velocity
    function createMovingTaskButton(taskObj) {
      const btn = document.createElement("button");
      btn.className = "task-btn";
      btn.textContent = `${taskObj.order}. ${taskObj.text}`;
      btn.dataset.order = taskObj.order;

      // Set initial random position
      const pos = getRandomPosition();
      btn.style.left = pos.x + "px";
      btn.style.top = pos.y + "px";

      // Calculate velocity based on difficulty and round
      const settings = DIFFICULTY_SETTINGS[currentDifficulty];
      const speedMultiplier = settings.baseSpeed + (round - 1) * settings.speedIncrease;

      // Random velocity with consistent speed
      const angle = Math.random() * Math.PI * 2;
      const speed = speedMultiplier * (0.8 + Math.random() * 0.4); // ¬±20% variance

      btn.dataset.dx = (Math.cos(angle) * speed).toFixed(2);
      btn.dataset.dy = (Math.sin(angle) * speed).toFixed(2);

      btn.addEventListener("click", function(e) {
        if (!gameActive) return;
        const clickedOrder = parseInt(this.dataset.order, 10);

        if (clickedOrder === expectedOrder) {
          // Success!
          this.classList.add("clicked");
          this.disabled = true;

          // Create success particles
          const rect = this.getBoundingClientRect();
          const windowRect = taskWindow.getBoundingClientRect();
          const x = rect.left - windowRect.left + rect.width / 2;
          const y = rect.top - windowRect.top + rect.height / 2;
          createParticles(x, y, '#28a745');

          expectedOrder++;

          if (expectedOrder > currentTasks.length) {
            const settings = DIFFICULTY_SETTINGS[currentDifficulty];

            // Check if game is won
            if (round >= settings.maxRounds) {
              score++;
              stopMovement();
              const elapsedTime = Date.now() - gameStartTime;
              feedbackEl.textContent = `üéâ Winner! Time: ${Math.floor(elapsedTime / 1000)}s`;
              feedbackEl.className = "feedback success";
              updateLeaderboard(round, elapsedTime);
              gameActive = false;
              restartBtn.style.display = "block";
              return;
            }

            // Continue to next round
            score++;
            feedbackEl.textContent = "Round complete! üéâ";
            feedbackEl.className = "feedback success";
            stopMovement();
            round++;
            setTimeout(startRound, 1500);
          }
        } else {
          // Wrong order!
          feedbackEl.textContent = "Wrong order! Game Over! ‚ùå";
          feedbackEl.className = "feedback error";
          gameActive = false;
          stopMovement();

          const elapsedTime = Date.now() - gameStartTime;
          updateLeaderboard(round, elapsedTime);

          restartBtn.style.display = "block";
        }
      });

      btn.addEventListener("keydown", function (e) {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.click();
        }
      });

      taskWindow.appendChild(btn);
    }

    // Get a random position within taskWindow boundaries
    function getRandomPosition() {
      const rect = taskWindow.getBoundingClientRect();
      const maxX = rect.width - 120;
      const maxY = rect.height - 60;
      return {
        x: Math.floor(Math.random() * maxX),
        y: Math.floor(Math.random() * maxY)
      };
    }

    // Helper to shuffle an array
    function shuffleArray(arr) {
      let array = [...arr];
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Clear all task buttons from taskWindow
    function clearTasks() {
      const buttons = document.querySelectorAll(".task-btn");
      buttons.forEach(btn => btn.remove());
      const particles = document.querySelectorAll(".particle");
      particles.forEach(p => p.remove());
    }

    /***** Smooth Movement using requestAnimationFrame *****/
    function animateButtons(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;

      const rect = taskWindow.getBoundingClientRect();
      const buttons = document.querySelectorAll(".task-btn:not(.clicked)");

      buttons.forEach(btn => {
        let x = parseFloat(btn.style.left);
        let y = parseFloat(btn.style.top);
        let dx = parseFloat(btn.dataset.dx);
        let dy = parseFloat(btn.dataset.dy);

        // Update positions
        x += dx * dt;
        y += dy * dt;

        // Bounce off boundaries with slight speed randomization
        if (x < 0) {
          x = 0;
          dx = -dx * (0.9 + Math.random() * 0.2);
          btn.dataset.dx = dx;
        }
        if (x > rect.width - btn.offsetWidth) {
          x = rect.width - btn.offsetWidth;
          dx = -dx * (0.9 + Math.random() * 0.2);
          btn.dataset.dx = dx;
        }
        if (y < 0) {
          y = 0;
          dy = -dy * (0.9 + Math.random() * 0.2);
          btn.dataset.dy = dy;
        }
        if (y > rect.height - btn.offsetHeight) {
          y = rect.height - btn.offsetHeight;
          dy = -dy * (0.9 + Math.random() * 0.2);
          btn.dataset.dy = dy;
        }

        btn.style.left = x + "px";
        btn.style.top = y + "px";
      });

      movementAnimationFrame = requestAnimationFrame(animateButtons);
    }

    function startMovement() {
      stopMovement();
      movementAnimationFrame = requestAnimationFrame(animateButtons);
    }

    function stopMovement() {
      if (movementAnimationFrame) {
        cancelAnimationFrame(movementAnimationFrame);
        movementAnimationFrame = null;
      }
    }

    /***** Restart Game Handler *****/
    function restartGame() {
      gameActive = true;
      round = 1;
      score = 0;
      restartBtn.style.display = "none";
      feedbackEl.textContent = "";
      feedbackEl.className = "feedback";
      startRound();
    }

    restartBtn.addEventListener("click", restartGame);

    backToMiniCycle.addEventListener("click", function() {
      window.location.href = "../miniCycle.html";
    });

    // Initialize leaderboard and start game
    window.onload = function() {
      updateLeaderboardDisplay();
      startRound();
    };
  </script>
  </main>
</body>
</html>
