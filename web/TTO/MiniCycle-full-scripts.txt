MiniCycle 

// Create a global state object to avoid module scoping issues
window.AppState = {
Â Â draggedTask: null,
Â Â logoTimeoutId: null,
Â Â touchStartTime: 0,
Â Â isLongPress: false,
Â Â touchStartY: 0,
Â Â touchEndY: 0,
Â Â holdTimeout: null,
Â Â moved: false,
Â Â isDragging: false,
Â Â rearrangeInitialized: false,
Â Â lastDraggedOver: null,
Â Â lastRearrangeTarget: null,
Â Â lastDragOverTime: 0,
Â Â hasInteracted: false,
Â Â reminderIntervalId: null,
Â Â timesReminded: 0,
Â Â lastReminderTime: null,
Â Â isResetting: false,
Â Â undoSnapshot: null,
Â Â redoSnapshot: null,
Â Â undoStack: [],
Â Â redoStack: [],
Â Â didDragReorderOccur: false,
Â Â lastReorderTime: 0,
Â Â advancedVisible: false
};

// For backward compatibility, also create the variables
let draggedTask = null;
let logoTimeoutId = null;
let touchStartTime = 0;
let isLongPress = false;
let touchStartY = 0;
let touchEndY = 0;
let holdTimeout = null;
let moved = false;
let isDragging = false;
let rearrangeInitialized = false;
let lastDraggedOver = null;
let lastRearrangeTarget = null;
let lastDragOverTime = 0;
let hasInteracted = false;
let reminderIntervalId = null;
let timesReminded = 0;
let lastReminderTime = null;
let isResetting = false;
let undoSnapshot = null;
let redoSnapshot = null;
const UNDO_LIMIT = 4;
let undoStack = [];
let redoStack = [];
let didDragReorderOccur = false;
let lastReorderTime = 0;
const REORDER_SNAPSHOT_INTERVAL = 500;
let advancedVisible = false;
let isDraggingNotification = false;

// âœ… Temporary placeholder functions for stats panel (will be replaced when module loads)
window.updateStatsPanel = function() {
Â Â Â Â console.log('ğŸ“Š updateStatsPanel called before StatsPanelManager is ready - queuing for later');
};
window.showStatsPanel = function() {
Â Â Â Â console.log('ğŸ“Š showStatsPanel called before StatsPanelManager is ready');
};
window.showTaskView = function() {
Â Â Â Â console.log('ğŸ“Š showTaskView called before StatsPanelManager is ready');
};

document.addEventListener('DOMContentLoaded', async (event) => {
Â Â Â Â console.log('ğŸš€ Starting miniCycle initialization (Schema 2.5 only)...');


Â Â Â Â /******
Â Â Â Â Â *Â 
Â Â Â Â Â * Import utility modules
Â Â Â Â */

Â Â Â Â // Import global utilities first (foundational functions)
Â Â Â Â await import('./utilities/globalUtils.js');
Â Â Â Â console.log('ğŸ› ï¸ Global utilities loaded');

Â Â Â Â // Import console capture module
Â Â Â Â const { default: consoleCapture } = await import('./utilities/consoleCapture.js');
Â Â Â Â 
Â Â Â Â // Make console capture globally accessible
Â Â Â Â window.consoleCapture = consoleCapture;

Â Â Â Â // Import and initialize notification system
Â Â Â Â const { MiniCycleNotifications } = await import('./utilities/notifications.js');
Â Â Â Â const notifications = new MiniCycleNotifications();
Â Â Â Â 
Â Â Â Â // Make notifications globally accessible
Â Â Â Â window.notifications = notifications;
Â Â Â Â window.showNotification = (message, type, duration) => notifications.show(message, type, duration);
Â Â Â Â 
Â Â Â Â // Import and initialize device detection
Â Â Â Â console.log('ğŸ“± Initializing device detection module...');
Â Â Â Â const { DeviceDetectionManager } = await import('./utilities/deviceDetection.js');
Â Â Â Â 
Â Â Â Â const deviceDetectionManager = new DeviceDetectionManager({
Â Â Â Â Â Â Â Â loadMiniCycleData: () => window.loadMiniCycleData ? window.loadMiniCycleData() : null,
Â Â Â Â Â Â Â Â showNotification: (msg, type, duration) => window.showNotification ? window.showNotification(msg, type, duration) : console.log('Notification:', msg),
Â Â Â Â Â Â Â Â currentVersion: '1.280'
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Make globally accessible
Â Â Â Â window.deviceDetectionManager = deviceDetectionManager;

Â Â Â Â Â Â Â // Around line 100 where you initialize StatsPanelManager, update it:
Â Â Â Â 
Â Â Â Â // Import and initialize stats panel manager
Â Â Â Â console.log('ğŸ“Š Initializing stats panel module...');
Â Â Â Â const { StatsPanelManager } = await import('./utilities/statsPanel.js');
Â Â Â Â 
Â Â Â Â // âœ… Don't wait arbitrarily - wait for data to be ready
Â Â Â Â const statsPanelManager = new StatsPanelManager({
Â Â Â Â Â Â Â Â showNotification: (msg, type, duration) => window.showNotification ? window.showNotification(msg, type, duration) : console.log('Notification:', msg),
Â Â Â Â Â Â Â Â loadMiniCycleData: () => {
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… More defensive data loading
Â Â Â Â Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const result = window.loadMiniCycleData ? window.loadMiniCycleData() : null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!result) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ï¿½ StatsPanelManager: Data not ready yet');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return result;
Â Â Â Â Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ StatsPanelManager: Error loading data:', error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return null;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â isOverlayActive: () => window.isOverlayActive ? window.isOverlayActive() : false
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Make globally accessible - replace placeholder functions
Â Â Â Â window.statsPanelManager = statsPanelManager;
Â Â Â Â window.showStatsPanel = () => statsPanelManager.showStatsPanel();
Â Â Â Â window.showTaskView = () => statsPanelManager.showTaskView();
Â Â Â Â window.updateStatsPanel = () => {
Â Â Â Â Â Â Â Â // âœ… Only call if data is available
Â Â Â Â Â Â Â Â const dataAvailable = window.loadMiniCycleData && window.loadMiniCycleData();
Â Â Â Â Â Â Â Â if (dataAvailable) {
Â Â Â Â Â Â Â Â Â Â Â Â return statsPanelManager.updateStatsPanel();
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Skipping stats update - data not ready');
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â console.log('ğŸ“Š StatsPanelManager global functions updated');
Â Â Â Â // âœ… isOverlayActive function (needed by various parts of the app)
Â Â Â Â window.isOverlayActive = function() {
Â Â Â Â Â Â Â Â // Check for visible menu
Â Â Â Â Â Â Â Â if (document.querySelector(".menu-container.visible")) return true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Check for open modals/overlays
Â Â Â Â Â Â Â Â const overlaySelectors = [
Â Â Â Â Â Â Â Â Â Â Â Â '.settings-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '.mini-cycle-switch-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#feedback-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#about-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#themes-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#games-panel[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#reminders-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#testing-modal[style*="display: flex"]',
Â Â Â Â Â Â Â Â Â Â Â Â '#recurring-panel-overlay:not(.hidden)',
Â Â Â Â Â Â Â Â Â Â Â Â '.notification-container .notification',
Â Â Â Â Â Â Â Â Â Â Â Â '#storage-viewer-overlay:not(.hidden)',Â  // Local storage viewer
Â Â Â Â Â Â Â Â Â Â Â Â '.mini-modal-overlay',Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Confirmation/prompt modals
Â Â Â Â Â Â Â Â Â Â Â Â '.miniCycle-overlay', Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Your prompt modals
Â Â Â Â Â Â Â Â Â Â Â Â '.onboarding-modal:not([style*="display: none"])'Â  // Onboarding
Â Â Â Â Â Â Â Â Â Â Â Â //'.modal-overlay'Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Generic modal overlay
Â Â Â Â Â Â Â Â ];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return overlaySelectors.some(selector => document.querySelector(selector));
Â Â Â Â };

Â Â Â Â // âœ… Navigation dots function (works with stats panel)
Â Â Â Â function updateNavDots() {
Â Â Â Â Â Â Â Â const statsPanel = document.getElementById("stats-panel");
Â Â Â Â Â Â Â Â const statsVisible = statsPanel && statsPanel.classList.contains("show");
Â Â Â Â Â Â Â Â const dots = document.querySelectorAll(".dot");

Â Â Â Â Â Â Â Â if (dots.length === 2) {
Â Â Â Â Â Â Â Â Â Â Â Â dots[0].classList.toggle("active", !statsVisible); // Task View dot
Â Â Â Â Â Â Â Â Â Â Â Â dots[1].classList.toggle("active", statsVisible);Â  // Stats Panel dot
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Make updateNavDots globally accessible
Â Â Â Â window.updateNavDots = updateNavDots;

Â Â Â Â // âœ… DOM Element References
Â Â Â Â const taskInput = document.getElementById("taskInput");
Â Â Â Â const addTaskButton = document.getElementById("addTask");
Â Â Â Â const taskList = document.getElementById("taskList");
Â Â Â Â const progressBar = document.getElementById("progressBar");
Â Â Â Â const completeAllButton = document.getElementById("completeAll");
Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â const menuButton = document.querySelector(".menu-button");
Â Â Â Â const menu = document.querySelector(".menu-container");
Â Â Â Â const exitMiniCycle = document.getElementById("exit-mini-cycle");
Â Â Â Â const feedbackModal = document.getElementById("feedback-modal");
Â Â Â Â const openFeedbackBtn = document.getElementById("open-feedback-modal");
Â Â Â Â const closeFeedbackBtn = document.querySelector(".close-feedback-modal");
Â Â Â Â const submitFeedbackBtn = document.getElementById("submit-feedback");
Â Â Â Â const feedbackText = document.getElementById("feedback-text");
Â Â Â Â const openUserManual = document.getElementById("open-user-manual");
Â Â Â Â const enableReminders = document.getElementById("enableReminders");
Â Â Â Â const enableTaskReminders = document.getElementById("enable-task-reminders");
Â Â Â Â const indefiniteCheckbox = document.getElementById("indefiniteCheckbox");
Â Â Â Â const repeatCountRow = document.getElementById("repeat-count-row");
Â Â Â Â const frequencySection = document.getElementById("frequency-section");
Â Â Â Â const remindersModal = document.getElementById("reminders-modal");
Â Â Â Â const closeRemindersBtn = document.getElementById("close-reminders-btn");
Â Â Â Â const closeMainMenuBtn = document.getElementById("close-main-menu");
Â Â Â Â const themeUnlockMessage = document.getElementById("theme-unlock-message");
Â Â Â Â const themeUnlockStatus = document.getElementById("theme-unlock-status");
Â Â Â Â const selectedYearlyDays = {}; // key = month number, value = array of selected days
Â Â Â Â const yearlyApplyToAllCheckbox = document.getElementById("yearly-apply-days-to-all");

Â Â Â Â // âœ… Dark Mode Toggle Setup (Schema 2.5)
Â Â Â Â const quickToggle = document.getElementById("quick-dark-toggle");
Â Â Â Â let darkModeEnabled = false;
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â darkModeEnabled = schemaData.settings.darkMode || false;
Â Â Â Â Â Â Â Â }
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Could not load dark mode setting, using default');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (quickToggle) {
Â Â Â Â Â Â Â Â quickToggle.textContent = darkModeEnabled ? "â˜€ï¸" : "ğŸŒ™";
Â Â Â Â }

Â Â Â Â // === ğŸ¯ Constants for event delegation targets ===
Â Â Â Â const RECURRING_CLICK_TARGETS = [
Â Â Â Â Â Â Â Â ".weekly-day-box",
Â Â Â Â Â Â Â Â ".biweekly-day-box",
Â Â Â Â Â Â Â Â ".monthly-day-box",
Â Â Â Â Â Â Â Â ".yearly-day-box",
Â Â Â Â Â Â Â Â ".yearly-month-box"
Â Â Â Â ];
Â Â Â Â 
Â Â Â Â const RECURRING_CHANGE_TARGETS = [
Â Â Â Â Â Â Â Â "input",
Â Â Â Â Â Â Â Â "select",
Â Â Â Â Â Â Â Â "#yearly-apply-days-to-all"
Â Â Â Â ];
Â Â Â Â 
Â Â Â Â // === ğŸ” Delegated Change Handler ===
Â Â Â Â const handleRecurringChange = (e) => {
Â Â Â Â Â Â Â Â const isMatch = RECURRING_CHANGE_TARGETS.some(selector =>
Â Â Â Â Â Â Â Â Â Â Â Â e.target.matches(selector)
Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â if (isMatch) {
Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringSummary();
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â // === ğŸ” Delegated Click Handler ===
Â Â Â Â const handleRecurringClick = (e) => {
Â Â Â Â Â Â Â Â const isMatch = RECURRING_CLICK_TARGETS.some(selector =>
Â Â Â Â Â Â Â Â Â Â Â Â e.target.matches(selector)
Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â if (isMatch) {
Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringSummary();
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â // === ğŸ§  Attach Delegated Listeners ===
Â Â Â Â function attachRecurringSummaryListeners() {
Â Â Â Â Â Â Â Â const panel = document.getElementById("recurring-settings-panel");
Â Â Â Â Â Â Â Â safeAddEventListener(panel, "change", handleRecurringChange);
Â Â Â Â Â Â Â Â safeAddEventListener(panel, "click", handleRecurringClick);
Â Â Â Â }

Â Â Â Â const DRAG_THROTTLE_MS = 50;
Â Â Â Â const TASK_LIMIT = 100;Â 

Â Â Â Â // âœ… Initialize app with proper error handling and Schema 2.5 focus
Â Â Â Â console.log('ğŸ”§ Starting core initialization sequence...');

Â Â Â Â // Device detection with delay to ensure DOM is ready
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ“± Running device detection...');
Â Â Â Â Â Â Â Â autoRedetectOnVersionChange();
Â Â Â Â }, 10000);

Â Â Â Â // âœ… Core data initialization (Schema 2.5 required)
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ”§ Fixing task validation issues...');
Â Â Â Â Â Â Â Â fixTaskValidationIssues();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Initializing app with auto-migration...');
Â Â Â Â Â Â Â Â initializeAppWithAutoMigration({ forceMode: true });
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.error('âŒ Critical initialization error:', error);
Â Â Â Â Â Â Â Â // Continue with setup even if migration fails
Â Â Â Â }

Â Â Â Â // âœ… UI Component Setup
Â Â Â Â console.log('ğŸ¨ Setting up UI components...');
Â Â Â Â loadRemindersSettings();
Â Â Â Â setupReminderToggle();
Â Â Â Â setupMainMenu();
Â Â Â Â setupSettingsMenu();
Â Â Â Â setupAbout();
Â Â Â Â setupUserManual();
Â Â Â Â setupFeedbackModal();
Â Â Â Â setupTestingModal();
Â Â Â Â setupModalClickOutside();

Â Â Â Â // âœ… Stats and Navigation
Â Â Â Â console.log('ğŸ“Š Updating stats and navigation...');
Â Â Â Â updateNavDots();


Â Â Â Â // âœ… Theme Loading (Schema 2.5 only)
Â Â Â Â console.log('ğŸ¨ Loading theme settings...');
Â Â Â Â try {
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (schemaData && schemaData.settings.theme) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¨ Applying theme from Schema 2.5:', schemaData.settings.theme);
Â Â Â Â Â Â Â Â Â Â Â Â applyTheme(schemaData.settings.theme);
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¨ Using default theme');
Â Â Â Â Â Â Â Â Â Â Â Â applyTheme('default');
Â Â Â Â Â Â Â Â }
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Theme loading failed, using default:', error);
Â Â Â Â Â Â Â Â applyTheme('default');
Â Â Â Â }

Â Â Â Â // âœ… Core App Loading
Â Â Â Â console.log('ğŸ“± Loading core app data...');
Â Â Â Â try {
Â Â Â Â Â Â Â Â loadMiniCycle();
Â Â Â Â Â Â Â Â initializeDefaultRecurringSettings();
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.error('âŒ Core app loading failed:', error);
Â Â Â Â Â Â Â Â // Try to create initial data if loading fails
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ†˜ Attempting to create initial data...');
Â Â Â Â Â Â Â Â Â Â Â Â createInitialSchema25Data();
Â Â Â Â Â Â Â Â Â Â Â Â loadMiniCycle();
Â Â Â Â Â Â Â Â } catch (fallbackError) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Fallback initialization failed:', fallbackError);
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â // âœ… Feature Setup
Â Â Â Â console.log('âš™ï¸ Setting up features...');
Â Â Â Â setupMiniCycleTitleListener();
Â Â Â Â setupDownloadMiniCycle();
Â Â Â Â setupUploadMiniCycle();
Â Â Â Â setupRearrange();
Â Â Â Â dragEndCleanup();
Â Â Â Â updateMoveArrowsVisibility();
Â Â Â Â checkDueDates();
Â Â Â Â initializeThemesPanel();

Â Â Â Â // âœ… Recurring Features
Â Â Â Â console.log('ğŸ” Setting up recurring features...');
Â Â Â Â setupRecurringPanel();
Â Â Â Â attachRecurringSummaryListeners();
Â Â Â Â loadAlwaysShowRecurringSetting();

Â Â Â Â // âœ… Mode Selector (with delay for DOM readiness)
Â Â Â Â console.log('ğŸ¯ Initializing mode selector...');
Â Â Â Â initializeModeSelector(); // This calls setupModeSelector()

Â Â Â Â // âœ… Reminder System (with staggered timing)
Â Â Â Â console.log('ğŸ”” Setting up reminder system...');
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â remindOverdueTasks();
Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Overdue task reminder failed:', error);
Â Â Â Â Â Â Â Â }
Â Â Â Â }, 2000);

Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â updateReminderButtons(); // âœ… This is the *right* place!
Â Â Â Â Â Â Â Â Â Â Â Â startReminders();
Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Reminder system setup failed:', error);
Â Â Â Â Â Â Â Â }
Â Â Â Â }, 200);

Â Â Â Â // âœ… Recurring Watcher Setup (with Schema 2.5 compatibility)
Â Â Â Â console.log('ğŸ‘ï¸ Setting up recurring task watcher...');
Â Â Â Â try {
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (schemaData && schemaData.cycles && schemaData.activeCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â const { activeCycle, cycles } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â setupRecurringWatcher(activeCycle, cycles);
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No Schema 2.5 data available for recurring watcher');
Â Â Â Â Â Â Â Â }
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Recurring watcher setup failed:', error);
Â Â Â Â }

Â Â Â Â // âœ… Final Setup
Â Â Â Â console.log('ğŸ¯ Completing initialization...');
Â Â Â Â window.onload = () => {
Â Â Â Â Â Â Â Â if (taskInput) {
Â Â Â Â Â Â Â Â Â Â Â Â taskInput.focus();
Â Â Â Â Â Â Â Â }
Â Â Â Â };

Â Â Â Â // âœ… Mark app as ready
Â Â Â Â window.AppReady = true;
Â Â Â Â console.log("âœ… miniCycle app is fully initialized and ready (Schema 2.5).");

Â Â Â Â console.log('ğŸ‰ Initialization sequence completed successfully!');



Â Â Â Â 
Â Â 
Â Â Â Â // âœ… FIXED: Device detection call at the end, after everything is initialized
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ“± Running device detection...');
Â Â Â Â Â Â Â Â if (window.deviceDetectionManager && window.loadMiniCycleData) {
Â Â Â Â Â Â Â Â Â Â Â Â window.deviceDetectionManager.autoRedetectOnVersionChange();
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Device detection manager or dependencies not available');
Â Â Â Â Â Â Â Â }
Â Â Â Â }, 10000);






// ğŸ”§ FORCE MIGRATION CHECK
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ”§ Forcing migration check...');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Fix validation issues first
Â Â Â Â Â Â Â Â fixTaskValidationIssues();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Then check migration
Â Â Â Â Â Â Â Â const migrationCheck = checkMigrationNeeded();
Â Â Â Â Â Â Â Â console.log('ğŸ” Migration check result:', migrationCheck);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (migrationCheck.needed) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸš¨ Migration needed - starting process...');
Â Â Â Â Â Â Â Â Â Â Â Â initializeAppWithAutoMigration();
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… No migration needed');
Â Â Â Â Â Â Â Â }
Â Â Â Â }, 1000);




// ==== ğŸ” UNDO / REDO SYSTEM =============================
// - Tracks task + recurring state snapshots
// - Limit: 4 snapshots
// - Functions: pushUndoSnapshot, performUndo, performRedo
// ========================================================

document.getElementById("undo-btn").hidden = true;
document.getElementById("redo-btn").hidden = true;

document.getElementById("undo-btn")?.addEventListener("click", performUndo);
document.getElementById("redo-btn")?.addEventListener("click", performRedo);

function pushUndoSnapshot() {
Â Â console.log('ğŸ“¸ Creating undo snapshot (Schema 2.5 only)...');
Â Â 
Â Â const schemaData = loadMiniCycleData();
Â Â if (!schemaData) {
Â Â Â Â console.error('âŒ Schema 2.5 data required for pushUndoSnapshot');
Â Â Â Â return;
Â Â }

Â Â const { cycles, activeCycle } = schemaData;
Â Â const currentCycle = cycles[activeCycle];
Â Â 
Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â console.warn('âš ï¸ No active cycle found for undo snapshot');
Â Â Â Â return;
Â Â }

Â Â const snapshot = {
Â Â Â Â tasks: structuredClone(currentCycle.tasks),
Â Â Â Â recurringTemplates: structuredClone(currentCycle.recurringTemplates || {}),
Â Â Â Â title: currentCycle.title || "Untitled miniCycle"
Â Â };

Â Â undoStack.push(snapshot);
Â Â if (undoStack.length > UNDO_LIMIT) undoStack.shift(); // keep max 4

Â Â redoStack = []; // clear redo on new action

Â Â document.getElementById("undo-btn").hidden = false;
Â Â document.getElementById("redo-btn").hidden = true;
Â Â 
Â Â console.log('âœ… Undo snapshot created');
}

function performUndo() {
Â Â if (undoStack.length === 0) return;
Â Â 
Â Â console.log('â†©ï¸ Performing undo (Schema 2.5 only)...');

Â Â const schemaData = loadMiniCycleData();
Â Â if (!schemaData) {
Â Â Â Â console.error('âŒ Schema 2.5 data required for performUndo');
Â Â Â Â return;
Â Â }

Â Â const { cycles, activeCycle } = schemaData;
Â Â const currentCycle = cycles[activeCycle];
Â Â 
Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â console.warn('âš ï¸ No active cycle found for undo');
Â Â Â Â return;
Â Â }

Â Â // Save current state to redo stack
Â Â const currentSnapshot = {
Â Â Â Â tasks: structuredClone(currentCycle.tasks),
Â Â Â Â recurringTemplates: structuredClone(currentCycle.recurringTemplates || {}),
Â Â Â Â title: currentCycle.title
Â Â };
Â Â redoStack.push(currentSnapshot);

Â Â // Restore from undo stack
Â Â const snapshotToRestore = undoStack.pop();
Â Â currentCycle.tasks = structuredClone(snapshotToRestore.tasks);
Â Â currentCycle.recurringTemplates = structuredClone(snapshotToRestore.recurringTemplates || {});

Â Â if (snapshotToRestore.title !== undefined) {
Â Â Â Â currentCycle.title = snapshotToRestore.title;
Â Â Â Â document.getElementById("mini-cycle-title").textContent = snapshotToRestore.title;
Â Â Â Â updateMainMenuHeader();
Â Â }

Â Â // Update the full schema data
Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â // Refresh UI
Â Â loadMiniCycle();
Â Â updateRecurringPanel();
Â Â updateRecurringPanelButtonVisibility();

Â Â // Update button states
Â Â document.getElementById("undo-btn").hidden = undoStack.length === 0;
Â Â document.getElementById("redo-btn").hidden = false;
Â Â 
Â Â console.log('âœ… Undo completed');
}

function performRedo() {
Â Â if (redoStack.length === 0) return;
Â Â 
Â Â console.log('â†ªï¸ Performing redo (Schema 2.5 only)...');

Â Â const schemaData = loadMiniCycleData();
Â Â if (!schemaData) {
Â Â Â Â console.error('âŒ Schema 2.5 data required for performRedo');
Â Â Â Â return;
Â Â }

Â Â const { cycles, activeCycle } = schemaData;
Â Â const currentCycle = cycles[activeCycle];
Â Â 
Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â console.warn('âš ï¸ No active cycle found for redo');
Â Â Â Â return;
Â Â }

Â Â // Save current state to undo stack
Â Â const currentSnapshot = {
Â Â Â Â tasks: structuredClone(currentCycle.tasks),
Â Â Â Â recurringTemplates: structuredClone(currentCycle.recurringTemplates || {}),
Â Â Â Â title: currentCycle.title
Â Â };
Â Â undoStack.push(currentSnapshot);

Â Â // Restore from redo stack
Â Â const snapshotToRestore = redoStack.pop();
Â Â currentCycle.tasks = structuredClone(snapshotToRestore.tasks);
Â Â currentCycle.recurringTemplates = structuredClone(snapshotToRestore.recurringTemplates || {});

Â Â if (snapshotToRestore.title !== undefined) {
Â Â Â Â currentCycle.title = snapshotToRestore.title;
Â Â Â Â document.getElementById("mini-cycle-title").textContent = snapshotToRestore.title;
Â Â Â Â updateMainMenuHeader();
Â Â }

Â Â // Update the full schema data
Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â // Refresh UI
Â Â loadMiniCycle();
Â Â updateRecurringPanel();
Â Â updateRecurringPanelButtonVisibility();

Â Â // Update button states
Â Â document.getElementById("undo-btn").hidden = false;
Â Â document.getElementById("redo-btn").hidden = redoStack.length === 0;
Â Â 
Â Â console.log('âœ… Redo completed');
}

function renderTasks(tasksArray = []) {
Â Â console.log('ğŸ”„ Rendering tasks (Schema 2.5 only)...');
Â Â 
Â Â const taskList = document.getElementById("taskList");
Â Â if (!taskList) {
Â Â Â Â console.error('âŒ Task list container not found');
Â Â Â Â return;
Â Â }
Â Â 
Â Â taskList.innerHTML = ""; // Clear existing tasks from DOM

Â Â if (!Array.isArray(tasksArray)) {
Â Â Â Â console.warn('âš ï¸ Invalid tasks array provided to renderTasks');
Â Â Â Â return;
Â Â }

Â Â console.log(`ğŸ“‹ Rendering ${tasksArray.length} tasks`);

Â Â tasksArray.forEach(task => {
Â Â Â Â if (!task || !task.id) {
Â Â Â Â Â Â console.warn('âš ï¸ Skipping invalid task:', task);
Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â addTask(
Â Â Â Â Â Â task.text,
Â Â Â Â Â Â task.completed,
Â Â Â Â Â Â false, Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // shouldSave: false (don't save during render)
Â Â Â Â Â Â task.dueDate,
Â Â Â Â Â Â task.highPriority,
Â Â Â Â Â Â true,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // isLoading: true (avoid overdue reminder popups)
Â Â Â Â Â Â task.remindersEnabled,
Â Â Â Â Â Â task.recurring,
Â Â Â Â Â Â task.id,
Â Â Â Â Â Â task.recurringSettings
Â Â Â Â );
Â Â });

Â Â // Re-run UI state updates
Â Â updateProgressBar();
Â Â checkCompleteAllButton();
Â Â updateStatsPanel();
Â Â 
Â Â console.log('âœ… Task rendering completed');
}

document.addEventListener("keydown", (e) => {
Â Â if ((e.ctrlKey || e.metaKey) && e.key === "z") {
Â Â Â Â e.preventDefault();
Â Â Â Â performUndo();
Â Â } else if ((e.ctrlKey || e.metaKey) && (e.key === "y" || (e.shiftKey && e.key === "Z"))) {
Â Â Â Â e.preventDefault();
Â Â Â Â performRedo();
Â Â }
});

// ğŸ”§ Utility Function (can go at top of your scripts)
function generateNotificationId(message) {
Â Â Â Â return message
Â Â Â Â Â Â Â Â .replace(/<br\s*\/?>/gi, '\n') Â  // Convert <br> to newline
Â Â Â Â Â Â Â Â .replace(/<[^>]*>/g, '') Â  Â  Â  Â  // Remove all HTML tags
Â Â Â Â Â Â Â Â .replace(/\s+/g, ' ')Â  Â  Â  Â  Â  Â  // Collapse whitespace
Â Â Â Â Â Â Â Â .trim()
Â Â Â Â Â Â Â Â .toLowerCase();Â  Â  Â  Â  Â  Â  Â  Â  Â  // Normalize case
}

function generateHashId(message) {
Â Â Â Â const text = generateNotificationId(message);
Â Â Â Â let hash = 0;
Â Â Â Â for (let i = 0; i < text.length; i++) {
Â Â Â Â Â Â Â Â hash = (hash << 5) - hash + text.charCodeAt(i);
Â Â Â Â Â Â Â Â hash |= 0; // Force 32-bit int
Â Â Â Â }
Â Â Â Â return `note-${Math.abs(hash)}`;
}

// Make utility functions globally accessible for the notification module
window.generateNotificationId = generateNotificationId;
window.generateHashId = generateHashId;

/**
Â * Detects the device type and applies the appropriate class to the body.
Â * Determines if the device has touch capabilities or a fine pointer (mouse).
Â */

function detectDeviceType() {
Â Â Â Â let hasTouchEvents = "ontouchstart" in window;
Â Â Â Â let touchPoints = navigator.maxTouchPoints || navigator.msMaxTouchPoints;
Â Â Â Â let isFinePointer = window.matchMedia("(pointer: fine)").matches;

Â Â Â Â console.log(`touch detected: hasTouchEvents=${hasTouchEvents}, maxTouchPoints=${touchPoints}, isFinePointer=${isFinePointer}`);

Â Â Â Â if (!isFinePointer && (hasTouchEvents || touchPoints > 0)) {
Â Â Â Â Â Â Â Â document.body.classList.add("touch-device");
Â Â Â Â } else {
Â Â Â Â Â Â Â Â document.body.classList.add("non-touch-device");
Â Â Â Â }
}
detectDeviceType();


Â Â Â Â Â Â Â Â function refreshTaskListUI() {
Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Refreshing task list UI (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for refreshTaskListUI');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn("âš ï¸ No active cycle found for UI refresh");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // Clear current list
Â Â Â Â Â Â Â Â Â Â const taskListContainer = document.getElementById("taskList");
Â Â Â Â Â Â Â Â Â Â if (!taskListContainer) return;
Â Â Â Â Â Â Â Â Â Â taskListContainer.innerHTML = "";
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // Re-render each task from Schema 2.5
Â Â Â Â Â Â Â Â Â Â (cycleData.tasks || []).forEach(task => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â addTask(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.text,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.completed,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â false, // Don't double save
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.dueDate,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.highPriority,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â true,Â  // isLoading (skip overdue reminder immediately)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.remindersEnabled,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.id,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurringSettings
Â Â Â Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â updateRecurringButtonVisibility();
Â Â Â Â Â Â Â Â Â Â console.log("âœ… Task list UI refreshed from Schema 2.5");
Â Â Â Â Â Â }


function initializeDefaultRecurringSettings() {
Â Â Â Â console.log('ğŸ§© Initializing default recurring settings (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for initializeDefaultRecurringSettings');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â 
Â Â Â Â // Check if default recurring settings exist in Schema 2.5
Â Â Â Â if (!fullSchemaData.settings.defaultRecurringSettings || Object.keys(fullSchemaData.settings.defaultRecurringSettings).length === 0) {
Â Â Â Â Â Â Â Â const defaultSettings = {
Â Â Â Â Â Â Â Â Â Â Â Â frequency: "daily",
Â Â Â Â Â Â Â Â Â Â Â Â indefinitely: true,
Â Â Â Â Â Â Â Â Â Â Â Â time: null
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â fullSchemaData.settings.defaultRecurringSettings = defaultSettings;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("ğŸ§© Initialized default recurring settings in Schema 2.5:", defaultSettings);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log("â„¹ï¸ Default recurring settings already exist in Schema 2.5.");
Â Â Â Â }
}

document.getElementById("toggleAutoReset").addEventListener("change", updateCycleModeDescription);
document.getElementById("deleteCheckedTasks").addEventListener("change", updateCycleModeDescription);
// ...existing code...



// Helper function to get readable mode name (keep this)
function getModeName(mode) {
Â Â Â Â const modeNames = {
Â Â Â Â Â Â Â Â 'auto-cycle': 'Auto Cycle â†»',
Â Â Â Â Â Â Â Â 'manual-cycle': 'Manual Cycle âœ”ï¸â†»',
Â Â Â Â Â Â Â Â 'todo-mode': 'To-Do Mode âœ“'
Â Â Â Â };
Â Â Â Â 
Â Â Â Â const result = modeNames[mode] || 'Auto Cycle â†»';
Â Â Â Â console.log('ğŸ“ Getting mode name:', { input: mode, output: result });
Â Â Â Â return result;
}

function initializeModeSelector() {
Â Â Â Â console.log('â° Initializing mode selector with 200ms delay...');
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('â° Delay complete, calling setupModeSelector...');
Â Â Â Â Â Â Â Â setupModeSelector();
Â Â Â Â }, 200);
}

// ...existing code...
/**
Â * Initializes the main menu by attaching event listeners to menu buttons.
Â * Ensures the function runs only once to prevent duplicate event bindings.
Â */

function setupMainMenu() {
Â Â Â Â if (setupMainMenu.hasRun) return; // Prevents running more than once
Â Â Â Â setupMainMenu.hasRun = true;

Â Â Â Â safeAddEventListener(document.getElementById("save-as-mini-cycle"), "click", saveMiniCycleAsNew);
Â Â Â Â safeAddEventListener(document.getElementById("open-mini-cycle"), "click", switchMiniCycle);Â Â Â Â 
Â Â Â Â safeAddEventListener(document.getElementById("clear-mini-cycle-tasks"), "click", clearAllTasks);
Â Â Â Â safeAddEventListener(document.getElementById("delete-all-mini-cycle-tasks"), "click", deleteAllTasks);
Â Â Â Â safeAddEventListener(document.getElementById("new-mini-cycle"), "click", createNewMiniCycle);
Â Â Â Â safeAddEventListener(document.getElementById("close-main-menu"), "click", closeMainMenu);
Â Â Â Â checkGamesUnlock();
Â Â Â Â safeAddEventListener(exitMiniCycle, "click", () => {
Â Â Â Â Â Â Â Â window.location.href = "../index.html";
Â Â Â Â });
Â Â Â Â 
}

function checkGamesUnlock() {
Â Â Â Â console.log('ğŸ® Checking games unlock (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for checkGamesUnlock');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const hasGameUnlock = schemaData.settings.unlockedFeatures.includes("task-order-game");
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Game unlock status:', hasGameUnlock);
Â Â Â Â 
Â Â Â Â if (hasGameUnlock) {
Â Â Â Â Â Â Â Â document.getElementById("games-menu-option").style.display = "block";
Â Â Â Â Â Â Â Â console.log('âœ… Games menu option displayed');
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('ğŸ”’ Games still locked');
Â Â Â Â }
}


document.getElementById("open-games-panel").addEventListener("click", () => {
Â Â Â Â document.getElementById("games-panel").style.display = "flex";
Â Â Â Â setupGamesModalOutsideClick();

});

document.getElementById("close-games-panel").addEventListener("click", () => {
Â Â Â Â document.getElementById("games-panel").style.display = "none";
});

document.getElementById("open-task-order-game").addEventListener("click", () => {
Â Â Â Â // Load game into container or open in new modal

Â Â Â Â Â Â Â Â window.location.href = "miniCycleGames/miniCycle-taskOrder.html";
Â Â Â 
});
/*
function loadTaskOrderGame() {
Â Â Â Â const container = document.getElementById("taskOrderGameContainer");
Â Â Â Â if (!container) return;

Â Â Â Â fetch("/miniCycleGames/miniCycle-taskOrder.html")
Â Â Â Â Â Â Â Â .then(res => res.text())
Â Â Â Â Â Â Â Â .then(html => {
Â Â Â Â Â Â Â Â Â Â Â Â container.innerHTML = html;
Â Â Â Â Â Â Â Â Â Â Â Â container.style.display = "block";
Â Â Â Â Â Â Â Â });
}
*/


function setupGamesModalOutsideClick() {
Â Â Â Â const gamesPanel = document.getElementById("games-panel");
Â Â Â Â const gamesContent = document.querySelector(".games-modal-content");
Â Â Â Â const openButton = document.getElementById("open-games-panel");
Â Â 
Â Â Â Â if (!gamesPanel || !gamesContent || !openButton) return;
Â Â 
Â Â Â Â console.log("âœ… Games outside click ready");
Â Â 
Â Â Â Â safeAddEventListener(document, "click", function (event) {
Â Â Â Â Â Â const isOpen = gamesPanel.style.display === "flex";
Â Â Â Â Â Â const clickedOutside =
Â Â Â Â Â Â Â Â !gamesContent.contains(event.target) && event.target !== openButton;
Â Â 
Â Â Â Â Â Â if (isOpen && clickedOutside) {
Â Â Â Â Â Â Â Â gamesPanel.style.display = "none";
Â Â Â Â Â Â }
Â Â Â Â });
Â Â }

function closeMainMenu() {
if (menu) { menu.classList.remove("visible");}
}



/**
Â * Initializes the miniCycle app by loading or creating a saved miniCycle.
Â * Ensures a valid miniCycle is always available in localStorage.
Â */
// âœ… UPDATED: Check onboarding first, then handle cycle creation
function initialSetup() {
Â Â Â Â console.log('ğŸš€ Initializing app (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â let schemaData = loadMiniCycleData();
Â Â Â Â 
Â Â Â Â // âœ… CREATE SCHEMA 2.5 DATA IF IT DOESN'T EXIST
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.log('ğŸ†• No Schema 2.5 data found - creating initial structure...');
Â Â Â Â Â Â Â Â createInitialSchema25Data();
Â Â Â Â Â Â Â Â schemaData = loadMiniCycleData(); // Load the newly created data
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle, reminders, settings } = schemaData;
Â Â Â Â 
Â Â Â Â console.log("ğŸ“¦ Loaded Schema 2.5 data:", {
Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â cycleCount: Object.keys(cycles).length,
Â Â Â Â Â Â Â Â hasReminders: !!reminders,
Â Â Â Â Â Â Â Â hasSettings: !!settings
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // âœ… CHECK ONBOARDING FIRST - before checking for cycles
Â Â Â Â const hasSeenOnboarding = settings.onboardingCompleted || false;
Â Â Â Â 
Â Â Â Â if (!hasSeenOnboarding) {
Â Â Â Â Â Â Â Â console.log('ğŸ‘‹ First time user - showing onboarding first...');
Â Â Â Â Â Â Â Â showOnboardingThenCycleCreation(cycles, activeCycle);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Check if we have a valid active cycle (existing users)
Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â console.log('ğŸ†• Existing user, no active cycle found, prompting for new cycle creation...');
Â Â Â Â Â Â Â Â showCycleCreationModal();
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Complete setup for existing cycles
Â Â Â Â completeInitialSetup(activeCycle, null, schemaData);
}

// âœ… NEW: Show onboarding, then cycle creation
function showOnboardingThenCycleCreation(cycles, activeCycle) {
Â Â Â Â console.log('ğŸ¯ Starting onboarding flow first...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â const currentTheme = schemaData.settings.theme || 'default';
Â Â Â Â 
Â Â Â Â const steps = [
Â Â Â Â Â Â Â Â `<h2>Welcome to miniCycle! ğŸ‰</h2>
Â Â Â Â Â Â Â Â Â <p>miniCycle helps you manage tasks with a powerful task cycling system!</p>`,
Â Â Â Â Â Â Â Â `<ul>
Â Â Â Â Â Â Â Â Â Â Â <li>âœ… Add tasks using the input box to create your cycle list.</li>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ”„ When all tasks are completed, they reset automatically (if Auto-Cycle is enabled)</li>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ“Š Track your progress and unlock themes</li>
Â Â Â Â Â Â Â Â Â </ul>`,
Â Â Â Â Â Â Â Â `<ul>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ“± On mobile, long press a task to open the menu</li>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ“± Long press and move to rearrange tasks</li>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ“± Swipe Left to access Stats Panel</li>
Â Â Â Â Â Â Â Â Â Â Â <li>ğŸ“µ Use Settings to show task buttons on older phones</li>
Â Â Â Â Â Â Â Â Â </ul>`
Â Â Â Â ];

Â Â Â Â let currentStep = 0;

Â Â Â Â const modal = document.createElement("div");
Â Â Â Â modal.id = "onboarding-modal";
Â Â Â Â modal.className = "onboarding-modal";
Â Â Â Â modal.innerHTML = `
Â Â Â Â Â Â Â Â <div class="onboarding-content theme-${currentTheme}">
Â Â Â Â Â Â Â Â Â Â Â Â <button id="onboarding-skip" class="onboarding-skip">Skip âœ–</button>
Â Â Â Â Â Â Â Â Â Â Â Â <div id="onboarding-step-content"></div>
Â Â Â Â Â Â Â Â Â Â Â Â <div class="onboarding-controls">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <button id="onboarding-prev" class="hidden">â¬… Back</button>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <button id="onboarding-next">Next â¡</button>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â </div>
Â Â Â Â `;

Â Â Â Â document.body.appendChild(modal);
Â Â Â Â const stepContent = document.getElementById("onboarding-step-content");
Â Â Â Â const nextBtn = document.getElementById("onboarding-next");
Â Â Â Â const prevBtn = document.getElementById("onboarding-prev");
Â Â Â Â const skipBtn = document.getElementById("onboarding-skip");

Â Â Â Â function renderStep(index) {
Â Â Â Â Â Â Â Â stepContent.innerHTML = steps[index];
Â Â Â Â Â Â Â Â prevBtn.classList.toggle("hidden", index === 0);
Â Â Â Â Â Â Â Â nextBtn.textContent = index === steps.length - 1 ? "Start ğŸš€" : "Next â¡";
Â Â Â Â }

Â Â Â Â function completeOnboardingAndShowCycleCreation() {
Â Â Â Â Â Â Â Â console.log('âœ… Onboarding completed, now showing cycle creation...');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Mark onboarding as complete
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.onboardingCompleted = true;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â modal.remove();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Now check if they need to create a cycle
Â Â Â Â Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showCycleCreationModal();
Â Â Â Â Â Â Â Â Â Â Â Â }, 300); // Small delay for smooth transition
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â // They already have a cycle, just load it
Â Â Â Â Â Â Â Â Â Â Â Â const updatedSchemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â completeInitialSetup(activeCycle, null, updatedSchemaData);
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â nextBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â if (currentStep < steps.length - 1) {
Â Â Â Â Â Â Â Â Â Â Â Â currentStep++;
Â Â Â Â Â Â Â Â Â Â Â Â renderStep(currentStep);
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â completeOnboardingAndShowCycleCreation();
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â prevBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â if (currentStep > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â currentStep--;
Â Â Â Â Â Â Â Â Â Â Â Â renderStep(currentStep);
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â skipBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â completeOnboardingAndShowCycleCreation();
Â Â Â Â });

Â Â Â Â modal.addEventListener("click", (e) => {
Â Â Â Â Â Â Â Â if (e.target === modal) {
Â Â Â Â Â Â Â Â Â Â Â Â completeOnboardingAndShowCycleCreation();
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â renderStep(currentStep);
}

// âœ… NEW: Extracted cycle creation modal logic
function showCycleCreationModal() {
Â Â Â Â console.log('ğŸ†• Showing cycle creation modal...');
Â Â Â Â 
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â showPromptModal({
Â Â Â Â Â Â Â Â Â Â Â Â title: "Create a miniCycle",
Â Â Â Â Â Â Â Â Â Â Â Â message: "Enter a name to get started:",
Â Â Â Â Â Â Â Â Â Â Â Â placeholder: "e.g., Morning Routine",
Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Create",
Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Load Sample",
Â Â Â Â Â Â Â Â Â Â Â Â callback: async (input) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!input || input.trim() === "") {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“¥ User chose sample cycle');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â await preloadGettingStartedCycle();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const newCycleName = sanitizeInput(input.trim());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const cycleId = `cycle_${Date.now()}`;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Creating new cycle:', newCycleName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Create new cycle in Schema 2.5 format
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[cycleId] = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: cycleId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: newCycleName,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tasks: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoReset: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = cycleId;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ New cycle saved to Schema 2.5');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Complete the setup after user interaction
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â completeInitialSetup(cycleId, fullSchemaData);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â }, 500);
}

// âœ… UPDATED: Close modal and complete setup after loading sample
async function preloadGettingStartedCycle() {
Â Â Â Â console.log('ğŸ“¥ Preloading getting started cycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â const response = await fetch("data/sample-getting-started.mcyc");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!response.ok) {
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error(`HTTP error! status: ${response.status}`);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const sample = await response.json();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“„ Sample data loaded:', {
Â Â Â Â Â Â Â Â Â Â Â Â title: sample.title || sample.name,
Â Â Â Â Â Â Â Â Â Â Â Â taskCount: sample.tasks?.length || 0
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for preloadGettingStartedCycle');
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â const cycleId = `cycle_${Date.now()}`;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Creating sample cycle with ID:', cycleId);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Create sample cycle in Schema 2.5 format
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[cycleId] = {
Â Â Â Â Â Â Â Â Â Â Â Â id: cycleId,
Â Â Â Â Â Â Â Â Â Â Â Â title: sample.title || sample.name || "Getting Started",
Â Â Â Â Â Â Â Â Â Â Â Â tasks: sample.tasks || [],
Â Â Â Â Â Â Â Â Â Â Â Â autoReset: sample.autoReset !== false, // Default to true if not specified
Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: sample.cycleCount || 0,
Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks: sample.deleteCheckedTasks || false,
Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = cycleId;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Sample cycle saved to Schema 2.5');
Â Â Â Â Â Â Â Â console.log('ğŸ“ˆ Total cycles created:', fullSchemaData.metadata.totalCyclesCreated);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… CLOSE ANY OPEN MODALS
Â Â Â Â Â Â Â Â const existingModals = document.querySelectorAll('.miniCycle-overlay, .mini-modal-overlay');
Â Â Â Â Â Â Â Â existingModals.forEach(modal => modal.remove());
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â showNotification("âœ¨ A sample miniCycle has been preloaded to help you get started!", "success", 5000);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… COMPLETE SETUP AFTER LOADING SAMPLE
Â Â Â Â Â Â Â Â completeInitialSetup(cycleId, fullSchemaData);
Â Â Â Â Â Â Â Â 
Â Â Â Â } catch (err) {
Â Â Â Â Â Â Â Â console.error('âŒ Failed to load sample miniCycle:', err);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… CLOSE MODAL ON ERROR TOO
Â Â Â Â Â Â Â Â const existingModals = document.querySelectorAll('.miniCycle-overlay, .mini-modal-overlay');
Â Â Â Â Â Â Â Â existingModals.forEach(modal => modal.remove());
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â showNotification("âŒ Failed to load sample miniCycle. Creating a basic cycle instead.", "error");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… CREATE A BASIC FALLBACK CYCLE
Â Â Â Â Â Â Â Â createBasicFallbackCycle();
Â Â Â Â }
}

// âœ… NEW: Create a basic cycle if sample loading fails
function createBasicFallbackCycle() {
Â Â Â Â console.log('ğŸ†˜ Creating basic fallback cycle...');
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â const cycleId = `cycle_${Date.now()}`;
Â Â Â Â 
Â Â Â Â fullSchemaData.data.cycles[cycleId] = {
Â Â Â Â Â Â Â Â id: cycleId,
Â Â Â Â Â Â Â Â title: "Getting Started",
Â Â Â Â Â Â Â Â tasks: [
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: "task-welcome",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: "Welcome to miniCycle! ğŸ‰",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â completed: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: "task-guide",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: "Add your first task using the input box above âœï¸",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â completed: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â ],
Â Â Â Â Â Â Â Â autoReset: true,
Â Â Â Â Â Â Â Â deleteCheckedTasks: false,
Â Â Â Â Â Â Â Â cycleCount: 0,
Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â };
Â Â Â Â 
Â Â Â Â fullSchemaData.appState.activeCycleId = cycleId;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;
Â Â Â Â 
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Basic fallback cycle created');
Â Â Â Â completeInitialSetup(cycleId, fullSchemaData);
}

// âœ… UPDATED: Simplified showOnboarding for existing users or edge cases
function showOnboarding() {
Â Â Â Â console.log('ğŸ‘‹ Checking onboarding status (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for showOnboarding');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const hasSeenOnboarding = schemaData.settings.onboardingCompleted || false;
Â Â Â Â 
Â Â Â Â if (hasSeenOnboarding) {
Â Â Â Â Â Â Â Â console.log('âœ… User has already completed onboarding');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… This function is now only called for edge cases
Â Â Â Â // Main onboarding flow is handled in initialSetup
Â Â Â Â console.log('ğŸ¯ Showing standalone onboarding...');
Â Â Â Â showOnboardingThenCycleCreation({}, null);
}

// âœ… Keep the same completeInitialSetup and createInitialSchema25Data functions
function completeInitialSetup(activeCycle, fullSchemaData = null, schemaData = null) {
Â Â Â Â console.log('âœ… Completing initial setup for cycle:', activeCycle);
Â Â Â Â 
Â Â Â Â // Get fresh data if not provided
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â schemaData = loadMiniCycleData();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!fullSchemaData) {
Â Â Â Â Â Â Â Â fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const { cycles, reminders, settings } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â console.error('âŒ Cycle not found after setup:', activeCycle);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Loading existing cycle from Schema 2.5:', activeCycle);
Â Â Â Â 
Â Â Â Â // Load UI from Schema 2.5
Â Â Â Â const titleElement = document.getElementById("mini-cycle-title");
Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â const deleteCheckedTasks = document.getElementById("deleteCheckedTasks");
Â Â Â Â const enableReminders = document.getElementById("enableReminders");
Â Â Â Â const frequencySection = document.getElementById("frequency-section");
Â Â Â Â 
Â Â Â Â if (titleElement) {
Â Â Â Â Â Â Â Â titleElement.textContent = currentCycle.title;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (toggleAutoReset) {
Â Â Â Â Â Â Â Â toggleAutoReset.checked = currentCycle.autoReset || false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (deleteCheckedTasks) {
Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = currentCycle.deleteCheckedTasks || false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âš™ï¸ Applied cycle settings:', {
Â Â Â Â Â Â Â Â autoReset: currentCycle.autoReset,
Â Â Â Â Â Â Â Â deleteCheckedTasks: currentCycle.deleteCheckedTasks
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Load reminders from Schema 2.5
Â Â Â Â if (enableReminders) {
Â Â Â Â Â Â Â Â enableReminders.checked = reminders.enabled === true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (reminders.enabled && frequencySection) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”” Starting reminders...');
Â Â Â Â Â Â Â Â Â Â Â Â frequencySection.classList.remove("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â startReminders();
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â // Apply dark mode and theme from settings
Â Â Â Â if (settings.darkMode) {
Â Â Â Â Â Â Â Â console.log('ğŸŒ™ Applying dark mode...');
Â Â Â Â Â Â Â Â document.body.classList.add("dark-mode");
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (settings.theme && settings.theme !== 'default') {
Â Â Â Â Â Â Â Â console.log('ğŸ¨ Applying theme:', settings.theme);
Â Â Â Â Â Â Â Â // Apply theme without calling updateThemeColor() to avoid double call
Â Â Â Â Â Â Â Â const allThemes = ['theme-dark-ocean', 'theme-golden-glow'];
Â Â Â Â Â Â Â Â allThemes.forEach(theme => document.body.classList.remove(theme));
Â Â Â Â Â Â Â Â document.body.classList.add(`theme-${settings.theme}`);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Update theme color after applying all settings
Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ¯ Loading miniCycle...');
Â Â Â Â loadMiniCycle();
Â Â Â Â 
Â Â Â Â console.log('âœ… Initial setup completed successfully');
}

function createInitialSchema25Data() {
Â Â Â Â const initialData = {
Â Â Â Â Â Â Â Â schemaVersion: "2.5",
Â Â Â Â Â Â Â Â metadata: {
Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â lastModified: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â migratedFrom: null,
Â Â Â Â Â Â Â Â Â Â Â Â migrationDate: null,
Â Â Â Â Â Â Â Â Â Â Â Â totalCyclesCreated: 0,
Â Â Â Â Â Â Â Â Â Â Â Â totalTasksCompleted: 0,
Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: "2.5"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â settings: {
Â Â Â Â Â Â Â Â Â Â Â Â theme: 'default',
Â Â Â Â Â Â Â Â Â Â Â Â darkMode: false,
Â Â Â Â Â Â Â Â Â Â Â Â alwaysShowRecurring: false,
Â Â Â Â Â Â Â Â Â Â Â Â autoSave: true,
Â Â Â Â Â Â Â Â Â Â Â Â showThreeDots: false,
Â Â Â Â Â Â Â Â Â Â Â Â onboardingCompleted: false,
Â Â Â Â Â Â Â Â Â Â Â Â dismissedEducationalTips: {},
Â Â Â Â Â Â Â Â Â Â Â Â defaultRecurringSettings: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â frequency: "daily",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â indefinitely: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â time: null
Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â unlockedThemes: [],
Â Â Â Â Â Â Â Â Â Â Â Â unlockedFeatures: [],
Â Â Â Â Â Â Â Â Â Â Â Â notificationPosition: { x: 0, y: 0 },
Â Â Â Â Â Â Â Â Â Â Â Â notificationPositionModified: false,
Â Â Â Â Â Â Â Â Â Â Â Â accessibility: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â reducedMotion: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â highContrast: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â screenReaderHints: false
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â data: {
Â Â Â Â Â Â Â Â Â Â Â Â cycles: {} // Empty - user will create their first cycle
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â appState: {
Â Â Â Â Â Â Â Â Â Â Â Â activeCycleId: null, // No active cycle yet
Â Â Â Â Â Â Â Â Â Â Â Â overdueTaskStates: {} // âœ… Add this for overdue task tracking
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â userProgress: {
Â Â Â Â Â Â Â Â Â Â Â Â cyclesCompleted: 0,
Â Â Â Â Â Â Â Â Â Â Â Â rewardMilestones: []
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â customReminders: {
Â Â Â Â Â Â Â Â Â Â Â Â enabled: false,
Â Â Â Â Â Â Â Â Â Â Â Â indefinite: false,
Â Â Â Â Â Â Â Â Â Â Â Â dueDatesReminders: false,
Â Â Â Â Â Â Â Â Â Â Â Â repeatCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â frequencyValue: 30,
Â Â Â Â Â Â Â Â Â Â Â Â frequencyUnit: "minutes"
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(initialData));
Â Â Â Â console.log('âœ… Initial Schema 2.5 data created');
}








function setupDarkModeToggle(toggleId, allToggleIds = []) {
Â Â Â Â const thisToggle = document.getElementById(toggleId);
Â Â Â Â if (!thisToggle) return;

Â Â Â Â console.log('ğŸŒ™ Setting up dark mode toggle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for setupDarkModeToggle');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const isDark = schemaData.settings.darkMode || false;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Loading dark mode state from Schema 2.5:', isDark);

Â Â Â Â // Set initial checked state
Â Â Â Â thisToggle.checked = isDark;
Â Â Â Â document.body.classList.toggle("dark-mode", isDark);

Â Â Â Â // âœ… Update theme color on initial load
Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â }

Â Â Â Â // Event handler
Â Â Â Â thisToggle.addEventListener("change", (e) => {
Â Â Â Â Â Â Â Â const enabled = e.target.checked;
Â Â Â Â Â Â Â Â document.body.classList.toggle("dark-mode", enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸŒ™ Dark mode toggle changed:', enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Save to Schema 2.5 only
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.darkMode = enabled;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("âœ… Dark mode saved to Schema 2.5:", enabled);

Â Â Â Â Â Â Â Â // âœ… Sync all other toggles
Â Â Â Â Â Â Â Â allToggleIds.forEach(id => {
Â Â Â Â Â Â Â Â Â Â Â Â const otherToggle = document.getElementById(id);
Â Â Â Â Â Â Â Â Â Â Â Â if (otherToggle && otherToggle !== thisToggle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â otherToggle.checked = enabled;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â // âœ… Update theme color after dark mode change
Â Â Â Â Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Dark mode toggle setup completed');
}


// âœ… Dynamic Theme Color System with Gradient-Matching Solid Colors
function updateThemeColor() {
Â Â Â Â const body = document.body;
Â Â Â Â const themeColorMeta = document.getElementById('theme-color-meta');
Â Â Â Â const statusBarMeta = document.getElementById('status-bar-style-meta');
Â Â Â Â 
Â Â Â Â let themeColor = '#5680ff'; // Default (matches gradient start)
Â Â Â Â let statusBarStyle = 'default';
Â Â Â Â 
Â Â Â Â // âœ… Check for Dark Mode + Themes
Â Â Â Â if (body.classList.contains('dark-mode')) {
Â Â Â Â Â Â Â Â if (body.classList.contains('theme-dark-ocean')) {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#0e1d2f'; // Matches dark ocean gradient
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'black-translucent';
Â Â Â Â Â Â Â Â } else if (body.classList.contains('theme-golden-glow')) {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#4a3d00'; // Matches dark golden gradient
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'black-translucent';
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#1c1c1c'; // Regular dark mode
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'black-translucent';
Â Â Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â Â Â // âœ… Light Mode Themes
Â Â Â Â Â Â Â Â if (body.classList.contains('theme-dark-ocean')) {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#0e1d2f'; // Matches light ocean gradient start
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'default';
Â Â Â Â Â Â Â Â } else if (body.classList.contains('theme-golden-glow')) {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#ffe066'; // Matches light golden gradient start
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'default';
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â themeColor = '#5680ff'; // Matches default gradient start (#5680ff to #74c0fc)
Â Â Â Â Â Â Â Â Â Â Â Â statusBarStyle = 'default';
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Update meta tags
Â Â Â Â if (themeColorMeta) {
Â Â Â Â Â Â Â Â themeColorMeta.setAttribute('content', themeColor);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (statusBarMeta) {
Â Â Â Â Â Â Â Â statusBarMeta.setAttribute('content', statusBarStyle);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log(`Theme color updated to: ${themeColor}, Status bar: ${statusBarStyle}`);
}

function applyTheme(themeName) {
Â Â Â Â console.log('ğŸ¨ Applying theme (Schema 2.5 only)...', themeName);
Â Â Â Â 
Â Â Â Â // Step 1: Remove all theme classes
Â Â Â Â const allThemes = ['theme-dark-ocean', 'theme-golden-glow'];
Â Â Â Â allThemes.forEach(theme => document.body.classList.remove(theme));
Â Â 
Â Â Â Â // Step 2: Add selected theme class if it's not 'default'
Â Â Â Â if (themeName && themeName !== 'default') {
Â Â Â Â Â Â Â Â document.body.classList.add(`theme-${themeName}`);
Â Â Â Â }

Â Â Â Â // Step 3: Update theme color after applying theme
Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â }
Â Â 
Â Â Â Â // Step 4: Save to Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for applyTheme');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.settings.theme = themeName || 'default';
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log("âœ… Theme saved to Schema 2.5:", themeName);
Â Â 
Â Â Â Â // Step 5: Update UI checkboxes
Â Â Â Â document.querySelectorAll('.theme-toggle').forEach(cb => {
Â Â Â Â Â Â Â Â cb.checked = cb.id === `toggle${capitalize(themeName)}Theme`;
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Theme application completed');
}
Â Â 
Â Â // Optional helper to format checkbox IDs
Â Â function capitalize(str) {
Â Â Â Â return str
Â Â Â Â Â Â ? str.charAt(0).toUpperCase() + str.slice(1).replace(/-./g, s => s.charAt(1).toUpperCase())
Â Â Â Â Â Â : '';
Â Â }
/**
Â * Enables editing of the miniCycle title and saves changes to localStorage.
Â * Prevents empty titles and restores the previous title if an invalid entry is made.
Â */

function setupMiniCycleTitleListener() {
Â Â Â Â const titleElement = document.getElementById("mini-cycle-title");
Â Â Â Â if (!titleElement) return;

Â Â Â Â titleElement.contentEditable = true;

Â Â Â Â if (!titleElement.dataset.listenerAdded) {
Â Â Â Â Â Â Â Â titleElement.addEventListener("blur", () => {
Â Â Â Â Â Â Â Â Â Â Â Â let newTitle = sanitizeInput(titleElement.textContent.trim());

Â Â Â Â Â Â Â Â Â Â Â Â if (newTitle === "") {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ” Empty title detected, reverting (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for title revert');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const oldTitle = cycles[activeCycle]?.title || "Untitled miniCycle";

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš  Title cannot be empty. Reverting to previous title.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â titleElement.textContent = oldTitle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ Updating title (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for setupMiniCycleTitleListener');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â const miniCycleData = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (!activeCycle || !miniCycleData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn("âš  No active miniCycle found. Title update aborted.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â const oldTitle = miniCycleData.title;

Â Â Â Â Â Â Â Â Â Â Â Â if (newTitle !== oldTitle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ”„ Title change detected: "${oldTitle}" â†’ "${newTitle}"`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ” Capture undo snapshot BEFORE title change
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â titleElement.textContent = newTitle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â miniCycleData.title = newTitle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = miniCycleData;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… miniCycle title updated (Schema 2.5): "${oldTitle}" â†’ "${newTitle}"`);

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ”„ Update UI
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateMainMenuHeader();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ”„ Show undo button
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("undo-btn").hidden = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("redo-btn").hidden = true;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â titleElement.dataset.listenerAdded = true;
Â Â Â Â }
}

/**
Â * Saves the current state of the active miniCycle to localStorage.
Â * Captures task list, completion status, due dates, priority settings, and reminders.
Â */

// Update autoSave to handle both schemas
function autoSave(overrideTaskList = null) {
Â Â console.log('ğŸ’¾ Auto-saving (Schema 2.5 only)...');
Â Â 
Â Â const schemaData = loadMiniCycleData();
Â Â if (!schemaData) {
Â Â Â Â console.error('âŒ Schema 2.5 data required for auto-save');
Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â }

Â Â const { cycles, activeCycle } = schemaData;
Â Â 
Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â console.error("âŒ Error: Active cycle not found in Schema 2.5.");
Â Â Â Â return;
Â Â }
Â Â 
Â Â console.log('ğŸ“Š Auto-saving cycle:', activeCycle);
Â Â 
Â Â // Get current task data from DOM (same logic as before)
Â Â const miniCycleTasks = overrideTaskList || [...document.getElementById("taskList").children].map(taskElement => {
Â Â Â Â const taskTextElement = taskElement.querySelector(".task-text");
Â Â Â Â const dueDateElement = taskElement.querySelector(".due-date");
Â Â Â Â const reminderButton = taskElement.querySelector(".enable-task-reminders");
Â Â Â Â const taskId = taskElement.dataset.taskId;

Â Â Â Â if (!taskTextElement || !taskId) {
Â Â Â Â Â Â console.warn("âš ï¸ Skipping task (missing text or ID):", taskElement);
Â Â Â Â Â Â return null;
Â Â Â Â }

Â Â Â Â let recurringSettings = {};
Â Â Â Â const settingsAttr = taskElement.getAttribute("data-recurring-settings");
Â Â Â Â try {
Â Â Â Â Â Â if (settingsAttr) {
Â Â Â Â Â Â Â Â recurringSettings = JSON.parse(settingsAttr);
Â Â Â Â Â Â }
Â Â Â Â } catch (err) {
Â Â Â Â Â Â console.warn("âš ï¸ Could not parse recurringSettings from DOM:", err);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log("ğŸ’¾ Processing task for save:", taskId, recurringSettings);

Â Â Â Â return {
Â Â Â Â Â Â id: taskId,
Â Â Â Â Â Â text: taskTextElement.textContent,
Â Â Â Â Â Â completed: taskElement.querySelector("input[type='checkbox']").checked,
Â Â Â Â Â Â dueDate: dueDateElement ? dueDateElement.value : null,
Â Â Â Â Â Â highPriority: taskElement.classList.contains("high-priority"),
Â Â Â Â Â Â remindersEnabled: reminderButton ? reminderButton.classList.contains("reminder-active") : false,
Â Â Â Â Â Â recurring: taskElement.querySelector(".recurring-btn")?.classList.contains("active") || false,
Â Â Â Â Â Â recurringSettings,
Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â };
Â Â }).filter(Boolean);
Â Â 
Â Â console.log('ğŸ“ Saving tasks:', miniCycleTasks.length);
Â Â 
Â Â // Update Schema 2.5 structure
Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â fullSchemaData.data.cycles[activeCycle].tasks = miniCycleTasks;
Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â 
Â Â // Handle recurring templates in Schema 2.5
Â Â if (!fullSchemaData.data.cycles[activeCycle].recurringTemplates) {
Â Â Â Â fullSchemaData.data.cycles[activeCycle].recurringTemplates = {};
Â Â }

Â Â miniCycleTasks.forEach(task => {
Â Â Â Â if (task.recurring && task.recurringSettings) {
Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].recurringTemplates[task.id] = {
Â Â Â Â Â Â Â Â id: task.id,
Â Â Â Â Â Â Â Â text: task.text,
Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â recurringSettings: task.recurringSettings,
Â Â Â Â Â Â Â Â highPriority: task.highPriority,
Â Â Â Â Â Â Â Â dueDate: task.dueDate,
Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled,
Â Â Â Â Â Â Â Â lastTriggeredTimestamp:Â 
Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].recurringTemplates[task.id]?.lastTriggeredTimestamp || null,
Â Â Â Â Â Â Â Â schemaVersion: task.schemaVersion || 2
Â Â Â Â Â Â };
Â Â Â Â }
Â Â });

Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â 
Â Â // âœ… Logging for debugging (same as before)
Â Â console.log("ğŸ“‹ Task Status (Schema 2.5):");
Â Â miniCycleTasks.forEach(task => {
Â Â Â Â console.log(`- ${task.text}: ${task.completed ? "âœ… Completed" : "âŒ Not Completed"}Â 
Â Â Â Â Â Â ${task.dueDate ? `(Due: ${task.dueDate})` : ''}Â 
Â Â Â Â Â Â ${task.highPriority ? "ğŸ”¥ High Priority" : ""}Â 
Â Â Â Â Â Â ${task.remindersEnabled ? "ğŸ”” Reminders ON" : "ğŸ”• Reminders OFF"}Â 
Â Â Â Â Â Â ${task.recurring ? "ğŸ” Recurring ON" : "â†©ï¸ Not Recurring"}`);
Â Â });

Â Â console.table(miniCycleTasks.map(t => ({
Â Â Â Â id: t.id,
Â Â Â Â text: t.text,
Â Â Â Â recurring: t.recurring,
Â Â Â Â frequency: t.recurringSettings?.frequency || "â€“",
Â Â Â Â version: t.schemaVersion
Â Â })));
Â Â 
Â Â console.log('âœ… Auto-save completed successfully');
}




/**
Â * Loads the last used miniCycle from localStorage and updates the UI.
Â * Ensures tasks, title, settings, and overdue statuses are properly restored.
Â */
/**
Â * Main coordination function - now much simpler
Â */
function loadMiniCycle() {
Â Â Â Â console.log('ğŸ”„ Loading miniCycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ No Schema 2.5 data found');
Â Â Â Â Â Â Â Â createInitialSchema25Data();
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â console.error('âŒ No valid active cycle found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â // ğŸ”§ 1. Repair and clean data
Â Â Â Â const cleanedTasks = repairAndCleanTasks(currentCycle);
Â Â Â Â 
Â Â Â Â // ğŸ’¾ 2. Save any repairs made
Â Â Â Â if (cleanedTasks.wasModified) {
Â Â Â Â Â Â Â Â saveCycleData(activeCycle, currentCycle);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // ğŸ¨ 3. Render tasks to DOM
Â Â Â Â renderTasksToDOM(currentCycle.tasks);
Â Â Â Â 
Â Â Â Â // âš™ï¸ 4. Update UI state
Â Â Â Â updateCycleUIState(currentCycle, schemaData.settings);
Â Â Â Â 
Â Â Â Â // ğŸ”” 5. Configure reminders
Â Â Â Â setupRemindersForCycle(schemaData.reminders);
Â Â Â Â 
Â Â Â Â // ğŸ“Š 6. Update dependent UI components
Â Â Â Â updateDependentComponents();
Â Â Â Â 
Â Â Â Â console.log('âœ… Cycle loading completed');
}

/**
Â * Handles task data repair and cleanup
Â */
function repairAndCleanTasks(currentCycle) {
Â Â Â Â if (!currentCycle.tasks || !Array.isArray(currentCycle.tasks)) {
Â Â Â Â Â Â Â Â return { tasks: [], wasModified: false };
Â Â Â Â }

Â Â Â Â let tasksModified = false;
Â Â Â Â 
Â Â Â Â // Process each task for repairs
Â Â Â Â currentCycle.tasks.forEach((task, index) => {
Â Â Â Â Â Â Â Â if (!task) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Fix missing text
Â Â Â Â Â Â Â Â const hasText = task.text || task.taskText;
Â Â Â Â Â Â Â Â if (!hasText) {
Â Â Â Â Â Â Â Â Â Â Â Â task.text = task.text || task.taskText || `[Task ${index + 1}]`;
Â Â Â Â Â Â Â Â Â Â Â Â tasksModified = true;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Fix missing ID
Â Â Â Â Â Â Â Â if (!task.id) {
Â Â Â Â Â Â Â Â Â Â Â Â task.id = `task-${Date.now()}-${index}`;
Â Â Â Â Â Â Â Â Â Â Â Â tasksModified = true;
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Filter out truly unusable tasks
Â Â Â Â const validTasks = currentCycle.tasks.filter(task => {
Â Â Â Â Â Â Â Â return task && (task.text || task.taskText);
Â Â Â Â });
Â Â Â Â 
Â Â Â Â currentCycle.tasks = validTasks;
Â Â Â Â 
Â Â Â Â return {
Â Â Â Â Â Â Â Â tasks: validTasks,
Â Â Â Â Â Â Â Â wasModified: tasksModified || validTasks.length !== currentCycle.tasks.length
Â Â Â Â };
}

/**
Â * Renders tasks to the DOM
Â */
function renderTasksToDOM(tasks) {
Â Â Â Â const taskList = document.getElementById("taskList");
Â Â Â Â if (!taskList) return;
Â Â Â Â 
Â Â Â Â taskList.innerHTML = "";
Â Â Â Â 
Â Â Â Â tasks.forEach((task) => {
Â Â Â Â Â Â Â Â const taskText = task.text || task.taskText || '';
Â Â Â Â Â Â Â Â const taskId = task.id || `task-${Date.now()}-${Math.random()}`;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â addTask(
Â Â Â Â Â Â Â Â Â Â Â Â taskText,
Â Â Â Â Â Â Â Â Â Â Â Â task.completed || false,
Â Â Â Â Â Â Â Â Â Â Â Â false, // Don't save during load
Â Â Â Â Â Â Â Â Â Â Â Â task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â Â Â task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â Â Â true, // isLoading = true
Â Â Â Â Â Â Â Â Â Â Â Â task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â Â Â task.recurring || false,
Â Â Â Â Â Â Â Â Â Â Â Â taskId,
Â Â Â Â Â Â Â Â Â Â Â Â task.recurringSettings || {}
Â Â Â Â Â Â Â Â );
Â Â Â Â });
}

/**
Â * Updates UI state for the current cycle
Â */
function updateCycleUIState(currentCycle, settings) {
Â Â Â Â // Update title
Â Â Â Â const titleElement = document.getElementById("mini-cycle-title");
Â Â Â Â if (titleElement) {
Â Â Â Â Â Â Â Â titleElement.textContent = currentCycle.title || "Untitled Cycle";
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Update toggles
Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â const deleteCheckedTasks = document.getElementById("deleteCheckedTasks");
Â Â Â Â 
Â Â Â Â if (toggleAutoReset) {
Â Â Â Â Â Â Â Â toggleAutoReset.checked = currentCycle.autoReset || false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (deleteCheckedTasks) {
Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = currentCycle.deleteCheckedTasks || false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Apply theme settings
Â Â Â Â applyThemeSettings(settings);
}

/**
Â * Applies theme settings from schema data
Â */
function applyThemeSettings(settings) {
Â Â Â Â if (settings.darkMode) {
Â Â Â Â Â Â Â Â document.body.classList.add("dark-mode");
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (settings.theme && settings.theme !== 'default') {
Â Â Â Â Â Â Â Â const allThemes = ['theme-dark-ocean', 'theme-golden-glow'];
Â Â Â Â Â Â Â Â allThemes.forEach(theme => document.body.classList.remove(theme));
Â Â Â Â Â Â Â Â document.body.classList.add(`theme-${settings.theme}`);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â }
}

/**
Â * Sets up reminders for the current cycle
Â */
function setupRemindersForCycle(reminders) {
Â Â Â Â const enableReminders = document.getElementById("enableReminders");
Â Â Â Â const frequencySection = document.getElementById("frequency-section");
Â Â Â Â 
Â Â Â Â if (!enableReminders) return;
Â Â Â Â 
Â Â Â Â enableReminders.checked = reminders.enabled === true;
Â Â Â Â 
Â Â Â Â if (reminders.enabled && frequencySection) {
Â Â Â Â Â Â Â Â frequencySection.classList.remove("hidden");
Â Â Â Â Â Â Â Â startReminders();
Â Â Â Â }
}

/**
Â * Updates all dependent UI components
Â */
function updateDependentComponents() {
Â Â Â Â updateProgressBar();
Â Â Â Â checkCompleteAllButton();
Â Â Â Â updateMainMenuHeader();
Â Â Â Â updateStatsPanel();
}

/**
Â * Saves cycle data to Schema 2.5 storage
Â */
function saveCycleData(activeCycle, currentCycle) {
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
}
// ...existing code...
/**
Â * Checks for overdue tasks and visually marks them as overdue.
Â * Notifies the user if newly overdue tasks are detected.
Â *
Â * @param {HTMLElement|null} taskToCheck - The specific task to check, or null to check all tasks.
Â */

function checkOverdueTasks(taskToCheck = null) {
Â Â Â Â const tasks = taskToCheck ? [taskToCheck] : document.querySelectorAll(".task");
Â Â Â Â let autoReset = toggleAutoReset.checked;

Â Â Â Â // âœ… Get overdue states from Schema 2.5 instead of separate localStorage key
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for checkOverdueTasks');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â let overdueTaskStates = fullSchemaData.appState.overdueTaskStates || {};

Â Â Â Â // âœ… Track tasks that just became overdue
Â Â Â Â let newlyOverdueTasks = [];

Â Â Â Â tasks.forEach(task => {
Â Â Â Â Â Â Â Â const taskText = task.querySelector(".task-text").textContent;
Â Â Â Â Â Â Â Â const dueDateInput = task.querySelector(".due-date");
Â Â Â Â Â Â Â Â if (!dueDateInput) return;

Â Â Â Â Â Â Â Â const dueDateValue = dueDateInput.value;
Â Â Â Â Â Â Â Â if (!dueDateValue) {
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Date was cleared â€” remove overdue class
Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â delete overdueTaskStates[taskText];
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const dueDate = new Date(dueDateValue);
Â Â Â Â Â Â Â Â const today = new Date();
Â Â Â Â Â Â Â Â today.setHours(0, 0, 0, 0);
Â Â Â Â Â Â Â Â dueDate.setHours(0, 0, 0, 0);

Â Â Â Â Â Â Â Â if (dueDate < today) {
Â Â Â Â Â Â Â Â Â Â Â Â if (!autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!overdueTaskStates[taskText]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â newlyOverdueTasks.push(taskText); // âœ… Only notify if it just became overdue
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.add("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â overdueTaskStates[taskText] = true;
Â Â Â Â Â Â Â Â Â Â Â Â } else if (overdueTaskStates[taskText]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.add("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â delete overdueTaskStates[taskText];
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â // âœ… Save overdue states back to Schema 2.5
Â Â Â Â fullSchemaData.appState.overdueTaskStates = overdueTaskStates;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â // âœ… Show notification ONLY if there are newly overdue tasks
Â Â Â Â if (newlyOverdueTasks.length > 0) {
Â Â Â Â Â Â Â Â showNotification(`âš ï¸ Overdue Tasks:<br>- ${newlyOverdueTasks.join("<br>- ")}`, "error");
Â Â Â Â }
}
















// Add this after your existing migration functions, around line 1100

// ==========================================
// ğŸ”„ SCHEMA 2.5 MIGRATION SYSTEM
// ==========================================

const SCHEMA_2_5_TARGET = {
Â Â schemaVersion: "2.5",
Â Â metadata: {
Â Â Â Â createdAt: null,
Â Â Â Â lastModified: null,
Â Â Â Â migratedFrom: null,
Â Â Â Â migrationDate: null,
Â Â Â Â totalCyclesCreated: 0,
Â Â Â Â totalTasksCompleted: 0,
Â Â Â Â schemaVersion: "2.5"
Â Â },
Â Â settings: {
Â Â Â Â theme: null,
Â Â Â Â darkMode: false,
Â Â Â Â alwaysShowRecurring: false,
Â Â Â Â autoSave: true,
Â Â Â Â defaultRecurringSettings: {
Â Â Â Â Â Â frequency: null,
Â Â Â Â Â Â indefinitely: true,
Â Â Â Â Â Â time: null
Â Â Â Â },
Â Â Â Â unlockedThemes: [],
Â Â Â Â unlockedFeatures: [],
Â Â Â Â notificationPosition: { x: 0, y: 0 },
Â Â Â Â notificationPositionModified: false,
Â Â Â Â accessibility: {
Â Â Â Â Â Â reducedMotion: false,
Â Â Â Â Â Â highContrast: false,
Â Â Â Â Â Â screenReaderHints: false
Â Â Â Â }
Â Â },
Â Â data: {
Â Â Â Â cycles: {}
Â Â },
Â Â appState: {
Â Â Â Â activeCycleId: null
Â Â },
Â Â userProgress: {
Â Â Â Â cyclesCompleted: 0,
Â Â Â Â rewardMilestones: []
Â Â },
Â Â customReminders: {
Â Â Â Â enabled: false,
Â Â Â Â indefinite: false,
Â Â Â Â dueDatesReminders: false,
Â Â Â Â repeatCount: 0,
Â Â Â Â frequencyValue: 30,
Â Â Â Â frequencyUnit: "minutes"
Â Â }
};

function checkMigrationNeeded() {
Â Â const currentData = localStorage.getItem("miniCycleData");
Â Â if (currentData) {
Â Â Â Â const parsed = JSON.parse(currentData);
Â Â Â Â if (parsed.schemaVersion === "2.5") {
Â Â Â Â Â Â return { needed: false, currentVersion: "2.5" };
Â Â Â Â }
Â Â }

Â Â // Check for old format data
Â Â const oldCycles = localStorage.getItem("miniCycleStorage");
Â Â const lastUsed = localStorage.getItem("lastUsedMiniCycle");
Â Â const reminders = localStorage.getItem("miniCycleReminders");
Â Â 
Â Â const hasOldData = oldCycles || lastUsed || reminders;
Â Â 
Â Â return {
Â Â Â Â needed: hasOldData,
Â Â Â Â currentVersion: currentData ? "unknown" : "legacy",
Â Â Â Â oldDataFound: {
Â Â Â Â Â Â cycles: !!oldCycles,
Â Â Â Â Â Â lastUsed: !!lastUsed,
Â Â Â Â Â Â reminders: !!reminders,
Â Â Â Â Â Â milestones: !!localStorage.getItem("milestoneUnlocks"),
Â Â Â Â Â Â darkMode: document.body.classList.contains('dark-mode')
Â Â Â Â }
Â Â };
}

function simulateMigrationToSchema25(dryRun = true) {
Â Â const results = {
Â Â Â Â success: false,
Â Â Â Â errors: [],
Â Â Â Â warnings: [],
Â Â Â Â changes: [],
Â Â Â Â dataPreview: null
Â Â };

Â Â try {
Â Â Â Â // 1. Gather existing data
Â Â Â Â const oldCycles = JSON.parse(localStorage.getItem("miniCycleStorage") || "{}");
Â Â Â Â const lastUsed = localStorage.getItem("lastUsedMiniCycle");
Â Â Â Â const reminders = JSON.parse(localStorage.getItem("miniCycleReminders") || "{}");
Â Â Â Â const milestones = JSON.parse(localStorage.getItem("milestoneUnlocks") || "{}");
Â Â Â Â const moveArrows = localStorage.getItem("miniCycleMoveArrows") === "true";
Â Â Â Â const threeDots = localStorage.getItem("miniCycleThreeDots") === "true";
Â Â Â Â const alwaysRecurring = JSON.parse(localStorage.getItem("miniCycleAlwaysShowRecurring")) || false;
Â Â Â Â const darkModeEnabled = localStorage.getItem("darkModeEnabled") === "true";
Â Â Â Â const currentTheme = localStorage.getItem("currentTheme") || null;
Â Â Â Â const notifPosition = JSON.parse(localStorage.getItem("miniCycleNotificationPosition") || "{}");

Â Â Â Â // 2. Create new schema structure
Â Â Â Â const newData = JSON.parse(JSON.stringify(SCHEMA_2_5_TARGET));
Â Â Â Â 
Â Â Â Â // 3. Populate metadata
Â Â Â Â newData.metadata.createdAt = Date.now();
Â Â Â Â newData.metadata.lastModified = Date.now();
Â Â Â Â newData.metadata.migratedFrom = "legacy";
Â Â Â Â newData.metadata.migrationDate = Date.now();
Â Â Â Â newData.metadata.totalCyclesCreated = Object.keys(oldCycles).length;
Â Â Â Â 
Â Â Â Â // Calculate total completed tasks
Â Â Â Â let totalCompleted = 0;
Â Â Â Â Object.values(oldCycles).forEach(cycle => {
Â Â Â Â Â Â totalCompleted += cycle.cycleCount || 0;
Â Â Â Â });
Â Â Â Â newData.metadata.totalTasksCompleted = totalCompleted;

Â Â Â Â // 4. Populate settings
Â Â Â Â newData.settings.theme = currentTheme;
Â Â Â Â newData.settings.darkMode = darkModeEnabled;
Â Â Â Â newData.settings.alwaysShowRecurring = alwaysRecurring;
Â Â Â Â 
Â Â Â Â // Unlocked themes from milestones
Â Â Â Â if (milestones.darkOcean) newData.settings.unlockedThemes.push("dark-ocean");
Â Â Â Â if (milestones.goldenGlow) newData.settings.unlockedThemes.push("golden-glow");
Â Â Â Â if (milestones.taskOrderGame) newData.settings.unlockedFeatures.push("task-order-game");

Â Â Â Â // Notification position
Â Â Â Â if (notifPosition.x || notifPosition.y) {
Â Â Â Â Â Â newData.settings.notificationPosition = notifPosition;
Â Â Â Â Â Â newData.settings.notificationPositionModified = true;
Â Â Â Â }

Â Â Â Â // 5. Migrate cycles
Â Â Â Â newData.data.cycles = oldCycles;
Â Â Â Â newData.appState.activeCycleId = lastUsed;

Â Â Â Â // 6. Migrate reminders
Â Â Â Â newData.customReminders = {
Â Â Â Â Â Â enabled: reminders.enabled || false,
Â Â Â Â Â Â indefinite: reminders.indefinite || false,
Â Â Â Â Â Â dueDatesReminders: reminders.dueDatesReminders || false,
Â Â Â Â Â Â repeatCount: reminders.repeatCount || 0,
Â Â Â Â Â Â frequencyValue: reminders.frequencyValue || 30,
Â Â Â Â Â Â frequencyUnit: reminders.frequencyUnit || "minutes"
Â Â Â Â };

Â Â Â Â // 7. User progress
Â Â Â Â newData.userProgress.cyclesCompleted = totalCompleted;
Â Â Â Â if (milestones.darkOcean) newData.userProgress.rewardMilestones.push("dark-ocean-5");
Â Â Â Â if (milestones.goldenGlow) newData.userProgress.rewardMilestones.push("golden-glow-50");

Â Â Â Â results.changes.push(`âœ… Found ${Object.keys(oldCycles).length} cycles to migrate`);
Â Â Â Â results.changes.push(`âœ… Active cycle: ${lastUsed || "none"}`);
Â Â Â Â results.changes.push(`âœ… Total completed cycles: ${totalCompleted}`);
Â Â Â Â results.changes.push(`âœ… Reminders enabled: ${reminders.enabled ? "yes" : "no"}`);
Â Â Â Â results.changes.push(`âœ… Themes unlocked: ${newData.settings.unlockedThemes.length}`);
Â Â Â Â 
Â Â Â Â if (!dryRun) {
Â Â Â Â Â Â // Actually perform migration
Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(newData));
Â Â Â Â Â Â results.changes.push("ğŸš€ Migration completed - data saved to miniCycleData");
Â Â Â Â Â Â 
Â Â Â Â Â Â // Optionally backup old data
Â Â Â Â Â Â const backupKey = `migration_backup_${Date.now()}`;
Â Â Â Â Â Â const oldData = {
Â Â Â Â Â Â Â Â miniCycleStorage: oldCycles,
Â Â Â Â Â Â Â Â lastUsedMiniCycle: lastUsed,
Â Â Â Â Â Â Â Â miniCycleReminders: reminders,
Â Â Â Â Â Â Â Â milestoneUnlocks: milestones,
Â Â Â Â Â Â Â Â darkModeEnabled: darkModeEnabled,
Â Â Â Â Â Â Â Â currentTheme: currentTheme
Â Â Â Â Â Â };
Â Â Â Â Â Â localStorage.setItem(backupKey, JSON.stringify(oldData));
Â Â Â Â Â Â results.changes.push(`ğŸ’¾ Old data backed up to ${backupKey}`);
Â Â Â Â }

Â Â Â Â results.dataPreview = newData;
Â Â Â Â results.success = true;

Â Â } catch (error) {
Â Â Â Â results.errors.push(`Migration failed: ${error.message}`);
Â Â }

Â Â return results;
}

function performSchema25Migration() {
Â Â // Create backup first
Â Â const backupKey = `pre_migration_backup_${Date.now()}`;
Â Â const currentData = {};
Â Â 
Â Â // Backup all current localStorage
Â Â ["miniCycleStorage", "lastUsedMiniCycle", "miniCycleReminders",Â 
Â Â Â "milestoneUnlocks", "darkModeEnabled", "currentTheme",Â 
Â Â Â "miniCycleNotificationPosition", "miniCycleAlwaysShowRecurring"].forEach(key => {
Â Â Â Â const value = localStorage.getItem(key);
Â Â Â Â if (value) currentData[key] = value;
Â Â });
Â Â 
Â Â localStorage.setItem(backupKey, JSON.stringify(currentData));

Â Â // Perform actual migration
Â Â const results = simulateMigrationToSchema25(false);
Â Â 
Â Â if (results.success) {
Â Â Â Â // Clean up old keys (optional - you might want to keep them temporarily)
Â Â Â Â // Object.keys(currentData).forEach(key => localStorage.removeItem(key));
Â Â Â Â results.changes.push(`ğŸ—‚ï¸ Backup created: ${backupKey}`);
Â Â }

Â Â return results;
}



// âœ… Make loadMiniCycleData() return legacy-compatible data as fallback
function loadMiniCycleData() {
Â Â Â Â const data = localStorage.getItem("miniCycleData");
Â Â Â Â if (data) {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â const parsed = JSON.parse(data);
Â Â Â Â Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycles: parsed.data.cycles,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â activeCycle: parsed.appState.activeCycleId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminders: parsed.customReminders,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â settings: parsed.settings
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Error parsing Schema 2.5 data:', error);
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… CREATE INITIAL DATA IF NONE EXISTS
Â Â Â Â console.log('ğŸ†• Creating initial Schema 2.5 structure...');
Â Â Â Â createInitialSchema25Data();
Â Â Â Â 
Â Â Â Â // Try again after creating
Â Â Â Â const newData = localStorage.getItem("miniCycleData");
Â Â Â Â if (newData) {
Â Â Â Â Â Â Â Â const parsed = JSON.parse(newData);
Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â cycles: parsed.data.cycles,
Â Â Â Â Â Â Â Â Â Â Â Â activeCycle: parsed.appState.activeCycleId,
Â Â Â Â Â Â Â Â Â Â Â Â reminders: parsed.customReminders,
Â Â Â Â Â Â Â Â Â Â Â Â settings: parsed.settings
Â Â Â Â Â Â Â Â };
Â Â Â Â }
Â Â Â Â 
Â Â Â Â return null;
}

// Make loadMiniCycleData globally accessible for the notification module
window.loadMiniCycleData = loadMiniCycleData;





// âœ… Auto-Migration with Enhanced Data Fixing and Lenient Validation
async function performAutoMigration(options = {}) {
Â Â Â Â const {Â 
Â Â Â Â Â Â Â Â forceMode = false,Â 
Â Â Â Â Â Â Â Â skipValidation = false,Â 
Â Â Â Â Â Â Â Â skipBackup = falseÂ 
Â Â Â Â } = options;
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Starting auto-migration processâ€¦', {
Â Â Â Â Â Â Â Â Â Â Â Â forceMode,
Â Â Â Â Â Â Â Â Â Â Â Â skipValidation,
Â Â Â Â Â Â Â Â Â Â Â Â skipBackup
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… FORCE MODE: Skip all safety checks
Â Â Â Â Â Â Â Â if (forceMode) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸš¨ FORCE MODE ACTIVE - Bypassing all safety checks');
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (!skipBackup) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const backupResult = await createAutomaticMigrationBackup();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Emergency backup created:', backupResult.backupKey);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Apply fixes without validation
Â Â Â Â Â Â Â Â Â Â Â Â const fixResult = fixTaskValidationIssues();
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”§ Applied fixes:', fixResult);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Force the migration
Â Â Â Â Â Â Â Â Â Â Â Â const migrationResult = performSchema25Migration();
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (migrationResult.success || migrationResult.partialSuccess) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification('âœ… Force migration completed! Some data may need manual review.', 'success', 6000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â success: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â forced: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: 'Force migration completed',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â warnings: migrationResult.warnings || []
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Even force mode failed - create minimal Schema 2.5 structure
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return createMinimalSchema25();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â console.log('ğŸ“Š Current localStorage keys:', Object.keys(localStorage));
Â Â Â Â 
Â Â Â Â // Step 1: Check if migration is needed
Â Â Â Â console.log('ğŸ” Checking if migration is needed...');
Â Â Â Â const migrationCheck = checkMigrationNeeded();
Â Â Â Â console.log('ğŸ“‹ Migration check result:', migrationCheck);
Â Â Â Â 
Â Â Â Â if (!migrationCheck.needed) {
Â Â Â Â Â Â Â Â console.log('âœ… No migration needed - user already on Schema 2.5');
Â Â Â Â Â Â Â Â console.log('ğŸ“¦ Current miniCycleData exists:', !!localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â return { success: true, message: 'Already on latest schema' };
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸš¨ Migration needed. Old data found:', migrationCheck.oldDataFound);
Â Â Â Â 
Â Â Â Â // Step 2: Show user notification
Â Â Â Â console.log('ğŸ“¢ Showing migration notification to user...');
Â Â Â Â showNotification('ğŸ”„ Updating your data format... This will take a moment.', 'info', 200);
Â Â Â Â 
Â Â Â Â // Step 3: Create automatic backup before migration
Â Â Â Â console.log('ğŸ“¥ Creating automatic backup before migration...');
Â Â Â Â console.log('ğŸ’¾ Available storage before backup:', {
Â Â Â Â Â Â Â Â used: JSON.stringify(localStorage).length,
Â Â Â Â Â Â Â Â limit: '~5-10MB (browser dependent)'
Â Â Â Â });
Â Â Â Â 
Â Â Â Â const backupResult = await createAutomaticMigrationBackup();
Â Â Â Â console.log('ğŸ’¾ Backup result:', backupResult);
Â Â Â Â 
Â Â Â Â if (!backupResult.success) {
Â Â Â Â Â Â Â Â console.error('âŒ Backup creation failed:', backupResult.message);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Troubleshooting: Check storage space and localStorage accessibility');
Â Â Â Â Â Â Â Â return await handleMigrationFailure('Backup creation failed', null);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Backup created successfully:', {
Â Â Â Â Â Â Â Â backupKey: backupResult.backupKey,
Â Â Â Â Â Â Â Â size: backupResult.size,
Â Â Â Â Â Â Â Â sizeKB: Math.round(backupResult.size / 1024)
Â Â Â Â });

Â Â Â Â // Step 3.5: âœ… ENHANCED - Pre-fix data validation issues with detailed reporting
Â Â Â Â console.log('ğŸ”§ Pre-fixing known data validation issues...');
Â Â Â Â const fixResult = fixTaskValidationIssues();
Â Â Â Â console.log('ğŸ”§ Data fix result:', fixResult);
Â Â Â Â 
Â Â Â Â if (fixResult.success && fixResult.fixedCount > 0) {
Â Â Â Â Â Â Â Â console.log(`âœ… Successfully fixed ${fixResult.fixedCount} data issues:`);
Â Â Â Â Â Â Â Â fixResult.details?.forEach(detail => console.log(` Â  - ${detail}`));
Â Â Â Â Â Â Â Â showNotification(`ğŸ”§ Fixed ${fixResult.fixedCount} data compatibility issues`, 'info', 3000);
Â Â Â Â } else if (!fixResult.success) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Data fixing encountered issues, but continuing with migration');
Â Â Â Â Â Â Â Â console.warn('ğŸ”§ Fix error:', fixResult.message);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('âœ… No data fixes needed - all data is already compatible');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Step 4: âœ… ENHANCED - Use lenient validation for auto-migration
Â Â Â Â console.log('ğŸ” Performing lenient validation for auto-migration...');
Â Â Â Â console.log('ğŸ“‹ Using lenient validation approach for better migration success...');
Â Â Â Â 
Â Â Â Â // âœ… Use lenient validation instead of strict validation
Â Â Â Â const legacyValidationResults = validateAllMiniCycleTasksLenient();
Â Â Â Â console.log('ğŸ“Š Lenient validation results:', legacyValidationResults);
Â Â Â Â 
Â Â Â Â if (legacyValidationResults.length > 0) {
Â Â Â Â Â Â Â Â console.error('âŒ Critical data issues found even after fixes:', legacyValidationResults);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ These are fundamental problems that prevent migration:');
Â Â Â Â Â Â Â Â legacyValidationResults.forEach((error, index) => {
Â Â Â Â Â Â Â Â Â Â Â Â console.error(` Â  ${index + 1}. ${JSON.stringify(error, null, 2)}`);
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Show user-friendly message about what went wrong
Â Â Â Â Â Â Â Â const errorSummary = legacyValidationResults.length === 1Â 
Â Â Â Â Â Â Â Â Â Â Â Â ? `1 critical issue: ${legacyValidationResults[0].errors?.[0] || 'Unknown error'}`
Â Â Â Â Â Â Â Â Â Â Â Â : `${legacyValidationResults.length} critical issues found`;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return await handleMigrationFailure(`Data validation failed: ${errorSummary}`, backupResult.backupKey);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Lenient validation passed - data is ready for migration');
Â Â Â Â 
Â Â Â Â // Step 5: Perform the actual migration using your existing function
Â Â Â Â console.log('ğŸ”„ Performing Schema 2.5 migration...');
Â Â Â Â console.log('ğŸ“¦ Calling performSchema25Migration()...');
Â Â Â Â 
Â Â Â Â const migrationResult = performSchema25Migration();
Â Â Â Â console.log('ğŸ”„ Migration process result:', migrationResult);
Â Â Â Â 
Â Â Â Â if (!migrationResult.success) {
Â Â Â Â Â Â Â Â console.error('âŒ Migration failed:', migrationResult.errors || migrationResult);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Troubleshooting: Check performSchema25Migration() function');
Â Â Â Â Â Â Â Â if (migrationResult.errors) {
Â Â Â Â Â Â Â Â Â Â Â Â migrationResult.errors.forEach((error, index) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error(` Â  Error ${index + 1}:`, error);
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return await handleMigrationFailure('Migration process failed', backupResult.backupKey);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Migration process completed successfully');
Â Â Â Â console.log('ğŸ“‹ Changes applied:', migrationResult.changes || 'No changes array provided');
Â Â Â Â 
Â Â Â Â // Step 6: âœ… Simple post-migration validation
Â Â Â Â console.log('âœ… Validating migrated data...');
Â Â Â Â const newSchemaData = localStorage.getItem("miniCycleData");
Â Â Â Â console.log('ğŸ“¦ New schema data exists:', !!newSchemaData);
Â Â Â Â console.log('ğŸ“ New schema data size:', newSchemaData ? newSchemaData.length : 0);
Â Â Â Â 
Â Â Â Â if (!newSchemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Post-migration validation failed: No Schema 2.5 data found');
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Troubleshooting: Migration did not create miniCycleData key');
Â Â Â Â Â Â Â Â console.error('ğŸ“Š Current localStorage keys after migration:', Object.keys(localStorage));
Â Â Â Â Â Â Â Â return await handleMigrationFailure('Migration validation failed - no new data found', backupResult.backupKey);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ” Parsing and validating new schema structure...');
Â Â Â Â Â Â Â Â const parsed = JSON.parse(newSchemaData);
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Parsed schema structure:', {
Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: parsed.schemaVersion,
Â Â Â Â Â Â Â Â Â Â Â Â hasMetadata: !!parsed.metadata,
Â Â Â Â Â Â Â Â Â Â Â Â hasData: !!parsed.data,
Â Â Â Â Â Â Â Â Â Â Â Â hasCycles: !!parsed.data?.cycles,
Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: parsed.data?.cycles ? Object.keys(parsed.data.cycles).length : 0,
Â Â Â Â Â Â Â Â Â Â Â Â hasAppState: !!parsed.appState,
Â Â Â Â Â Â Â Â Â Â Â Â activeCycleId: parsed.appState?.activeCycleId
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!parsed.schemaVersion || parsed.schemaVersion !== '2.5') {
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error(`Schema version missing or incorrect: ${parsed.schemaVersion}`);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (!parsed.data || !parsed.data.cycles) {
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Missing cycles data structure');
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Post-migration validation passed');
Â Â Â Â Â Â Â Â console.log('ğŸ¯ Final data structure validated successfully');
Â Â Â Â Â Â Â Â 
Â Â Â Â } catch (validationError) {
Â Â Â Â Â Â Â Â console.error('âŒ Post-migration validation failed:', validationError.message);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Troubleshooting: Schema structure is invalid');
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Raw data snippet:', newSchemaData.substring(0, 500) + '...');
Â Â Â Â Â Â Â Â return await handleMigrationFailure('Migration validation failed', backupResult.backupKey);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Step 7: Success!
Â Â Â Â console.log('âœ… Auto-migration completed successfully');
Â Â Â Â console.log('ğŸ‰ Migration summary:', {
Â Â Â Â Â Â Â Â backupKey: backupResult.backupKey,
Â Â Â Â Â Â Â Â migrationChanges: migrationResult.changes?.length || 0,
Â Â Â Â Â Â Â Â finalDataSize: newSchemaData.length,
Â Â Â Â Â Â Â Â dataFixesApplied: fixResult.fixedCount || 0,
Â Â Â Â Â Â Â Â timestamp: new Date().toISOString()
Â Â Â Â });

Â Â Â Â // âœ… Clean up old separate localStorage keys
console.log('ğŸ§¹ Cleaning up legacy localStorage keys...');
localStorage.removeItem("overdueTaskStates"); // Clean up old separate key
console.log('âœ… Removed old overdueTaskStates key');
Â Â Â Â 
Â Â Â Â // âœ… Enhanced success notification with fix details
Â Â Â Â const successMessage = fixResult.fixedCount > 0Â 
Â Â Â Â Â Â Â Â ? `âœ… Data updated successfully! Fixed ${fixResult.fixedCount} compatibility issues.`
Â Â Â Â Â Â Â Â : 'âœ… Data format updated successfully!';
Â Â Â Â showNotification(successMessage, 'success', 4000);
Â Â Â Â 
Â Â Â Â // Step 8: Store migration completion info
Â Â Â Â const legacyData = localStorage.getItem('miniCycleStorage') || '{}';
Â Â Â Â const migrationInfo = {
Â Â Â Â Â Â Â Â completed: Date.now(),
Â Â Â Â Â Â Â Â backupKey: backupResult.backupKey,
Â Â Â Â Â Â Â Â version: '2.5',
Â Â Â Â Â Â Â Â autoMigrated: true,
Â Â Â Â Â Â Â Â dataFixesApplied: fixResult.fixedCount || 0,
Â Â Â Â Â Â Â Â migrationSummary: {
Â Â Â Â Â Â Â Â Â Â Â Â originalDataSize: legacyData.length,
Â Â Â Â Â Â Â Â Â Â Â Â newDataSize: newSchemaData.length,
Â Â Â Â Â Â Â Â Â Â Â Â changesApplied: migrationResult.changes?.length || 0,
Â Â Â Â Â Â Â Â Â Â Â Â fixesApplied: fixResult.details || []
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â console.log('ğŸ’¾ Storing migration completion info:', migrationInfo);
Â Â Â Â localStorage.setItem('miniCycleMigrationInfo', JSON.stringify(migrationInfo));
Â Â Â Â 
Â Â Â Â return {
Â Â Â Â Â Â Â Â success: true,
Â Â Â Â Â Â Â Â message: 'Auto-migration completed successfully',
Â Â Â Â Â Â Â Â backupKey: backupResult.backupKey,
Â Â Â Â Â Â Â Â fixesApplied: fixResult.fixedCount || 0
Â Â Â Â };
Â Â Â Â 
Â } catch (error) {
Â Â Â Â Â Â Â Â if (forceMode) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Force migration failed, creating minimal schema');
Â Â Â Â Â Â Â Â Â Â Â Â return createMinimalSchema25();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return await handleMigrationFailure(`Unexpected error: ${error.message}`, null);
Â Â Â Â }
}

// âœ… NEW: Create minimal working Schema 2.5 if everything else fails
function createMinimalSchema25() {
Â Â Â Â console.log('ğŸ†˜ Creating minimal Schema 2.5 structure as last resort');
Â Â Â Â 
Â Â Â Â const minimalData = {
Â Â Â Â Â Â Â Â schemaVersion: "2.5",
Â Â Â Â Â Â Â Â metadata: {
Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â lastModified: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â migratedFrom: "force_migration",
Â Â Â Â Â Â Â Â Â Â Â Â migrationDate: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â totalCyclesCreated: 1,
Â Â Â Â Â Â Â Â Â Â Â Â totalTasksCompleted: 0,
Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: "2.5"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â settings: {
Â Â Â Â Â Â Â Â Â Â Â Â theme: null,
Â Â Â Â Â Â Â Â Â Â Â Â darkMode: false,
Â Â Â Â Â Â Â Â Â Â Â Â alwaysShowRecurring: false,
Â Â Â Â Â Â Â Â Â Â Â Â autoSave: true,
Â Â Â Â Â Â Â Â Â Â Â Â defaultRecurringSettings: { time: null },
Â Â Â Â Â Â Â Â Â Â Â Â unlockedThemes: [],
Â Â Â Â Â Â Â Â Â Â Â Â unlockedFeatures: [],
Â Â Â Â Â Â Â Â Â Â Â Â notificationPosition: { x: 0, y: 0 },
Â Â Â Â Â Â Â Â Â Â Â Â notificationPositionModified: false
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â data: {
Â Â Â Â Â Â Â Â Â Â Â Â cycles: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Default Cycle": {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: "default_cycle",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "Default Cycle",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tasks: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoReset: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â appState: {
Â Â Â Â Â Â Â Â Â Â Â Â activeCycleId: "Default Cycle"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â userProgress: {
Â Â Â Â Â Â Â Â Â Â Â Â rewardMilestones: []
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â customReminders: {
Â Â Â Â Â Â Â Â Â Â Â Â enabled: false,
Â Â Â Â Â Â Â Â Â Â Â Â indefinite: false,
Â Â Â Â Â Â Â Â Â Â Â Â dueDatesReminders: false,
Â Â Â Â Â Â Â Â Â Â Â Â repeatCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â frequencyValue: 30,
Â Â Â Â Â Â Â Â Â Â Â Â frequencyUnit: "minutes"
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(minimalData));
Â Â Â Â 
Â Â Â Â showNotification('âš ï¸ Created fresh miniCycle. Previous data may have been incompatible.', 'warning', 8000);
Â Â Â Â 
Â Â Â Â return {
Â Â Â Â Â Â Â Â success: true,
Â Â Â Â Â Â Â Â forced: true,
Â Â Â Â Â Â Â Â minimal: true,
Â Â Â Â Â Â Â Â message: 'Created minimal Schema 2.5 structure'
Â Â Â Â };
}

// âœ… ADD: Lenient validation function for auto-migration
function validateAllMiniCycleTasksLenient() {
Â Â const storage = JSON.parse(localStorage.getItem("miniCycleStorage")) || {};
Â Â const results = [];

Â Â for (const [cycleName, cycleData] of Object.entries(storage)) {
Â Â Â Â if (!Array.isArray(cycleData.tasks)) continue;

Â Â Â Â cycleData.tasks.forEach(task => {
Â Â Â Â Â Â const criticalErrors = [];
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Only check for critical errors that would break migration
Â Â Â Â Â Â if (!task.text && !task.taskText) {
Â Â Â Â Â Â Â Â criticalErrors.push("Task has no text content");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â if (!task.id) {
Â Â Â Â Â Â Â Â criticalErrors.push("Task missing unique ID");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Check for completely malformed recurring settings (not just missing properties)
Â Â Â Â Â Â if (task.recurring && task.recurringSettings && typeof task.recurringSettings !== 'object') {
Â Â Â Â Â Â Â Â criticalErrors.push("Recurring settings is not a valid object");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Only report tasks with critical issues
Â Â Â Â Â Â if (criticalErrors.length > 0) {
Â Â Â Â Â Â Â Â results.push({
Â Â Â Â Â Â Â Â Â Â cycle: cycleName,
Â Â Â Â Â Â Â Â Â Â taskText: task.text || task.taskText || "(no text)",
Â Â Â Â Â Â Â Â Â Â id: task.id || "(no id)",
Â Â Â Â Â Â Â Â Â Â errors: criticalErrors
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â }
Â Â Â Â });
Â Â }

Â Â return results;
}


// âœ… Handle Migration Failure with Legacy Data Fallback
async function handleMigrationFailure(reason, backupKey) {
try {
console.log('ğŸ”„ Handling migration failure, attempting to maintain legacy data accessâ€¦');
console.log('âŒ Failure reason:', reason);
console.log('ğŸ“¦ Backup key available:', backupKey);

Â Â Â Â // Step 1: Try to restore from backup if available
Â Â Â Â if (backupKey) {
Â Â Â Â Â Â Â Â console.log('ğŸ“¥ Attempting to restore from backup:', backupKey);
Â Â Â Â Â Â Â Â console.log('ğŸ” Checking if backup exists in localStorage...');
Â Â Â Â Â Â Â Â const backupExists = !!localStorage.getItem(backupKey);
Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Backup exists:', backupExists);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â await restoreFromAutomaticBackup(backupKey);
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Successfully restored from backup');
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Post-restore localStorage keys:', Object.keys(localStorage));
Â Â Â Â Â Â Â Â } catch (restoreError) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Failed to restore from backup:', restoreError);
Â Â Â Â Â Â Â Â Â Â Â Â console.error('ğŸ”§ Restore error details:', restoreError.message);
Â Â Â Â Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Continuing with fallback strategy...');
Â Â Â Â Â Â Â Â Â Â Â Â // Continue with fallback - don't fail here
Â Â Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('âš ï¸ No backup key provided, skipping restore attempt');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Step 2: Ensure legacy data is accessible
Â Â Â Â console.log('ğŸ” Checking legacy data accessibility...');
Â Â Â Â const legacyDataExists = ensureLegacyDataAccess();
Â Â Â Â console.log('ğŸ“¦ Legacy data accessible:', legacyDataExists);
Â Â Â Â 
Â Â Â Â if (legacyDataExists) {
Â Â Â Â Â Â Â Â console.log('âœ… Legacy data found and accessible');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Step 3: Set session flag to use legacy mode until reload
Â Â Â Â Â Â Â Â console.log('ğŸš© Setting legacy fallback mode flags...');
Â Â Â Â Â Â Â Â sessionStorage.setItem('miniCycleLegacyModeActive', 'true');
Â Â Â Â Â Â Â Â sessionStorage.setItem('miniCycleMigrationFailureReason', reason);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Session storage flags set:', {
Â Â Â Â Â Â Â Â Â Â Â Â legacyMode: sessionStorage.getItem('miniCycleLegacyModeActive'),
Â Â Â Â Â Â Â Â Â Â Â Â failureReason: sessionStorage.getItem('miniCycleMigrationFailureReason')
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Step 4: Show user-friendly notification
Â Â Â Â Â Â Â Â showNotification(
Â Â Â Â Â Â Â Â Â Â Â Â 'âš ï¸ Unable to update data format. Using existing data until next app reload. Your data is safe!',Â 
Â Â Â Â Â Â Â Â Â Â Â Â 'warning',Â 
Â Â Â Â Â Â Â Â Â Â Â Â 8000
Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Fallback to legacy data successful');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â success: false,
Â Â Â Â Â Â Â Â Â Â Â Â fallbackActive: true,
Â Â Â Â Â Â Â Â Â Â Â Â message: 'Migration failed but legacy data access maintained',
Â Â Â Â Â Â Â Â Â Â Â Â reason: reason
Â Â Â Â Â Â Â Â };
Â Â Â Â } else {
Â Â Â Â Â Â Â Â // Step 5: Last resort - critical error
Â Â Â Â Â Â Â Â console.error('âŒ No legacy data available for fallback');
Â Â Â Â Â Â Â Â console.error('ğŸš¨ CRITICAL: Complete data loss scenario');
Â Â Â Â Â Â Â Â console.error('ğŸ“Š Final localStorage state:', Object.keys(localStorage));
Â Â Â Â Â Â Â Â console.error('ğŸ’¾ Available data sources:', {
Â Â Â Â Â Â Â Â Â Â Â Â miniCycleStorage: !!localStorage.getItem('miniCycleStorage'),
Â Â Â Â Â Â Â Â Â Â Â Â miniCycleData: !!localStorage.getItem('miniCycleData'),
Â Â Â Â Â Â Â Â Â Â Â Â lastUsedMiniCycle: !!localStorage.getItem('lastUsedMiniCycle'),
Â Â Â Â Â Â Â Â Â Â Â Â anyBackups: Object.keys(localStorage).filter(key => key.includes('backup')),
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â showCriticalError('Unable to access your data. Please contact support or try refreshing the page.');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â success: false,
Â Â Â Â Â Â Â Â Â Â Â Â fallbackActive: false,
Â Â Â Â Â Â Â Â Â Â Â Â message: 'Migration failed and no legacy data available',
Â Â Â Â Â Â Â Â Â Â Â Â reason: reason
Â Â Â Â Â Â Â Â };
Â Â Â Â }
Â Â Â Â 
} catch (error) {
Â Â Â Â console.error('âŒ Failed to handle migration failure:', error);
Â Â Â Â console.error('ğŸ”§ Handler error stack:', error.stack);
Â Â Â Â console.error('ğŸš¨ CRITICAL: Migration failure handler itself failed');
Â Â Â Â showCriticalError('Critical error occurred. Please refresh the page.');
Â Â Â Â 
Â Â Â Â return {
Â Â Â Â Â Â Â Â success: false,
Â Â Â Â Â Â Â Â fallbackActive: false,
Â Â Â Â Â Â Â Â message: 'Failed to handle migration failure',
Â Â Â Â Â Â Â Â reason: `${reason} + ${error.message}`
Â Â Â Â };
}
}

// âœ… Ensure Legacy Data is Accessible
function ensureLegacyDataAccess() {
try {
console.log('ğŸ” Checking legacy data access...');

// Check if legacy data exists
const legacyStorage = localStorage.getItem('miniCycleStorage');
console.log('ğŸ“¦ Legacy storage exists:', !!legacyStorage);
console.log('ğŸ“ Legacy storage size:', legacyStorage ? legacyStorage.length : 0);

Â Â Â Â if (!legacyStorage) {
Â Â Â Â Â Â Â Â console.error('âŒ No legacy data found in localStorage');
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Available localStorage keys:', Object.keys(localStorage));
Â Â Â Â Â Â Â Â return false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Try to parse the legacy data to ensure it's valid
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ” Attempting to parse legacy data...');
Â Â Â Â Â Â Â Â const parsedData = JSON.parse(legacyStorage);
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Parsed legacy data structure:', {
Â Â Â Â Â Â Â Â Â Â Â Â type: typeof parsedData,
Â Â Â Â Â Â Â Â Â Â Â Â isObject: typeof parsedData === 'object',
Â Â Â Â Â Â Â Â Â Â Â Â isNull: parsedData === null,
Â Â Â Â Â Â Â Â Â Â Â Â keys: typeof parsedData === 'object' && parsedData !== null ? Object.keys(parsedData) : 'N/A',
Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: typeof parsedData === 'object' && parsedData !== null ? Object.keys(parsedData).length : 0
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (typeof parsedData === 'object' && parsedData !== null) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Legacy data is accessible and valid');
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Additional validation
Â Â Â Â Â Â Â Â Â Â Â Â const cycleKeys = Object.keys(parsedData);
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“‹ Available legacy cycles:', cycleKeys);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (cycleKeys.length > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const firstCycle = parsedData[cycleKeys[0]];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š First cycle structure:', {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hasTasks: !!firstCycle.tasks,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskCount: Array.isArray(firstCycle.tasks) ? firstCycle.tasks.length : 'Not array',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hasTitle: !!firstCycle.title,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hasAutoReset: 'autoReset' in firstCycle
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â return true;
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Legacy data is not a valid object');
Â Â Â Â Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Actual data type:', typeof parsedData);
Â Â Â Â Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Data content preview:', JSON.stringify(parsedData).substring(0, 200));
Â Â Â Â Â Â Â Â Â Â Â Â return false;
Â Â Â Â Â Â Â Â }
Â Â Â Â } catch (parseError) {
Â Â Â Â Â Â Â Â console.error('âŒ Legacy data is corrupted:', parseError);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Parse error details:', parseError.message);
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Raw data preview:', legacyStorage.substring(0, 200) + '...');
Â Â Â Â Â Â Â Â return false;
Â Â Â Â }
Â Â Â Â 
} catch (error) {
Â Â Â Â console.error('âŒ Error checking legacy data access:', error);
Â Â Â Â console.error('ğŸ”§ Access check error:', error.message);
Â Â Â Â return false;
}
}

// âœ… Check if App is Running in Legacy Fallback Mode
function isLegacyFallbackModeActive() {
const isActive = sessionStorage.getItem('miniCycleLegacyModeActive') === 'true';
console.log('ğŸš© Legacy fallback mode check:', {
Â Â Â Â isActive: isActive,
Â Â Â Â sessionFlag: sessionStorage.getItem('miniCycleLegacyModeActive'),
Â Â Â Â failureReason: sessionStorage.getItem('miniCycleMigrationFailureReason')
});
return isActive;
}
// âœ… Fixed createAutomaticMigrationBackup function
async function createAutomaticMigrationBackup() {
try {
console.log('ğŸ“¥ Starting automatic backup creation...');
const timestamp = Date.now();
const backupKey = `auto_migration_backup_${timestamp}`;
console.log('ğŸ·ï¸ Generated backup key:', backupKey);

Â Â Â Â // Check if we have data to backup
Â Â Â Â console.log('ğŸ” Checking for legacy data to backup...');
Â Â Â Â const legacyData = localStorage.getItem('miniCycleStorage');
Â Â Â Â console.log('ğŸ“¦ Legacy data found:', !!legacyData);
Â Â Â Â console.log('ğŸ“ Legacy data size:', legacyData ? legacyData.length : 0);
Â Â Â Â 
Â Â Â Â if (!legacyData) {
Â Â Â Â Â Â Â Â console.error('âŒ No legacy data found to backup');
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Available localStorage keys:', Object.keys(localStorage));
Â Â Â Â Â Â Â Â throw new Error('No legacy data found to backup');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Gather all data to backup - FIXED STORAGE KEYS
Â Â Â Â console.log('ğŸ“‹ Gathering additional data for backup...');
Â Â Â Â const remindersData = localStorage.getItem('miniCycleReminders');
Â Â Â Â const lastUsed = localStorage.getItem('lastUsedMiniCycle');
Â Â Â Â const milestones = localStorage.getItem('milestoneUnlocks');
Â Â Â Â console.log('ğŸ”” Reminders data:', !!remindersData);
Â Â Â Â console.log('ğŸ“Œ Last used cycle:', !!lastUsed);
Â Â Â Â console.log('ğŸ† Milestones:', !!milestones);
Â Â Â Â 
Â Â Â Â const settingsData = {
Â Â Â Â Â Â Â Â threeDots: localStorage.getItem('miniCycleThreeDots'),
Â Â Â Â Â Â Â Â darkMode: localStorage.getItem('darkModeEnabled'), // âœ… FIXED
Â Â Â Â Â Â Â Â moveArrows: localStorage.getItem('miniCycleMoveArrows'),
Â Â Â Â Â Â Â Â alwaysShowRecurring: localStorage.getItem('miniCycleAlwaysShowRecurring'),
Â Â Â Â Â Â Â Â defaultRecurring: localStorage.getItem('miniCycleDefaultRecurring'),
Â Â Â Â Â Â Â Â theme: localStorage.getItem('currentTheme'), // âœ… FIXED
Â Â Â Â Â Â Â Â onboarding: localStorage.getItem('miniCycleOnboarding'),
Â Â Â Â Â Â Â Â notificationPosition: localStorage.getItem('miniCycleNotificationPosition')
Â Â Â Â };
Â Â Â Â 
Â Â Â Â console.log('âš™ï¸ Settings data collected:', Object.keys(settingsData).filter(key => settingsData[key] !== null));
Â Â Â Â 
Â Â Â Â const backupData = {
Â Â Â Â Â Â Â Â version: 'legacy',
Â Â Â Â Â Â Â Â created: timestamp,
Â Â Â Â Â Â Â Â type: 'auto_migration_backup',
Â Â Â Â Â Â Â Â data: {
Â Â Â Â Â Â Â Â Â Â Â Â miniCycleStorage: legacyData,
Â Â Â Â Â Â Â Â Â Â Â Â lastUsedMiniCycle: lastUsed, // âœ… ADDED
Â Â Â Â Â Â Â Â Â Â Â Â miniCycleReminders: remindersData,
Â Â Â Â Â Â Â Â Â Â Â Â milestoneUnlocks: milestones, // âœ… ADDED
Â Â Â Â Â Â Â Â Â Â Â Â settings: settingsData
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â metadata: {
Â Â Â Â Â Â Â Â Â Â Â Â userAgent: navigator.userAgent,
Â Â Â Â Â Â Â Â Â Â Â Â url: window.location.href,
Â Â Â Â Â Â Â Â Â Â Â Â migrationReason: 'Automatic migration to Schema 2.5'
Â Â Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â 
Â Â Â Â const backupSize = JSON.stringify(backupData).length;
Â Â Â Â console.log('ğŸ“Š Backup data prepared:', {
Â Â Â Â Â Â Â Â totalSize: backupSize,
Â Â Â Â Â Â Â Â totalSizeKB: Math.round(backupSize / 1024),
Â Â Â Â Â Â Â Â legacyDataSize: legacyData.length,
Â Â Â Â Â Â Â Â remindersSize: remindersData ? remindersData.length : 0,
Â Â Â Â Â Â Â Â lastUsedSize: lastUsed ? lastUsed.length : 0,
Â Â Â Â Â Â Â Â milestonesSize: milestones ? milestones.length : 0,
Â Â Â Â Â Â Â Â settingsCount: Object.keys(settingsData).filter(key => settingsData[key] !== null).length
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Rest of the function remains the same...
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Attempting to store backup in localStorage...');
Â Â Â Â Â Â Â Â localStorage.setItem(backupKey, JSON.stringify(backupData));
Â Â Â Â Â Â Â Â console.log('âœ… Backup stored successfully');
Â Â Â Â } catch (storageError) {
Â Â Â Â Â Â Â Â console.error('âŒ Storage error during backup:', storageError);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Storage error details:', storageError.message);
Â Â Â Â Â Â Â Â console.error('ğŸ“Š Storage usage info:', {
Â Â Â Â Â Â Â Â Â Â Â Â backupSize: backupSize,
Â Â Â Â Â Â Â Â Â Â Â Â estimatedTotalStorage: JSON.stringify(localStorage).length,
Â Â Â Â Â Â Â Â Â Â Â Â availableKeys: Object.keys(localStorage).length
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â throw new Error('Insufficient storage space for backup');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Add to backup index for management
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ“‹ Updating backup index...');
Â Â Â Â Â Â Â Â const backupIndex = JSON.parse(localStorage.getItem('miniCycleBackupIndex') || '[]');
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Current backup index size:', backupIndex.length);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â backupIndex.push({
Â Â Â Â Â Â Â Â Â Â Â Â key: backupKey,
Â Â Â Â Â Â Â Â Â Â Â Â created: timestamp,
Â Â Â Â Â Â Â Â Â Â Â Â type: 'auto_migration',
Â Â Â Â Â Â Â Â Â Â Â Â size: JSON.stringify(backupData).length
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Keep only last 5 automatic backups to prevent storage bloat
Â Â Â Â Â Â Â Â const autoBackups = backupIndex.filter(b => b.type === 'auto_migration');
Â Â Â Â Â Â Â Â console.log('ğŸ—‚ï¸ Auto backup count:', autoBackups.length);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (autoBackups.length > 5) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Cleaning up old backups...');
Â Â Â Â Â Â Â Â Â Â Â Â const oldestAutoBackup = autoBackups.sort((a, b) => a.created - b.created)[0];
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Removing oldest backup:', oldestAutoBackup.key);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.removeItem(oldestAutoBackup.key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const index = backupIndex.findIndex(b => b.key === oldestAutoBackup.key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â backupIndex.splice(index, 1);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Old backup cleaned up successfully');
Â Â Â Â Â Â Â Â Â Â Â Â } catch (cleanupError) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Failed to cleanup old backup:', cleanupError);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('ğŸ”§ Cleanup error details:', cleanupError.message);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Continue anyway - this isn't critical
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â localStorage.setItem('miniCycleBackupIndex', JSON.stringify(backupIndex));
Â Â Â Â Â Â Â Â console.log('âœ… Backup index updated successfully');
Â Â Â Â Â Â Â Â 
Â Â Â Â } catch (indexError) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Failed to update backup index:', indexError);
Â Â Â Â Â Â Â Â console.warn('ğŸ”§ Index error details:', indexError.message);
Â Â Â Â Â Â Â Â // Continue anyway - backup was created successfully
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Automatic backup created successfully:', backupKey);
Â Â Â Â return {
Â Â Â Â Â Â Â Â success: true,
Â Â Â Â Â Â Â Â backupKey: backupKey,
Â Â Â Â Â Â Â Â size: JSON.stringify(backupData).length
Â Â Â Â };
Â Â Â Â 
} catch (error) {
Â Â Â Â console.error('âŒ Failed to create automatic backup:', error);
Â Â Â Â console.error('ğŸ”§ Backup creation error:', error.message);
Â Â Â Â console.error('ğŸ“Š System state at backup failure:', {
Â Â Â Â Â Â Â Â localStorage: Object.keys(localStorage),
Â Â Â Â Â Â Â Â storageEstimate: JSON.stringify(localStorage).length
Â Â Â Â });
Â Â Â Â return {
Â Â Â Â Â Â Â Â success: false,
Â Â Â Â Â Â Â Â message: error.message
Â Â Â Â };
}
}

// âœ… Also update the restore function
async function restoreFromAutomaticBackup(backupKey) {
try {
console.log('ğŸ”„ Restoring from automatic backup:', backupKey);

Â Â Â Â console.log('ğŸ” Checking if backup exists...');
Â Â Â Â const backupData = localStorage.getItem(backupKey);
Â Â Â Â console.log('ğŸ“¦ Backup data found:', !!backupData);
Â Â Â Â console.log('ğŸ“ Backup data size:', backupData ? backupData.length : 0);
Â Â Â Â 
Â Â Â Â if (!backupData) {
Â Â Â Â Â Â Â Â console.error('âŒ Backup not found in localStorage');
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Available backup keys:', Object.keys(localStorage).filter(key => key.includes('backup')));
Â Â Â Â Â Â Â Â throw new Error('Backup not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â let backup;
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ” Parsing backup data...');
Â Â Â Â Â Â Â Â backup = JSON.parse(backupData);
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Backup structure:', {
Â Â Â Â Â Â Â Â Â Â Â Â version: backup.version,
Â Â Â Â Â Â Â Â Â Â Â Â type: backup.type,
Â Â Â Â Â Â Â Â Â Â Â Â created: new Date(backup.created).toISOString(),
Â Â Â Â Â Â Â Â Â Â Â Â hasData: !!backup.data,
Â Â Â Â Â Â Â Â Â Â Â Â hasMetadata: !!backup.metadata
Â Â Â Â Â Â Â Â });
Â Â Â Â } catch (parseError) {
Â Â Â Â Â Â Â Â console.error('âŒ Backup data is corrupted:', parseError);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Parse error details:', parseError.message);
Â Â Â Â Â Â Â Â console.error('ğŸ“‹ Raw backup preview:', backupData.substring(0, 200) + '...');
Â Â Â Â Â Â Â Â throw new Error('Backup data is corrupted');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Restore legacy data
Â Â Â Â if (backup.data.miniCycleStorage) {
Â Â Â Â Â Â Â Â console.log('ğŸ“¦ Restoring miniCycleStorage...');
Â Â Â Â Â Â Â Â localStorage.setItem('miniCycleStorage', backup.data.miniCycleStorage);
Â Â Â Â Â Â Â Â console.log('âœ… miniCycleStorage restored');
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No miniCycleStorage found in backup');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… RESTORE LAST USED CYCLE
Â Â Â Â if (backup.data.lastUsedMiniCycle) {
Â Â Â Â Â Â Â Â console.log('ğŸ“Œ Restoring lastUsedMiniCycle...');
Â Â Â Â Â Â Â Â localStorage.setItem('lastUsedMiniCycle', backup.data.lastUsedMiniCycle);
Â Â Â Â Â Â Â Â console.log('âœ… lastUsedMiniCycle restored');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (backup.data.miniCycleReminders) {
Â Â Â Â Â Â Â Â console.log('ğŸ”” Restoring miniCycleReminders...');
Â Â Â Â Â Â Â Â localStorage.setItem('miniCycleReminders', backup.data.miniCycleReminders);
Â Â Â Â Â Â Â Â console.log('âœ… miniCycleReminders restored');
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No miniCycleReminders found in backup');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… RESTORE MILESTONES
Â Â Â Â if (backup.data.milestoneUnlocks) {
Â Â Â Â Â Â Â Â console.log('ğŸ† Restoring milestoneUnlocks...');
Â Â Â Â Â Â Â Â localStorage.setItem('milestoneUnlocks', backup.data.milestoneUnlocks);
Â Â Â Â Â Â Â Â console.log('âœ… milestoneUnlocks restored');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Restore settings - FIXED KEYS
Â Â Â Â if (backup.data.settings) {
Â Â Â Â Â Â Â Â console.log('âš™ï¸ Restoring settings...');
Â Â Â Â Â Â Â Â const settings = backup.data.settings;
Â Â Â Â Â Â Â Â const settingsRestored = [];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Object.keys(settings).forEach(key => {
Â Â Â Â Â Â Â Â Â Â Â Â if (settings[key] !== null && settings[key] !== undefined) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… FIXED: Use correct storage keys
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let storageKey;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â switch(key) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â case 'darkMode':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â storageKey = 'darkModeEnabled';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â case 'theme':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â storageKey = 'currentTheme';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â default:
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â storageKey = `miniCycle${key.charAt(0).toUpperCase() + key.slice(1)}`;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem(storageKey, settings[key]);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â settingsRestored.push(key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(` Â  âœ… Restored setting: ${key} -> ${storageKey}`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } catch (settingError) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Failed to restore setting ${key}:`, settingError);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Continue with other settings
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Settings restoration complete:', settingsRestored);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No settings found in backup');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Remove any Schema 2.5 data that might have been created
Â Â Â Â try {
Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Cleaning up any Schema 2.5 data...');
Â Â Â Â Â Â Â Â const schema25Existed = !!localStorage.getItem('miniCycleData');
Â Â Â Â Â Â Â Â localStorage.removeItem('miniCycleData');
Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Schema 2.5 data cleanup:', schema25Existed ? 'removed' : 'none found');
Â Â Â Â } catch (removeError) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Failed to remove Schema 2.5 data:', removeError);
Â Â Â Â Â Â Â Â // Continue anyway
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Data restored from automatic backup successfully');
Â Â Â Â console.log('ğŸ“Š Post-restore localStorage keys:', Object.keys(localStorage));
Â Â Â Â 
Â Â Â Â return { success: true };
Â Â Â Â 
} catch (error) {
Â Â Â Â console.error('âŒ Failed to restore from automatic backup:', error);
Â Â Â Â console.error('ğŸ”§ Restore error stack:', error.stack);
Â Â Â Â console.error('ğŸ“Š System state at restore failure:', {
Â Â Â Â Â Â Â Â backupKey: backupKey,
Â Â Â Â Â Â Â Â backupExists: !!localStorage.getItem(backupKey),
Â Â Â Â Â Â Â Â currentKeys: Object.keys(localStorage)
Â Â Â Â });
Â Â Â Â throw error;
}
}

// âœ… Initialize App with Auto-Migration and Fallback Support
function initializeAppWithAutoMigration(options = {}) {
console.log('ğŸš€ Initializing app with auto-migration checkâ€¦');
console.log('ğŸ“Š Initial system state:', {
Â Â Â Â localStorage: Object.keys(localStorage),
Â Â Â Â sessionStorage: Object.keys(sessionStorage),
Â Â Â Â userAgent: navigator.userAgent,
Â Â Â Â timestamp: new Date().toISOString()
});

// Check if we're already in legacy fallback mode
console.log('ğŸš© Checking for existing legacy fallback mode...');
if (isLegacyFallbackModeActive()) {
Â Â Â Â console.log('âš ï¸ App is running in legacy fallback mode');
Â Â Â Â const failureReason = sessionStorage.getItem('miniCycleMigrationFailureReason') || 'Unknown reason';
Â Â Â Â console.log('âŒ Previous failure reason:', failureReason);
Â Â Â Â 
Â Â Â Â showNotification(
Â Â Â Â Â Â Â Â `âš ï¸ Running in compatibility mode due to: ${failureReason}. Restart app to retry migration.`,Â 
Â Â Â Â Â Â Â Â 'warning',Â 
Â Â Â Â Â Â Â Â 5000
Â Â Â Â );
Â Â Â Â 
Â Â Â Â // Load app with legacy data
Â Â Â Â console.log('ğŸ“± Loading app in legacy fallback mode...');
Â Â Â Â initialSetup();
Â Â Â Â return;
}

console.log('âœ… No existing fallback mode detected');

// âœ… FIXED: Use your existing function correctly
console.log('ğŸ” Running migration check...');
const migrationCheck = checkMigrationNeeded();
console.log('ğŸ“‹ Migration check complete:', migrationCheck);

if (migrationCheck.needed) { // âœ… Use .needed property
Â Â Â Â console.log('ğŸ“‹ Migration needed - starting auto-migration process...');
Â Â Â Â console.log('ğŸ”„ Auto-migration will be performed asynchronously...');
Â Â Â Â 
Â Â Â Â // âœ… NEW: Pass through any options (like forceMode)
Â Â Â Â performAutoMigration(options).then(result => {
Â Â Â Â Â Â Â Â console.log('ğŸ Auto-migration promise resolved:', result);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (result.success) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Auto-migration successful, loading app...');
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Migration success details:', {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â backupKey: result.backupKey,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: result.message,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â forced: result.forced || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minimal: result.minimal || false
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â initialSetup();
Â Â Â Â Â Â Â Â } else if (result.fallbackActive) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âš ï¸ Migration failed but fallback active, loading app with legacy data...');
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Fallback details:', {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â reason: result.reason,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: result.message
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â initialSetup();
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Auto-migration failed completely:', result.message);
Â Â Â Â Â Â Â Â Â Â Â Â console.error('ğŸš¨ Critical failure details:', result);
Â Â Â Â Â Â Â Â Â Â Â Â // Critical error is already shown by handleMigrationFailure
Â Â Â Â Â Â Â Â }
Â Â Â Â }).catch(error => {
Â Â Â Â Â Â Â Â console.error('âŒ Unexpected error during auto-migration:', error);
Â Â Â Â Â Â Â Â console.error('ğŸ”§ Promise rejection stack:', error.stack);
Â Â Â Â Â Â Â Â console.error('ğŸ“Š System state at promise failure:', {
Â Â Â Â Â Â Â Â Â Â Â Â localStorage: Object.keys(localStorage),
Â Â Â Â Â Â Â Â Â Â Â Â sessionStorage: Object.keys(sessionStorage)
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â showCriticalError('An unexpected error occurred. Please refresh the page.');
Â Â Â Â });
} else {
Â Â Â Â console.log('âœ… No migration needed, loading app normally...');
Â Â Â Â console.log('ğŸ“¦ Current schema status:', migrationCheck.currentVersion);
Â Â Â Â initialSetup();
}
}

// âœ… NEW: Helper function to trigger force migration
function forceAppMigration() {
Â Â Â Â console.log('ğŸš¨ Forcing app migration...');
Â Â Â Â return initializeAppWithAutoMigration({Â 
Â Â Â Â Â Â Â Â forceMode: true,Â 
Â Â Â Â Â Â Â Â skipValidation: trueÂ 
Â Â Â Â });
}

// âœ… Show Critical Error (Enhanced for better UX)
function showCriticalError(message) {
console.log('ğŸš¨ Showing critical error to user:', message);
console.log('ğŸ“Š System state at critical error:', {
Â Â Â Â localStorage: Object.keys(localStorage),
Â Â Â Â sessionStorage: Object.keys(sessionStorage),
Â Â Â Â url: window.location.href,
Â Â Â Â timestamp: new Date().toISOString()
});

const errorContainer = document.createElement('div');
errorContainer.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ff4444; color: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10000; max-width: 400px; text-align: center; font-family: Inter, sans-serif; line-height: 1.5;`;

errorContainer.innerHTML = `
Â Â Â Â <h3 style="margin-top: 0;">âš ï¸ App Error</h3>
Â Â Â Â <p style="margin-bottom: 20px;">${message}</p>
Â Â Â Â <div style="display: flex; gap: 10px; justify-content: center;">
Â Â Â Â Â Â Â Â <button onclick="location.reload()" style="
Â Â Â Â Â Â Â Â Â Â Â Â background: white;
Â Â Â Â Â Â Â Â Â Â Â Â color: #ff4444;
Â Â Â Â Â Â Â Â Â Â Â Â border: none;
Â Â Â Â Â Â Â Â Â Â Â Â padding: 10px 20px;
Â Â Â Â Â Â Â Â Â Â Â Â border-radius: 5px;
Â Â Â Â Â Â Â Â Â Â Â Â cursor: pointer;
Â Â Â Â Â Â Â Â Â Â Â Â font-weight: bold;
Â Â Â Â Â Â Â Â ">Reload App</button>
Â Â Â Â Â Â Â Â <button onclick="this.parentElement.parentElement.remove()" style="
Â Â Â Â Â Â Â Â Â Â Â Â background: transparent;
Â Â Â Â Â Â Â Â Â Â Â Â color: white;
Â Â Â Â Â Â Â Â Â Â Â Â border: 1px solid white;
Â Â Â Â Â Â Â Â Â Â Â Â padding: 10px 20px;
Â Â Â Â Â Â Â Â Â Â Â Â border-radius: 5px;
Â Â Â Â Â Â Â Â Â Â Â Â cursor: pointer;
Â Â Â Â Â Â Â Â Â Â Â Â font-weight: bold;
Â Â Â Â Â Â Â Â ">Dismiss</button>
Â Â Â Â </div>
`;

document.body.appendChild(errorContainer);

console.log('ğŸ“¢ Critical error dialog displayed to user');

// Auto-remove after 15 seconds
setTimeout(() => {
Â Â Â Â if (errorContainer.parentElement) {
Â Â Â Â Â Â Â Â errorContainer.remove();
Â Â Â Â Â Â Â Â console.log('â° Critical error dialog auto-removed after timeout');
Â Â Â Â }
}, 15000);
}

// Add this function before your migration functions
function fixTaskValidationIssues() {
Â Â Â Â console.log('ğŸ”§ Fixing task validation issues...');
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â const legacyData = localStorage.getItem('miniCycleStorage');
Â Â Â Â Â Â Â Â if (!legacyData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âš ï¸ No legacy data found');
Â Â Â Â Â Â Â Â Â Â Â Â return { success: false, message: 'No legacy data found' };
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const cycles = JSON.parse(legacyData);
Â Â Â Â Â Â Â Â let fixedTasks = 0;
Â Â Â Â Â Â Â Â let fixedDetails = [];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Object.keys(cycles).forEach(cycleName => {
Â Â Â Â Â Â Â Â Â Â Â Â const cycle = cycles[cycleName];
Â Â Â Â Â Â Â Â Â Â Â Â if (!cycle.tasks || !Array.isArray(cycle.tasks)) return;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â cycle.tasks.forEach(task => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskId = task.id || 'unknown';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ” Checking task: "${task.taskText}" (${taskId})`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… NEW: Handle tasks that SHOULD have recurring but don't
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!task.recurring && (task.taskText || task.id)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Skip tasks that are clearly not meant to be recurring
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // (This is the safest approach - only fix existing recurring objects)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Handle tasks with incomplete recurring objects
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task.recurring && typeof task.recurring === 'object') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Set sensible defaults based on existing data or fallbacks
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task.recurring.recurCount === undefined) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.recurCount = 1;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added recurCount`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added recurCount = 1');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task.recurring.recurIndefinitely === undefined) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.recurIndefinitely = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added recurIndefinitely`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added recurIndefinitely = true');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task.recurring.useSpecificTime === undefined) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.useSpecificTime = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added useSpecificTime`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added useSpecificTime = false');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Set frequency if missing
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!task.recurring.frequency) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.frequency = 'daily'; // Most common default
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added default frequency`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added frequency = daily');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Fix missing frequency blocks based on actual frequency
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const freq = task.recurring.frequency;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'hourly' && !task.recurring.hourly) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.hourly = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificMinute: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added hourly block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added hourly block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'daily' && !task.recurring.daily) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.daily = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hour: 12,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â meridiem: 'PM',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â militaryTime: false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added daily block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added daily block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'weekly' && !task.recurring.weekly) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.weekly = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificDays: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â days: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hour: 12,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â meridiem: 'PM',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â militaryTime: false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added weekly block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added weekly block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'biweekly' && !task.recurring.biweekly) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.biweekly = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificDays: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â days: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hour: 12,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â meridiem: 'PM',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â militaryTime: false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added biweekly block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added biweekly block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'monthly' && !task.recurring.monthly) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.monthly = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificDays: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â days: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hour: 12,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â meridiem: 'PM',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â militaryTime: false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added monthly block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added monthly block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (freq === 'yearly' && !task.recurring.yearly) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring.yearly = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificMonths: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â months: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificDays: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â days: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hour: 12,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â minute: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â meridiem: 'PM',
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â militaryTime: false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedTasks++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.push(`${task.taskText}: Added yearly block`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('Â  âœ… Fixed: Added yearly block');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (fixedTasks > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem('miniCycleStorage', JSON.stringify(cycles));
Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… Fixed ${fixedTasks} task validation issues:`);
Â Â Â Â Â Â Â Â Â Â Â Â fixedDetails.forEach(detail => console.log(` Â  - ${detail}`));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â return {Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â success: true,Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedCount: fixedTasks,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â details: fixedDetails,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: `Fixed ${fixedTasks} validation issues`
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… No fixes needed');
Â Â Â Â Â Â Â Â Â Â Â Â return {Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â success: true,Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fixedCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: 'No validation issues found'Â 
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.error('âŒ Error fixing task validation:', error);
Â Â Â Â Â Â Â Â return {Â 
Â Â Â Â Â Â Â Â Â Â Â Â success: false,Â 
Â Â Â Â Â Â Â Â Â Â Â Â error: error.message,
Â Â Â Â Â Â Â Â Â Â Â Â message: `Error during fix: ${error.message}`
Â Â Â Â Â Â Â Â };
Â Â Â Â }
}











/**
Â * Remindoverduetasks function.
Â *
Â * @returns {void}
Â */

function remindOverdueTasks() {
Â Â Â Â console.log('âš ï¸ Checking for overdue tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â let autoReset = toggleAutoReset.checked;
Â Â Â Â if (autoReset) {
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto-reset enabled, skipping overdue reminders');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for remindOverdueTasks');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { reminders } = schemaData;
Â Â Â Â const remindersSettings = reminders || {};
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Reminder settings:', {
Â Â Â Â Â Â Â Â enabled: remindersSettings.enabled,
Â Â Â Â Â Â Â Â dueDatesReminders: remindersSettings.dueDatesReminders
Â Â Â Â });
Â Â Â Â 
Â Â Â Â const dueDatesRemindersEnabled = remindersSettings.dueDatesReminders;

Â Â Â Â // âœ… Only proceed if due date notifications are enabled
Â Â Â Â if (!dueDatesRemindersEnabled) {
Â Â Â Â Â Â Â Â console.log("âŒ Due date notifications are disabled. Exiting remindOverdueTasks().");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ” Scanning for overdue tasks...');
Â Â Â Â 
Â Â Â Â let overdueTasks = [...document.querySelectorAll(".task")]
Â Â Â Â Â Â Â Â .filter(task => task.classList.contains("overdue-task"))
Â Â Â Â Â Â Â Â .map(task => task.querySelector(".task-text").textContent);

Â Â Â Â console.log('ğŸ“‹ Found overdue tasks:', overdueTasks.length);

Â Â Â Â if (overdueTasks.length > 0) {
Â Â Â Â Â Â Â Â console.log('âš ï¸ Showing overdue notification for tasks:', overdueTasks);
Â Â Â Â Â Â Â Â showNotification(`âš ï¸ Overdue Tasks:<br>- ${overdueTasks.join("<br>- ")}`, "error");
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('âœ… No overdue tasks found');
Â Â Â Â }
}







/**
Â * Updates the main menu header with the active miniCycle title and current date.
Â * Ensures proper display of selected miniCycle.
Â */

function updateMainMenuHeader() {
Â Â Â Â console.log('ğŸ“° Updating main menu header (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const menuHeaderTitle = document.getElementById("main-menu-mini-cycle-title");
Â Â Â Â const dateElement = document.getElementById("current-date");
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateMainMenuHeader');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â let activeCycleTitle = "No miniCycle Selected";
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Looking up active cycle:', activeCycle);
Â Â Â Â 
Â Â Â Â if (activeCycle && cycles[activeCycle]) {
Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â activeCycleTitle = currentCycle.title || activeCycle;
Â Â Â Â Â Â Â Â console.log('âœ… Found active cycle title:', activeCycleTitle);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for header update');
Â Â Â Â }

Â Â Â Â // âœ… Get Current Date
Â Â Â Â const today = new Date();
Â Â Â Â const formattedDate = today.toLocaleDateString(undefined, {
Â Â Â Â Â Â Â Â weekday: 'short', // "Mon"
Â Â Â Â Â Â Â Â month: 'short', // "Jan"
Â Â Â Â Â Â Â Â day: '2-digit', // "08"
Â Â Â Â Â Â Â Â year: 'numeric' // "2025"
Â Â Â Â });

Â Â Â Â console.log('ğŸ“… Formatted date:', formattedDate);

Â Â Â Â // âœ… Update Title & Date
Â Â Â Â if (menuHeaderTitle) {
Â Â Â Â Â Â Â Â menuHeaderTitle.textContent = activeCycleTitle;
Â Â Â Â Â Â Â Â console.log('ğŸ·ï¸ Updated menu header title');
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Menu header title element not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (dateElement) {
Â Â Â Â Â Â Â Â dateElement.textContent = formattedDate;
Â Â Â Â Â Â Â Â console.log('ğŸ“… Updated date element');
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Date element not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Main menu header update completed');
}

/**
Â * Saves the due date for a specific task in the active miniCycle.
Â *
Â * @param {string} taskText - The text of the task to update.
Â * @param {string|null} dueDate - The due date to assign, or null to remove the due date.
Â */

function saveTaskDueDate(taskId, newDueDate) {
Â Â Â Â console.log('ğŸ“… Saving task due date (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveTaskDueDate');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â console.error("âŒ Error: Active cycle not found in Schema 2.5.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Finding task:', taskId);
Â Â Â Â 
Â Â Â Â const task = cycles[activeCycle].tasks?.find(t => t.id === taskId);
Â Â Â Â 
Â Â Â Â if (!task) {
Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Task with ID "${taskId}" not found in active cycle`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Updating due date:', {
Â Â Â Â Â Â Â Â taskId,
Â Â Â Â Â Â Â Â taskText: task.text,
Â Â Â Â Â Â Â Â oldDueDate: task.dueDate,
Â Â Â Â Â Â Â Â newDueDate
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Update task due date
Â Â Â Â task.dueDate = newDueDate;
Â Â Â Â 
Â Â Â Â // Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycles[activeCycle];
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log(`âœ… Due date updated for task "${task.text}": ${newDueDate || 'cleared'}`);
}
Â Â /***********************
Â *Â 
Â *Â 
Â * Menu Management Logic
Â *Â 
Â *Â 
Â ************************/

/**
Â * Saves the current miniCycle under a new name, creating a separate copy.
Â * Ensures that the new name is unique before saving.
Â */

function saveMiniCycleAsNew() {
Â Â Â Â console.log('ğŸ’¾ Saving miniCycle as new (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveMiniCycleAsNew');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Checking active cycle:', activeCycle);
Â Â Â Â 
Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active miniCycle found to save');
Â Â Â Â Â Â Â Â showNotification("âš  No miniCycle found to save.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“ Prompting user for new cycle name');

Â Â Â Â showPromptModal({
Â Â Â Â Â Â Â Â title: "Duplicate Cycle List",
Â Â Â Â Â Â Â Â message: `Enter a new name for your copy of "${currentCycle.title}":`,
Â Â Â Â Â Â Â Â placeholder: "e.g., My Custom Routine",
Â Â Â Â Â Â Â Â confirmText: "Save Copy",
Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â required: true,
Â Â Â Â Â Â Â Â callback: (input) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (!input) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âŒ User cancelled save operation');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Save cancelled.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â const newCycleName = sanitizeInput(input.trim());
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ” Processing new cycle name:', newCycleName);

Â Â Â Â Â Â Â Â Â Â Â Â if (!newCycleName) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Invalid cycle name provided');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš  Please enter a valid name.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Check for existing cycles by key
Â Â Â Â Â Â Â Â Â Â Â Â if (cycles[newCycleName]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Cycle name already exists:', newCycleName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš  A miniCycle with this name already exists. Please choose a different name.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Creating new cycle copy...');

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Create new cycle with title as key for Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â const newCycleId = `copy_${Date.now()}`;
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Deep copying current cycle data');
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Deep copy the current cycle with new title as storage key
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[newCycleName] = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ...JSON.parse(JSON.stringify(currentCycle)),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: newCycleId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: newCycleName,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now()
Â Â Â Â Â Â Â Â Â Â Â Â };

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¯ Setting new cycle as active:', newCycleName);

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Set as active cycle using the title as key
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = newCycleName;
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;

Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… Successfully created cycle copy: "${currentCycle.title}" â†’ "${newCycleName}"`);
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ˆ Total cycles created:', fullSchemaData.metadata.totalCyclesCreated);

Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âœ… miniCycle "${currentCycle.title}" was copied as "${newCycleName}"!`);
Â Â Â Â Â Â Â Â Â Â Â Â hideMainMenu();
Â Â Â Â Â Â Â Â Â Â Â Â loadMiniCycle();
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}


/**
Â * Switchminicycle function.
Â *
Â * @returns {void}
Â */

function switchMiniCycle() {
Â Â Â Â console.log('ğŸ”„ Opening switch miniCycle modal (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for switchMiniCycle');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles } = schemaData;
Â Â Â Â const switchModal = document.querySelector(".mini-cycle-switch-modal");
Â Â Â Â const listContainer = document.getElementById("miniCycleList");
Â Â Â Â const switchRow = document.querySelector(".switch-items-row");
Â Â Â Â const renameButton = document.getElementById("switch-rename");
Â Â Â Â const deleteButton = document.getElementById("switch-delete");
Â Â Â Â const previewWindow = document.getElementById("switch-preview-window");

Â Â Â Â console.log('ğŸ“Š Found cycles:', Object.keys(cycles).length);

Â Â Â Â hideMainMenu();

Â Â Â Â if (Object.keys(cycles).length === 0) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No saved miniCycles found');
Â Â Â Â Â Â Â Â showNotification("No saved miniCycles found.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ”„ Populating cycle list...');

Â Â Â Â // âœ… Clear previous list and populate with miniCycles from Schema 2.5
Â Â Â Â listContainer.innerHTML = "";
Â Â Â Â Object.entries(cycles).forEach(([cycleKey, cycle]) => {
Â Â Â Â Â Â Â Â const listItem = document.createElement("button");
Â Â Â Â Â Â Â Â listItem.classList.add("mini-cycle-switch-item");
Â Â Â Â Â Â Â Â listItem.textContent = cycle.title || cycleKey;
Â Â Â Â Â Â Â Â listItem.dataset.cycleKey = cycleKey; // âœ… Use the storage key (title in Option 1)
Â Â Â Â Â Â Â Â listItem.dataset.cycleName = cycle.title || cycleKey; // Keep for compatibility

Â Â Â Â Â Â Â Â console.log('ğŸ“‹ Adding cycle to list:', cycle.title || cycleKey);

Â Â Â Â Â Â Â Â // âœ… Click event for selecting a miniCycle
Â Â Â Â Â Â Â Â listItem.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¯ Cycle selected:', cycle.title || cycleKey);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".mini-cycle-switch-item").forEach(item =>Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â item.classList.remove("selected"));
Â Â Â Â Â Â Â Â Â Â Â Â listItem.classList.add("selected");

Â Â Â Â Â Â Â Â Â Â Â Â switchRow.style.display = "block";Â 
Â Â Â Â Â Â Â Â Â Â Â Â updatePreview(cycle.title || cycleKey);
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â listContainer.appendChild(listItem);
Â Â Â Â });

Â Â Â Â console.log('ğŸ“± Showing switch modal...');
Â Â Â Â switchModal.style.display = "flex";
Â Â Â Â switchRow.style.display = "none";
Â Â Â Â loadMiniCycleList();

Â Â Â Â console.log('ğŸ”— Setting up event listeners...');

Â Â Â Â // âœ… Event listeners remain the same
Â Â Â Â renameButton.removeEventListener("click", renameMiniCycle);
Â Â Â Â renameButton.addEventListener("click", renameMiniCycle);

Â Â Â Â deleteButton.removeEventListener("click", deleteMiniCycle);
Â Â Â Â deleteButton.addEventListener("click", deleteMiniCycle);

Â Â Â Â document.getElementById("miniCycleSwitchConfirm").removeEventListener("click", confirmMiniCycle);
Â Â Â Â document.getElementById("miniCycleSwitchConfirm").addEventListener("click", confirmMiniCycle);

document.getElementById("miniCycleSwitchCancel").removeEventListener("click", hideSwitchMiniCycleModal);
document.getElementById("miniCycleSwitchCancel").addEventListener("click", hideSwitchMiniCycleModal);
Â Â Â Â 
Â Â Â Â console.log('âœ… Switch miniCycle modal setup completed');
}
Â Â 

/**
Â * Renameminicycle function.
Â *
Â * @returns {void}
Â */

function renameMiniCycle() {
Â Â Â Â console.log('ğŸ“ Renaming miniCycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const selectedCycle = document.querySelector(".mini-cycle-switch-item.selected");

Â Â Â Â if (!selectedCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No cycle selected for rename');
Â Â Â Â Â Â Â Â showNotification("Please select a miniCycle to rename.", "info", 1500);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for renameMiniCycle');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles } = schemaData;
Â Â Â Â const cycleKey = selectedCycle.dataset.cycleKey;
Â Â Â Â const currentCycle = cycles[cycleKey];
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Renaming cycle:', cycleKey);
Â Â Â Â 
Â Â Â Â if (!cycleKey || !currentCycle) {
Â Â Â Â Â Â Â Â console.error('âŒ Invalid cycle selection:', { cycleKey, hasCycle: !!currentCycle });
Â Â Â Â Â Â Â Â showNotification("âš ï¸ Invalid cycle selection.", "error", 1500);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const oldName = currentCycle.title;
Â Â Â Â console.log('ğŸ“Š Current cycle details:', { oldName, cycleKey });

Â Â Â Â showPromptModal({
Â Â Â Â Â Â Â Â title: "Rename miniCycle",
Â Â Â Â Â Â Â Â message: `Rename "${oldName}" to:`,
Â Â Â Â Â Â Â Â placeholder: "e.g., Morning Routine",
Â Â Â Â Â Â Â Â defaultValue: oldName,
Â Â Â Â Â Â Â Â confirmText: "Rename",
Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â required: true,
Â Â Â Â Â Â Â Â callback: (newName) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (!newName) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âŒ User cancelled rename');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Rename canceled.", "show", 1500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â const cleanName = sanitizeInput(newName.trim());
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Cleaned name:', { original: newName, cleaned: cleanName });
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (cleanName === oldName) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('â„¹ï¸ Name unchanged');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("â„¹ Name unchanged.", "show", 1500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â // Check for existing cycles by title (key collision check)
Â Â Â Â Â Â Â Â Â Â Â Â if (cycles[cleanName]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Cycle name already exists:', cleanName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš  A miniCycle with that name already exists.", "show", 1500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Performing rename operation...');

Â Â Â Â Â Â Â Â Â Â Â Â // Update Schema 2.5 with title-as-key approach
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Create new entry with new title as key
Â Â Â Â Â Â Â Â Â Â Â Â const updatedCycle = { ...currentCycle, title: cleanName };
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[cleanName] = updatedCycle;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Remove old entry
Â Â Â Â Â Â Â Â Â Â Â Â delete fullSchemaData.data.cycles[cycleKey];
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Updated cycles structure:', Object.keys(fullSchemaData.data.cycles));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Update active cycle if this was the active one
Â Â Â Â Â Â Â Â Â Â Â Â if (fullSchemaData.appState.activeCycleId === cycleKey) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = cleanName;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¯ Updated active cycle ID to:', cleanName);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Rename saved to Schema 2.5');

Â Â Â Â Â Â Â Â Â Â Â Â // Update UI
Â Â Â Â Â Â Â Â Â Â Â Â selectedCycle.dataset.cycleKey = cleanName;
Â Â Â Â Â Â Â Â Â Â Â Â selectedCycle.dataset.cycleName = cleanName;
Â Â Â Â Â Â Â Â Â Â Â Â selectedCycle.textContent = cleanName;

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Refreshing UI...');

Â Â Â Â Â Â Â Â Â Â Â Â // Refresh UI
Â Â Â Â Â Â Â Â Â Â Â Â loadMiniCycleList();
Â Â Â Â Â Â Â Â Â Â Â Â updatePreview(cleanName);
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const updatedItem = [...document.querySelectorAll(".mini-cycle-switch-item")]
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .find(item => item.dataset.cycleKey === cleanName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (updatedItem) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updatedItem.classList.add("selected");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updatedItem.click();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Updated item selected in UI');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }, 50);

Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… Successfully renamed: "${oldName}" â†’ "${cleanName}"`);
Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âœ… miniCycle renamed to "${cleanName}"`, "success", 2500);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}

/**
Â * Deleteminicycle function.
Â *
Â * @returns {void}
Â */
function deleteMiniCycle() {
Â Â Â Â console.log('ğŸ—‘ï¸ Deleting miniCycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const selectedCycle = document.querySelector(".mini-cycle-switch-item.selected");
Â Â Â Â if (!selectedCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No cycle selected for deletion');
Â Â Â Â Â Â Â Â showNotification("âš  No miniCycle selected for deletion.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for deleteMiniCycle');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleKey = selectedCycle.dataset.cycleKey;
Â Â Â Â const currentCycle = cycles[cycleKey];
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Deleting cycle:', cycleKey);
Â Â Â Â console.log('ğŸ“Š Current cycles count:', Object.keys(cycles).length);
Â Â Â Â 
Â Â Â Â if (!cycleKey || !currentCycle) {
Â Â Â Â Â Â Â Â console.error('âŒ Invalid cycle selection:', { cycleKey, hasCycle: !!currentCycle });
Â Â Â Â Â Â Â Â showNotification("âš ï¸ Invalid cycle selection.", "error", 1500);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const cycleToDelete = currentCycle.title;
Â Â Â Â console.log('ğŸ“Š Cycle to delete:', { title: cycleToDelete, isActive: cycleKey === activeCycle });

Â Â Â Â showConfirmationModal({
Â Â Â Â Â Â Â Â title: "Delete miniCycle",
Â Â Â Â Â Â Â Â message: `âŒ Are you sure you want to delete "${cycleToDelete}"? This action cannot be undone.`,
Â Â Â Â Â Â Â Â confirmText: "Delete",
Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmed) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âŒ User cancelled deletion');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Performing deletion...');

Â Â Â Â Â Â Â Â Â Â Â Â // Create undo snapshot before deletion
Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â // Remove the selected miniCycle from Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â delete fullSchemaData.data.cycles[cycleKey];
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… miniCycle "${cycleToDelete}" deleted from Schema 2.5`);
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“Š Remaining cycles:', Object.keys(fullSchemaData.data.cycles));

Â Â Â Â Â Â Â Â Â Â Â Â // If the deleted cycle was the active one, handle fallback
Â Â Â Â Â Â Â Â Â Â Â Â if (cycleKey === activeCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¯ Deleted cycle was active, handling fallback...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const remainingCycleKeys = Object.keys(fullSchemaData.data.cycles);

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (remainingCycleKeys.length > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Switch to the first available miniCycle
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const newActiveCycleKey = remainingCycleKeys[0];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = newActiveCycleKey;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const newActiveCycle = fullSchemaData.data.cycles[newActiveCycleKey];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ”„ Switched to miniCycle: "${newActiveCycle.title}"`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âš ï¸ No cycles remaining, resetting app...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hideSwitchMiniCycleModal();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš  No miniCycles left. Please create a new one.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Manually reset UI instead of reloading
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskList.innerHTML = "";
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleAutoReset.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â initialSetup();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }, 300);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â // Update metadata and save
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Deletion saved to Schema 2.5');
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Refreshing UI...');

Â Â Â Â Â Â Â Â Â Â Â Â // Refresh UI
Â Â Â Â Â Â Â Â Â Â Â Â loadMiniCycle();
Â Â Â Â Â Â Â Â Â Â Â Â loadMiniCycleList();
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(updateProgressBar, 500);
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(updateStatsPanel, 500);
Â Â Â Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const firstCycle = document.querySelector(".mini-cycle-switch-item");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (firstCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â firstCycle.classList.add("selected");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â firstCycle.click();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… First remaining cycle selected');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }, 50);

Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… Successfully deleted: "${cycleToDelete}"`);
Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`ğŸ—‘ï¸ "${cycleToDelete}" has been deleted.`);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}
/**
Â * Hideswitchminicyclemodal function.
Â *
Â * @returns {void}
Â */
function hideSwitchMiniCycleModal() {
Â Â Â Â console.log("ğŸ” Hiding switch miniCycle modal (Schema 2.5 only)...");
Â Â Â Â 
Â Â Â Â const switchModal = document.querySelector(".mini-cycle-switch-modal");
Â Â Â Â console.log("ğŸ” Modal Found?", switchModal);

Â Â Â Â if (!switchModal) {
Â Â Â Â Â Â Â Â console.error("âŒ Error: Modal not found.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â switchModal.style.display = "none";
Â Â Â Â console.log("âœ… Modal hidden successfully");
}

/**
Â * Confirmminicycle function.
Â *
Â * @returns {void}
Â */
function confirmMiniCycle() {
Â Â Â Â console.log("âœ… Confirming miniCycle selection (Schema 2.5 only)...");
Â Â Â Â 
Â Â Â Â const selectedCycle = document.querySelector(".mini-cycle-switch-item.selected");

Â Â Â Â if (!selectedCycle) {
Â Â Â Â Â Â Â Â showNotification("Please select a miniCycle.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for confirmMiniCycle');
Â Â Â Â Â Â Â Â showNotification("âŒ Cannot switch cycle - Schema 2.5 data required.", "error");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const cycleKey = selectedCycle.dataset.cycleKey;
Â Â Â Â 
Â Â Â Â if (!cycleKey) {
Â Â Â Â Â Â Â Â console.error("âŒ Invalid cycle selection - missing cycleKey");
Â Â Â Â Â Â Â Â showNotification("âš ï¸ Invalid cycle selection.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log(`ğŸ”„ Switching to cycle: ${cycleKey}`);
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â 
Â Â Â Â // Set the active cycle using the cycle key
Â Â Â Â fullSchemaData.appState.activeCycleId = cycleKey;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log(`âœ… Switched to cycle (Schema 2.5): ${cycleKey}`);
Â Â Â Â 
Â Â Â Â // Load the new cycle and close modal
Â Â Â Â loadMiniCycle();
Â Â Â Â hideSwitchMiniCycleModal();
Â Â Â Â 
Â Â Â Â // Show confirmation
Â Â Â Â const cycleName = fullSchemaData.data.cycles[cycleKey]?.title || cycleKey;
Â Â Â Â showNotification(`âœ… Switched to "${cycleName}"`, "success", 2000);
}



// âœ… Updated event listener with proper error checking
function setupModalClickOutside() {
Â Â Â Â document.addEventListener("click", function closeOnClickOutside(event) {
Â Â Â Â Â Â Â Â const switchModalContent = document.querySelector(".mini-cycle-switch-modal-content");
Â Â Â Â Â Â Â Â const switchModal = document.querySelector(".mini-cycle-switch-modal");
Â Â Â Â Â Â Â Â const mainMenu = document.querySelector(".menu-container");

Â Â Â Â Â Â Â Â // âœ… Add error checking for missing elements
Â Â Â Â Â Â Â Â if (!switchModalContent || !switchModal || !mainMenu) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Modal elements not found for click outside handler');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… If the modal is open and the clicked area is NOT inside the modal or main menu, close it
Â Â Â Â Â Â Â Â if (
Â Â Â Â Â Â Â Â Â Â Â Â switchModal.style.display === "flex" &&
Â Â Â Â Â Â Â Â Â Â Â Â !switchModalContent.contains(event.target) &&Â 
Â Â Â Â Â Â Â Â Â Â Â Â !mainMenu.contains(event.target)
Â Â Â Â Â Â Â Â ) {
Â Â Â Â Â Â Â Â Â Â Â Â switchModal.style.display = "none";Â 
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}

// âœ… Call this function during initialization instead of immediate attachment

/**
Â * Updatepreview function.
Â *
Â * @param {any} cycleName - Description. * @returns {void}
Â */

function updatePreview(cycleName) {
Â Â Â Â console.log('ğŸ‘ï¸ Updating preview (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updatePreview');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles } = schemaData;
Â Â Â Â const cycleData = cycles[cycleName];
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Preview for cycle:', cycleName);
Â Â Â Â 
Â Â Â Â const previewWindow = document.getElementById("switch-preview-window");

Â Â Â Â function escapeHTML(str) {
Â Â Â Â Â Â Â Â const temp = document.createElement("div");
Â Â Â Â Â Â Â Â temp.textContent = str;
Â Â Â Â Â Â Â Â return temp.innerHTML;
Â Â Â Â }

Â Â Â Â if (!cycleData || !cycleData.tasks) {
Â Â Â Â Â Â Â Â previewWindow.innerHTML = `<br><strong>No tasks found.</strong>`;
Â Â Â Â Â Â Â Â console.log('âš ï¸ No tasks found for preview');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“‹ Generating preview for', cycleData.tasks.length, 'tasks');

Â Â Â Â // âœ… Create a simple list of tasks for preview
Â Â Â Â const tasksPreview = cycleData.tasks
Â Â Â Â Â Â Â Â .map(task => `<div class="preview-task">${task.completed ? "âœ”ï¸" : "___"} ${escapeHTML(task.text)}</div>`)
Â Â Â Â Â Â Â Â .join("");

Â Â Â Â previewWindow.innerHTML = `<strong>Tasks:</strong><br>${tasksPreview}`;
Â Â Â Â 
Â Â Â Â console.log('âœ… Preview updated successfully');
}
/**
Â * Loadminicyclelist function.
Â *
Â * @returns {void}
Â */
function loadMiniCycleList() {
Â Â Â Â console.log('ğŸ“‹ Loading miniCycle list (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for loadMiniCycleList');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles } = schemaData;
Â Â Â Â const miniCycleList = document.getElementById("miniCycleList");
Â Â Â Â 
Â Â Â Â if (!miniCycleList) {
Â Â Â Â Â Â Â Â console.error('âŒ miniCycleList element not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â miniCycleList.innerHTML = ""; // Clear the list before repopulating

Â Â Â Â console.log('ğŸ“Š Found cycles:', Object.keys(cycles).length);

Â Â Â Â // âœ… Use Object.entries to get both key and cycle data
Â Â Â Â Object.entries(cycles).forEach(([cycleKey, cycleData]) => {
Â Â Â Â Â Â Â Â const listItem = document.createElement("div");
Â Â Â Â Â Â Â Â listItem.classList.add("mini-cycle-switch-item");
Â Â Â Â Â Â Â Â listItem.dataset.cycleName = cycleData.title || cycleKey; // Use title for compatibility
Â Â Â Â Â Â Â Â listItem.dataset.cycleKey = cycleKey; // âœ… Store the storage key

Â Â Â Â Â Â Â Â console.log('ğŸ“‹ Adding cycle to list:', cycleData.title || cycleKey);

Â Â Â Â Â Â Â Â // ğŸ·ï¸ Determine emoji based on miniCycle properties
Â Â Â Â Â Â Â Â let emoji = "ğŸ“‹"; // Default to ğŸ“‹ (Standard Document)
Â Â Â Â Â Â Â Â if (cycleData.autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â emoji = "ğŸ”ƒ"; // If Auto Reset is ON, show ğŸ”ƒ
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // ğŸ“Œ Ensure spacing between emoji and text
Â Â Â Â Â Â Â Â listItem.textContent = emoji + " ";
Â Â Â Â Â Â Â Â const nameSpan = document.createElement("span");
Â Â Â Â Â Â Â Â nameSpan.textContent = cycleData.title || cycleKey;
Â Â Â Â Â Â Â Â listItem.appendChild(nameSpan);

Â Â Â Â Â Â Â Â // ğŸ–±ï¸ Handle selection
Â Â Â Â Â Â Â Â listItem.addEventListener("click", function () {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¯ Cycle selected:', cycleData.title || cycleKey);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".mini-cycle-switch-item").forEach(item => item.classList.remove("selected"));
Â Â Â Â Â Â Â Â Â Â Â Â this.classList.add("selected");

Â Â Â Â Â Â Â Â Â Â Â Â // Show preview & buttons
Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("switch-items-row").style.display = "block";
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Pass the cycle key for Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â updatePreview(cycleKey);
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â miniCycleList.appendChild(listItem);
Â Â Â Â });

Â Â Â Â updateReminderButtons();
Â Â Â Â 
Â Â Â Â console.log('âœ… MiniCycle list loaded successfully');
}



/**
Â * Clearalltasks function.
Â *
Â * @returns {void}
Â */
function clearAllTasks() {
Â Â Â Â console.log('ğŸ§¹ Clearing all tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for clearAllTasks');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active miniCycle to clear tasks');
Â Â Â Â Â Â Â Â showNotification("âš  No active miniCycle to clear tasks.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Clearing tasks for cycle:', activeCycle);

Â Â Â Â // âœ… Create undo snapshot before making changes
Â Â Â Â pushUndoSnapshot();

Â Â Â Â // âœ… Uncheck all tasks (DO NOT DELETE)
Â Â Â Â currentCycle.tasks.forEach(task => task.completed = false);

Â Â Â Â // âœ… Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â console.log('ğŸ’¾ Tasks unchecked and saved to Schema 2.5');

Â Â Â Â // âœ… Uncheck tasks in the UI and remove overdue styling
Â Â Â Â document.querySelectorAll("#taskList .task").forEach(taskElement => {
Â Â Â Â Â Â Â Â const checkbox = taskElement.querySelector("input[type='checkbox']");
Â Â Â Â Â Â Â Â if (checkbox) {
Â Â Â Â Â Â Â Â Â Â Â Â checkbox.checked = false;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â // âœ… Remove overdue styling
Â Â Â Â Â Â Â Â taskElement.classList.remove("overdue-task");
Â Â Â Â });

Â Â Â Â // âœ… Update UI elements
Â Â Â Â updateProgressBar();
Â Â Â Â updateStatsPanel();
Â Â Â Â checkCompleteAllButton();
Â Â Â Â updateRecurringPanelButtonVisibility();
Â Â Â Â hideMainMenu();

Â Â Â Â // âœ… Show undo/hide redo buttons
Â Â Â Â document.getElementById("undo-btn").hidden = false;
Â Â Â Â document.getElementById("redo-btn").hidden = true;

Â Â Â Â console.log(`âœ… All tasks unchecked for miniCycle: "${currentCycle.title}"`);
Â Â Â Â showNotification(`âœ… All tasks unchecked for "${currentCycle.title}"`, "success", 2000);
}

/**
Â * Deletealltasks function.
Â *
Â * @returns {void}
Â */
function deleteAllTasks() {
Â Â Â Â console.log('ğŸ—‘ï¸ Deleting all tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for deleteAllTasks');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active miniCycle to delete tasks from');
Â Â Â Â Â Â Â Â showNotification("âš  No active miniCycle to delete tasks from.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Preparing to delete tasks for cycle:', activeCycle);

Â Â Â Â // âœ… Use callback pattern with showConfirmationModal
Â Â Â Â showConfirmationModal({
Â Â Â Â Â Â Â Â title: "Delete All Tasks",
Â Â Â Â Â Â Â Â message: `âš  Are you sure you want to permanently delete all tasks in "${currentCycle.title}"? This action cannot be undone.`,
Â Â Â Â Â Â Â Â confirmText: "Delete All",
Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmed) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âŒ User cancelled deletion');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Deletion cancelled.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Proceeding with task deletion...');

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Push undo snapshot before deletion
Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Clear tasks completely
Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.tasks = [];

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Clear recurring templates too
Â Â Â Â Â Â Â Â Â Â Â Â if (currentCycle.recurringTemplates) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates = {};
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ All tasks deleted and saved to Schema 2.5');

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Clear UI & update progress
Â Â Â Â Â Â Â Â Â Â Â Â const taskList = document.getElementById("taskList");
Â Â Â Â Â Â Â Â Â Â Â Â if (taskList) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskList.innerHTML = "";
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringPanelButtonVisibility();

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Show undo/hide redo buttons
Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("undo-btn").hidden = false;
Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("redo-btn").hidden = true;

Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… All tasks deleted for miniCycle: "${currentCycle.title}"`);
Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âœ… All tasks deleted from "${currentCycle.title}"`, "success", 3000);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}


/**
Â * Create new miniCycle function.
Â *
Â * @returns {void}
Â */
function createNewMiniCycle() {
Â Â Â Â console.log('ğŸ†• Creating new miniCycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for createNewMiniCycle');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â showPromptModal({
Â Â Â Â Â Â Â Â title: "Create New miniCycle",
Â Â Â Â Â Â Â Â message: "What would you like to name it?",
Â Â Â Â Â Â Â Â placeholder: "e.g., Daily Routine",
Â Â Â Â Â Â Â Â defaultValue: "",
Â Â Â Â Â Â Â Â confirmText: "Create",
Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â required: true,
Â Â Â Â Â Â Â Â callback: (result) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (!result) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âŒ User cancelled creation');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Creation canceled.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const newCycleName = sanitizeInput(result.trim());
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ” Processing new cycle name:', newCycleName);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Create unique ID first
Â Â Â Â Â Â Â Â Â Â Â Â const cycleId = `cycle_${Date.now()}`;
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ†” Generated cycle ID:', cycleId);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Determine the storage key (title-first approach with ID fallback)
Â Â Â Â Â Â Â Â Â Â Â Â let storageKey = newCycleName;
Â Â Â Â Â Â Â Â Â Â Â Â let finalTitle = newCycleName;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Handle duplicate titles by checking existing keys
Â Â Â Â Â Â Â Â Â Â Â Â if (fullSchemaData.data.cycles[storageKey]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âš ï¸ Duplicate title detected, finding unique variation');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Try numbered variations first: "Title (2)", "Title (3)", etc.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let counter = 2;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let numberedTitle = `${newCycleName} (${counter})`;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â while (fullSchemaData.data.cycles[numberedTitle] && counter < 10) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â counter++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â numberedTitle = `${newCycleName} (${counter})`;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // If we found a unique numbered title, use it
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!fullSchemaData.data.cycles[numberedTitle]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â storageKey = numberedTitle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â finalTitle = numberedTitle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Using numbered variation:', finalTitle);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âš  Title already exists. Using "${finalTitle}" instead.`, "warning", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Fallback to ID if too many duplicates
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â storageKey = cycleId;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â finalTitle = newCycleName; // Keep original title inside object
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Using unique ID for storage:', storageKey);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âš  Multiple cycles with this name exist. Using unique ID for storage.`, "warning", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Creating new cycle with storage key:', storageKey);

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Create new cycle in Schema 2.5 format
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[storageKey] = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: finalTitle,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: cycleId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tasks: [],
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoReset: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: 0,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â Â Â Â Â Â Â Â Â };

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Set as active cycle using the storage key
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = storageKey;
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Saving to Schema 2.5 storage...');

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Save to localStorage
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Updating UI elements...');

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Clear UI & Load new miniCycle
Â Â Â Â Â Â Â Â Â Â Â Â const taskList = document.getElementById("taskList");
Â Â Â Â Â Â Â Â Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â Â Â Â Â Â Â Â Â const deleteCheckedTasks = document.getElementById("deleteCheckedTasks");
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (taskList) taskList.innerHTML = "";
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const titleElement = document.getElementById("mini-cycle-title");
Â Â Â Â Â Â Â Â Â Â Â Â if (titleElement) titleElement.textContent = finalTitle;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (toggleAutoReset) toggleAutoReset.checked = true;
Â Â Â Â Â Â Â Â Â Â Â Â if (deleteCheckedTasks) deleteCheckedTasks.checked = false;

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Ensure UI updates
Â Â Â Â Â Â Â Â Â Â Â Â hideMainMenu();
Â Â Â Â Â Â Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â Â Â Â Â Â Â Â Â autoSave();

Â Â Â Â Â Â Â Â Â Â Â Â console.log(`âœ… Created and switched to new miniCycle (Schema 2.5): "${finalTitle}" (key: ${storageKey})`);
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ˆ Total cycles created:', fullSchemaData.metadata.totalCyclesCreated);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`âœ… Created new miniCycle "${finalTitle}"`, "success", 3000);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}



indefiniteCheckbox.addEventListener("change", () => {
Â Â // If indefinite, hide the repeatCount row
Â Â repeatCountRow.style.display = indefiniteCheckbox.checked ? "none" : "block";
});



function handleReminderToggle() {
Â Â Â Â console.log('ğŸ”” Handling reminder toggle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const isEnabled = enableReminders.checked;
Â Â 
Â Â Â Â // âœ… Get previous state from Schema 2.5
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for handleReminderToggle');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const previousSettings = schemaData.reminders || {};
Â Â Â Â const wasEnabled = previousSettings.enabled === true;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Reminder toggle state:', {
Â Â Â Â Â Â Â Â wasEnabled,
Â Â Â Â Â Â Â Â nowEnabled: isEnabled,
Â Â Â Â Â Â Â Â changed: wasEnabled !== isEnabled
Â Â Â Â });
Â Â 
Â Â Â Â // âœ… Update the visibility of the frequency section
Â Â Â Â frequencySection.classList.toggle("hidden", !isEnabled);
Â Â 
Â Â Â Â // âœ… Save updated settings and get the current global state
Â Â Â Â const globalReminderState = autoSaveReminders();
Â Â 
Â Â Â Â // âœ… Update the ğŸ”” task buttons
Â Â Â Â updateReminderButtons();
Â Â 
Â Â Â Â // âœ… Start or stop reminders
Â Â Â Â if (globalReminderState) {
Â Â Â Â Â Â Â Â console.log("ğŸ”” Global Reminders Enabled â€” Starting reminders...");
Â Â Â Â Â Â Â Â if (!wasEnabled) {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ”” Task reminders enabled!", "success", 2500);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â setTimeout(() => startReminders(), 200);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log("ğŸ”• Global Reminders Disabled â€” Stopping reminders...");
Â Â Â Â Â Â Â Â if (wasEnabled) {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ”• Task reminders disabled.", "error", 2500);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â stopReminders();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Reminder toggle handled successfully');
}
Â Â 
Â Â function setupReminderToggle() {
Â Â Â Â Â Â console.log('âš™ï¸ Setting up reminder toggle (Schema 2.5 only)...');
Â Â Â Â Â Â 
Â Â Â Â Â Â safeAddEventListener(enableReminders, "change", handleReminderToggle);
Â Â 
Â Â Â Â Â Â // âœ… Load reminder settings from Schema 2.5
Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for setupReminderToggle');
Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â const reminderSettings = schemaData.reminders || {
Â Â Â Â Â Â Â Â Â Â enabled: false,
Â Â Â Â Â Â Â Â Â Â indefinite: true,
Â Â Â Â Â Â Â Â Â Â dueDatesReminders: false,
Â Â Â Â Â Â Â Â Â Â repeatCount: 0,
Â Â Â Â Â Â Â Â Â Â frequencyValue: 0,
Â Â Â Â Â Â Â Â Â Â frequencyUnit: "hours"
Â Â Â Â Â Â };
Â Â 
Â Â Â Â Â Â console.log('ğŸ“Š Loading reminder settings from Schema 2.5:', reminderSettings);
Â Â 
Â Â Â Â Â Â enableReminders.checked = reminderSettings.enabled === true;
Â Â Â Â Â Â frequencySection.classList.toggle("hidden", !reminderSettings.enabled);
Â Â 
Â Â Â Â Â Â // âœ… ğŸ§  Reminder system will re-run if already enabled
Â Â Â Â Â Â if (reminderSettings.enabled) {
Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Reminders were enabled, starting system...');
Â Â Â Â Â Â Â Â Â Â updateReminderButtons();
Â Â Â Â Â Â Â Â Â Â startReminders();
Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”• Reminders disabled in settings');
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log('âœ… Reminder toggle setup completed');
Â Â }

Â Â function stopReminders() {
Â Â Â Â Â Â console.log('ğŸ›‘ Stopping reminder system (Schema 2.5 only)...');
Â Â Â Â Â Â 
Â Â Â Â Â Â if (reminderIntervalId) {
Â Â Â Â Â Â Â Â Â Â clearInterval(reminderIntervalId);
Â Â Â Â Â Â Â Â Â Â reminderIntervalId = null;
Â Â Â Â Â Â Â Â Â Â console.log("ğŸ›‘ Reminder interval cleared");
Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â console.log("â„¹ï¸ No active reminder interval to stop");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log("âœ… Reminder system stopped successfully");
Â Â }






/**
Â * Auto-save reminders function (Schema 2.5 only).
Â *
Â * @returns {boolean} - Returns the enabled state
Â */
function autoSaveReminders() {
Â Â Â Â console.log('ğŸ’¾ Auto-saving reminders (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for autoSaveReminders');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const enabled = document.getElementById("enableReminders").checked;
Â Â Â Â 
Â Â Â Â const remindersToSave = {
Â Â Â Â Â Â Â Â enabled,
Â Â Â Â Â Â Â Â indefinite: document.getElementById("indefiniteCheckbox").checked,
Â Â Â Â Â Â Â Â dueDatesReminders: document.getElementById("dueDatesReminders").checked,
Â Â Â Â Â Â Â Â repeatCount: parseInt(document.getElementById("repeatCount").value) || 0,
Â Â Â Â Â Â Â Â frequencyValue: parseInt(document.getElementById("frequencyValue").value) || 0,
Â Â Â Â Â Â Â Â frequencyUnit: document.getElementById("frequencyUnit").value
Â Â Â Â };
Â Â Â Â 
Â Â Â Â // â±ï¸ Save reminder start time only when enabling reminders
Â Â Â Â if (enabled) {
Â Â Â Â Â Â Â Â remindersToSave.reminderStartTime = Date.now();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.customReminders = remindersToSave;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log("âœ… Reminders settings saved automatically (Schema 2.5):", remindersToSave);
Â Â Â Â return enabled;
}

/**
Â * Load reminders settings function (Schema 2.5 only).
Â *
Â * @returns {void}
Â */
function loadRemindersSettings() {
Â Â Â Â console.log('ğŸ“¥ Loading reminders settings (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for loadRemindersSettings');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const reminders = schemaData.reminders || {
Â Â Â Â Â Â Â Â enabled: false,
Â Â Â Â Â Â Â Â indefinite: true,
Â Â Â Â Â Â Â Â dueDatesReminders: false,
Â Â Â Â Â Â Â Â repeatCount: 0,
Â Â Â Â Â Â Â Â frequencyValue: 0,
Â Â Â Â Â Â Â Â frequencyUnit: "hours"
Â Â Â Â };

Â Â Â Â console.log('ğŸ“Š Loading reminder settings from Schema 2.5:', reminders);

Â Â Â Â // âœ… Apply settings to UI
Â Â Â Â document.getElementById("enableReminders").checked = reminders.enabled;
Â Â Â Â document.getElementById("indefiniteCheckbox").checked = reminders.indefinite;
Â Â Â Â document.getElementById("dueDatesReminders").checked = reminders.dueDatesReminders;
Â Â Â Â document.getElementById("repeatCount").value = reminders.repeatCount;
Â Â Â Â document.getElementById("frequencyValue").value = reminders.frequencyValue;
Â Â Â Â document.getElementById("frequencyUnit").value = reminders.frequencyUnit;

Â Â Â Â // âœ… Show/hide frequency settings dynamically
Â Â Â Â const frequencySection = document.getElementById("frequency-section");
Â Â Â Â if (frequencySection) {
Â Â Â Â Â Â Â Â frequencySection.classList.toggle("hidden", !reminders.enabled);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const repeatCountRow = document.getElementById("repeat-count-row");
Â Â Â Â if (repeatCountRow) {
Â Â Â Â Â Â Â Â repeatCountRow.style.display = reminders.indefinite ? "none" : "block";
Â Â Â Â }

Â Â Â Â // âœ… ğŸ”” Show/hide reminder buttons on load
Â Â Â Â updateReminderButtons();
Â Â Â Â 
Â Â Â Â console.log("âœ… Reminder settings loaded from Schema 2.5");
}

// âœ… Attach auto-save & restart reminders to all reminder settings inputs safely


// âœ… Updated indefinite checkbox listener
safeAddEventListenerById("indefiniteCheckbox", "change", () => {
Â Â Â Â console.log('ğŸ”„ Indefinite checkbox changed (Schema 2.5 only)');
Â Â Â Â 
Â Â Â Â const repeatCountRow = document.getElementById("repeat-count-row");
Â Â Â Â if (repeatCountRow) {
Â Â Â Â Â Â Â Â repeatCountRow.style.display = document.getElementById("indefiniteCheckbox").checked ? "none" : "block";
Â Â Â Â }
Â Â Â Â 
Â Â Â Â autoSaveReminders();
Â Â Â Â startReminders();
});

// âœ… Updated due dates reminders listener
safeAddEventListenerById("dueDatesReminders", "change", () => {
Â Â Â Â console.log('ğŸ“… Due dates reminders changed (Schema 2.5 only)');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for dueDatesReminders change');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â 
Â Â Â Â // âœ… Update only the due dates reminders setting in Schema 2.5
Â Â Â Â if (!fullSchemaData.customReminders) {
Â Â Â Â Â Â Â Â fullSchemaData.customReminders = {};
Â Â Â Â }
Â Â Â Â 
Â Â Â Â fullSchemaData.customReminders.dueDatesReminders = document.getElementById("dueDatesReminders").checked;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â console.log(`ğŸ’¾ Saved Due Dates Reminders setting (Schema 2.5): ${fullSchemaData.customReminders.dueDatesReminders}`);
});

// âœ… Updated reminder input listeners
["repeatCount", "frequencyValue", "frequencyUnit"].forEach(id => {
Â Â Â Â safeAddEventListenerById(id, "input", () => {
Â Â Â Â Â Â Â Â console.log(`ğŸ”„ Reminder input changed: ${id} (Schema 2.5 only)`);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for reminder input change');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const settings = schemaData.reminders || {};
Â Â Â Â Â Â Â Â if (settings.enabled) {
Â Â Â Â Â Â Â Â Â Â Â Â autoSaveReminders();
Â Â Â Â Â Â Â Â Â Â Â Â startReminders();
Â Â Â Â Â Â Â Â }
Â Â Â Â });
});

/**
Â * Save the reminder state for a specific task inside the active miniCycle (Schema 2.5 only).
Â * @param {string} taskId - The ID of the task to update.
Â * @param {boolean} isEnabled - Whether reminders are enabled for this task.
Â * @returns {void}
Â */
function saveTaskReminderState(taskId, isEnabled) {
Â Â Â Â console.log('ğŸ”” Saving task reminder state (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveTaskReminderState');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â console.error('âŒ No active cycle found for task reminder state');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Finding task for reminder state update:', taskId);
Â Â Â Â 
Â Â Â Â const task = cycles[activeCycle].tasks?.find(t => t.id === taskId);
Â Â Â Â 
Â Â Â Â if (!task) {
Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Task with ID "${taskId}" not found in active cycle`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Updating reminder state:', {
Â Â Â Â Â Â Â Â taskId,
Â Â Â Â Â Â Â Â taskText: task.text,
Â Â Â Â Â Â Â Â oldState: task.remindersEnabled,
Â Â Â Â Â Â Â Â newState: isEnabled
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Update task reminder state
Â Â Â Â task.remindersEnabled = isEnabled;
Â Â Â Â 
Â Â Â Â // Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycles[activeCycle];
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log(`âœ… Task reminder state saved (Schema 2.5): ${taskId} = ${isEnabled}`);
}
/**
Â * ğŸ“Œ Handle click event for saving reminders settings.
Â * - Saves the settings.
Â * - Starts the reminders.
Â * - Shows a confirmation alert.
Â */

/**
Â * ğŸ“Œ Close the reminders settings modal when the close button is clicked.
Â */
closeRemindersBtn.addEventListener("click", () => {
Â Â Â Â remindersModal.style.display = "none";
});

/**
Â * ğŸ“Œ Close the reminders modal when clicking outside of it.
Â */
window.addEventListener("click", (event) => {
Â Â Â Â if (event.target === remindersModal) {
Â Â Â Â Â Â Â Â remindersModal.style.display = "none";
Â Â Â Â }
});

document.getElementById('try-lite-version')?.addEventListener('click', function() {
Â Â showConfirmationModal({
Â Â Â Â title: "Switch to Lite Version",
Â Â Â Â message: "Try the Lite version? It works great on older devices and slower connections.",
Â Â Â Â confirmText: "Try Lite Version",
Â Â Â Â cancelText: "Stay Here",
Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â if (confirmed) {
Â Â Â Â Â Â Â Â window.location.href = 'miniCycle-lite.html';
Â Â Â Â Â Â }
Â Â Â Â }
Â Â });
});


/********
Â *Â 
Â * Show Notification function (Schema 2.5 only) - Modular Wrapper
Â *Â 
Â */
Â Â 
function showNotification(message, type = "default", duration = null) {
Â Â return window.notifications.show(message, type, duration);
}

function setupNotificationDragging(notificationContainer) {
Â Â return window.notifications.setupNotificationDragging(notificationContainer);
}

Â Â 
function resetNotificationPosition() {
Â Â return window.notifications.resetPosition();
}


// ï¿½ Access educational tips from the notification module
const educationalTips = notifications.educationalTips;

/**
Â * ğŸš€ Enhanced Recurring Notification with Educational Tip
Â * Updated implementation for your recurring feature
Â */
function createRecurringNotificationWithTip(assignedTaskId, frequency, pattern) {
Â Â return notifications.createRecurringNotificationWithTip(assignedTaskId, frequency, pattern);
}


/**
Â * âœ… Enhanced recurring notification listeners with proper event handling (Schema 2.5 only)
Â */
function initializeRecurringNotificationListeners(notification) {
Â Â return notifications.initializeRecurringNotificationListeners(notification);
}

/**
Â * Show confirmation message after applying changes
Â */
function showApplyConfirmation(targetElement) {
Â Â return notifications.showApplyConfirmation(targetElement);
}

// ğŸ›  Unified recurring update helper (Schema 2.5 only)
function applyRecurringToTaskSchema25(taskId, newSettings, cycles, activeCycle) {
Â Â const cycleData = cycles[activeCycle];
Â Â if (!cycleData) {
Â Â Â Â console.error('âŒ No active cycle found for applyRecurringToTaskSchema25');
Â Â Â Â return;
Â Â }

Â Â let task = cycleData.tasks.find(t => t.id === taskId);
Â Â if (!task) {
Â Â Â Â console.error('âŒ Task not found for applyRecurringToTaskSchema25:', taskId);
Â Â Â Â return;
Â Â }

Â Â // Merge instead of overwrite so we keep advanced panel settings
Â Â task.recurringSettings = {
Â Â Â Â ...task.recurringSettings,
Â Â Â Â ...newSettings
Â Â };
Â Â task.recurring = true;
Â Â task.schemaVersion = 2;

Â Â // Keep recurringTemplates in sync
Â Â if (!cycleData.recurringTemplates) cycleData.recurringTemplates = {};
Â Â cycleData.recurringTemplates[taskId] = {
Â Â Â Â ...(cycleData.recurringTemplates[taskId] || {}),
Â Â Â Â id: taskId,
Â Â Â Â text: task.text,
Â Â Â Â recurring: true,
Â Â Â Â schemaVersion: 2,
Â Â Â Â recurringSettings: { ...task.recurringSettings }
Â Â };

Â Â // âœ… Save to Schema 2.5
Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â // Update DOM attributes for this task
Â Â const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
Â Â if (taskElement) {
Â Â Â Â taskElement.classList.add("recurring");
Â Â Â Â taskElement.setAttribute("data-recurring-settings", JSON.stringify(task.recurringSettings));
Â Â Â Â const recurringBtn = taskElement.querySelector(".recurring-btn");
Â Â Â Â if (recurringBtn) {
Â Â Â Â Â Â recurringBtn.classList.add("active");
Â Â Â Â Â Â recurringBtn.setAttribute("aria-pressed", "true");
Â Â Â Â }
Â Â }
}

// Make recurring function globally accessible for the notification module
window.applyRecurringToTaskSchema25 = applyRecurringToTaskSchema25;

/**
Â * ğŸ”§ Enhanced showNotification function with educational tips support (Schema 2.5 only)
Â */
function showNotificationWithTip(content, type = "default", duration = null, tipId = null) {
Â Â return notifications.showWithTip(content, type, duration, tipId);
}

/**
Â * Show a confirmation modal and call callback with boolean result
Â */
function showConfirmationModal(options) {
Â Â return notifications.showConfirmationModal(options);
}

function showPromptModal(options) {
Â Â return notifications.showPromptModal(options);
}

Â Â 
Â Â /**
Â * Startreminders function.
Â *
Â * @returns {void}
Â */


Â Â function sendReminderNotificationIfNeeded() {
Â Â Â Â Â Â console.log('ğŸ”” Sending reminder notification if needed (Schema 2.5 only)...');
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for sendReminderNotificationIfNeeded');
Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â const { reminders } = schemaData;
Â Â Â Â Â Â const remindersSettings = reminders || {};
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log('ğŸ“Š Reminder settings:', remindersSettings);
Â Â 
Â Â Â Â Â Â let tasksWithReminders = [...document.querySelectorAll(".task")]
Â Â Â Â Â Â Â Â Â Â .filter(task => task.querySelector(".enable-task-reminders.reminder-active"));
Â Â 
Â Â Â Â Â Â console.log("ğŸ” Tasks With Active Reminders:", tasksWithReminders.length);
Â Â 
Â Â Â Â Â Â let incompleteTasks = tasksWithReminders
Â Â Â Â Â Â Â Â Â Â .filter(task => !task.querySelector("input[type='checkbox']").checked)
Â Â Â Â Â Â Â Â Â Â .map(task => task.querySelector(".task-text").textContent);
Â Â 
Â Â Â Â Â Â if (incompleteTasks.length === 0) {
Â Â Â Â Â Â Â Â Â Â console.log("âœ… All tasks complete. Stopping reminders.");
Â Â Â Â Â Â Â Â Â Â clearInterval(reminderIntervalId);
Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â if (!remindersSettings.indefinite && timesReminded >= remindersSettings.repeatCount) {
Â Â Â Â Â Â Â Â Â Â console.log("âœ… Max reminders sent. Stopping reminders.");
Â Â Â Â Â Â Â Â Â Â clearInterval(reminderIntervalId);
Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â console.log('ğŸ“¢ Showing reminder notification for tasks:', incompleteTasks);
Â Â Â Â Â Â showNotification(`ğŸ”” You have tasks to complete:<br>- ${incompleteTasks.join("<br>- ")}`, "default");
Â Â Â Â Â Â timesReminded++;
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log('âœ… Reminder notification sent (Schema 2.5)');
Â Â }

function startReminders() {
Â Â Â Â console.log("ğŸ”„ Starting Reminder System (Schema 2.5 only)...");

Â Â Â Â if (reminderIntervalId) {
Â Â Â Â Â Â Â Â clearInterval(reminderIntervalId);
Â Â Â Â Â Â Â Â console.log('ğŸ›‘ Cleared existing reminder interval');
Â Â Â Â }

Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for startReminders');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { reminders } = schemaData;
Â Â Â Â const remindersSettings = reminders || {};
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Loading reminder settings from Schema 2.5:', remindersSettings);
Â Â Â Â 
Â Â Â Â if (!remindersSettings.enabled) {
Â Â Â Â Â Â Â Â console.log('ğŸ”• Reminders disabled in settings');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â let multiplier = remindersSettings.frequencyUnit === "hours" ? 3600000 :
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â remindersSettings.frequencyUnit === "days" ? 86400000 : 60000;
Â Â Â Â const intervalMs = remindersSettings.frequencyValue * multiplier;

Â Â Â Â console.log('â° Reminder interval:', {
Â Â Â Â Â Â Â Â value: remindersSettings.frequencyValue,
Â Â Â Â Â Â Â Â unit: remindersSettings.frequencyUnit,
Â Â Â Â Â Â Â Â intervalMs: intervalMs
Â Â Â Â });

Â Â Â Â // â±ï¸ Use stored start time or now if missing
Â Â Â Â const now = Date.now();
Â Â Â Â const startTime = remindersSettings.reminderStartTime || now;
Â Â Â Â const elapsedTime = now - startTime;
Â Â Â Â const intervalsPassed = Math.floor(elapsedTime / intervalMs);

Â Â Â Â timesReminded = intervalsPassed;
Â Â Â Â lastReminderTime = startTime + (intervalsPassed * intervalMs);

Â Â Â Â console.log(`â±ï¸ ${intervalsPassed} interval(s) have passed since reminderStartTime`);

Â Â Â Â // If max reminders already sent, exit early
Â Â Â Â if (!remindersSettings.indefinite && timesReminded >= remindersSettings.repeatCount) {
Â Â Â Â Â Â Â Â console.log("âœ… Max reminders already reached. Skipping further reminders.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â // Only send if enough time has passed since last reminder
Â Â Â Â if ((Date.now() - lastReminderTime) >= intervalMs) {
Â Â Â Â Â Â Â Â console.log("â° Sending catch-up reminder on startup.");
Â Â Â Â Â Â Â Â sendReminderNotificationIfNeeded();
Â Â Â Â } else {
Â Â Â Â Â Â Â Â const timeUntilNext = intervalMs - (Date.now() - lastReminderTime);
Â Â Â Â Â Â Â Â console.log(`â³ Next reminder in ${Math.round(timeUntilNext / 1000 / 60)} minutes`);
Â Â Â Â }

Â Â Â Â // ğŸ” Set up recurring reminders on interval
Â Â Â Â reminderIntervalId = setInterval(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ”” Reminder interval triggered');
Â Â Â Â Â Â Â Â sendReminderNotificationIfNeeded();
Â Â Â Â }, intervalMs);
Â Â Â Â 
Â Â Â Â console.log('âœ… Reminder system started successfully (Schema 2.5)');
}



Â Â updateRecurringPanelButtonVisibility();


Â Â function setupRecurringPanel() {
Â Â Â Â const overlay = document.getElementById("recurring-panel-overlay");
Â Â Â Â const panel = document.getElementById("recurring-panel");
Â Â Â Â const closeBtn = document.getElementById("close-recurring-panel");
Â Â Â Â const openBtn = document.getElementById("open-recurring-panel");
Â Â Â Â const yearlyApplyToAllCheckbox = document.getElementById("yearly-apply-days-to-all");
Â Â Â Â const specificDatesCheckbox = document.getElementById("recur-specific-dates");
Â Â Â Â const specificDatesPanel = document.getElementById("specific-dates-panel");
Â Â Â Â const toggleBtn = document.getElementById("toggle-advanced-settings");
Â Â Â 
Â Â Â Â advancedVisible = false; // Use global variable instead of let
Â Â Â Â setAdvancedVisibility(advancedVisible, toggleBtn);
Â Â 
Â Â Â Â toggleBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â advancedVisible = !advancedVisible;
Â Â Â Â Â Â Â Â setAdvancedVisibility(advancedVisible, toggleBtn);
Â Â Â Â });
Â Â 
Â Â Â Â if (!overlay || !panel || !closeBtn || !openBtn) return;
Â Â 
Â Â Â Â openBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â console.log('ğŸ” Opening recurring panel (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for recurring panel');
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â updateRecurringPanel(currentCycle);

Â Â Â Â Â Â Â Â document.getElementById("recurring-settings-panel")?.classList.add("hidden");
Â Â Â Â Â Â Â Â overlay.classList.remove("hidden");
Â Â Â Â Â Â Â Â updateRecurringSettingsVisibility();
Â Â Â Â Â Â Â Â document.getElementById("set-default-recurring").checked = false;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Recurring panel opened successfully');
Â Â Â Â });

Â Â Â Â // Rest of your existing setup code stays the same...
Â Â Â Â closeBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â updateRecurringSettingsVisibility();
Â Â Â Â Â Â Â Â overlay.classList.add("hidden");
Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â overlay.addEventListener("click", (e) => {
Â Â Â Â Â Â Â Â Â Â if (e.target === overlay) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringSettingsVisibility();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â overlay.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â // Rest of the function remains the same...
Â Â Â Â Â Â const frequencySelect = document.getElementById("recur-frequency");
Â Â Â Â Â Â if (frequencySelect) {
Â Â Â Â Â Â Â Â Â Â frequencySelect.addEventListener("change", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const selectedFrequency = frequencySelect.value;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const frequencyMap = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hourly: document.getElementById("hourly-options"),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â daily: document.getElementById("daily-options"),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â weekly: document.getElementById("weekly-options"),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â biweekly: document.getElementById("biweekly-options"),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â monthly: document.getElementById("monthly-options"),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â yearly: document.getElementById("yearly-options")
Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Object.values(frequencyMap).forEach(section => section?.classList.add("hidden"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â frequencyMap[selectedFrequency]?.classList.remove("hidden");
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â updateRecurringSummary();
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â // Rest of the setup code remains the same...
Â Â Â Â Â Â const toggleVisibility = (triggerId, contentId) => {
Â Â Â Â Â Â Â Â Â Â const trigger = document.getElementById(triggerId);
Â Â Â Â Â Â Â Â Â Â const content = document.getElementById(contentId);
Â Â Â Â Â Â Â Â Â Â if (trigger && content) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â trigger.addEventListener("change", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â content.classList.toggle("hidden", !trigger.checked);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â };
Â Â 
Â Â Â Â Â Â toggleVisibility("hourly-specific-time", "hourly-minute-container");
Â Â Â Â Â Â toggleVisibility("daily-specific-time", "daily-time-container");
Â Â Â Â Â Â toggleVisibility("weekly-specific-days", "weekly-day-container");
Â Â Â Â Â Â toggleVisibility("weekly-specific-time", "weekly-time-container");
Â Â Â Â Â Â toggleVisibility("biweekly-specific-days", "biweekly-day-container");
Â Â Â Â Â Â toggleVisibility("biweekly-specific-time", "biweekly-time-container");
Â Â Â Â Â Â toggleVisibility("monthly-specific-days", "monthly-day-container");
Â Â Â Â Â Â toggleVisibility("monthly-specific-time", "monthly-time-container");
Â Â Â Â Â Â toggleVisibility("yearly-specific-months", "yearly-month-container");
Â Â Â Â Â Â toggleVisibility("yearly-specific-time", "yearly-time-container");
Â Â 
Â Â Â Â Â Â const yearlySpecificDaysCheckbox = document.getElementById("yearly-specific-days");
Â Â Â Â Â Â const yearlyDayContainer = document.getElementById("yearly-day-container");
Â Â Â Â Â Â const yearlyMonthSelect = document.getElementById("yearly-month-select");
Â Â 
Â Â Â Â Â Â if (yearlySpecificDaysCheckbox && yearlyDayContainer) {
Â Â Â Â Â Â Â Â Â Â yearlySpecificDaysCheckbox.addEventListener("change", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const hasMonthSelected = getSelectedYearlyMonths().length > 0;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â yearlyDayContainer.classList.toggle("hidden", !yearlySpecificDaysCheckbox.checked || !hasMonthSelected);
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "specific-date-hour", minuteInputId: "specific-date-minute", meridiemSelectId: "specific-date-meridiem", militaryCheckboxId: "specific-date-military" });
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "daily-hour", minuteInputId: "daily-minute", meridiemSelectId: "daily-meridiem", militaryCheckboxId: "daily-military" });
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "weekly-hour", minuteInputId: "weekly-minute", meridiemSelectId: "weekly-meridiem", militaryCheckboxId: "weekly-military" });
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "biweekly-hour", minuteInputId: "biweekly-minute", meridiemSelectId: "biweekly-meridiem", militaryCheckboxId: "biweekly-military" });
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "monthly-hour", minuteInputId: "monthly-minute", meridiemSelectId: "monthly-meridiem", militaryCheckboxId: "monthly-military" });
Â Â Â Â Â Â setupTimeConversion({ hourInputId: "yearly-hour", minuteInputId: "yearly-minute", meridiemSelectId: "yearly-meridiem", militaryCheckboxId: "yearly-military" });
Â Â 
Â Â Â Â Â Â setupMilitaryTimeToggle("daily");
Â Â Â Â Â Â setupMilitaryTimeToggle("weekly");
Â Â Â Â Â Â setupMilitaryTimeToggle("biweekly");
Â Â Â Â Â Â setupMilitaryTimeToggle("monthly");
Â Â Â Â Â Â setupMilitaryTimeToggle("yearly");
Â Â 
Â Â Â Â Â Â setupWeeklyDayToggle();
Â Â Â Â Â Â generateMonthlyDayGrid();
Â Â Â Â Â Â generateYearlyMonthGrid();
Â Â 
Â Â Â Â Â Â if (yearlyMonthSelect) {
Â Â Â Â Â Â Â Â Â Â yearlyMonthSelect.addEventListener("change", (e) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const selectedMonth = parseInt(e.target.value);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â generateYearlyDayGrid(selectedMonth);
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â generateYearlyDayGrid(1);
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â yearlyApplyToAllCheckbox?.addEventListener("change", handleYearlyApplyToAllChange);
Â Â Â Â Â Â setupSpecificDatesPanel();
Â Â Â Â Â Â updateRecurringSummary();
Â Â }

// Define the helper first
function setAdvancedVisibility(visible, toggleBtn) {
Â Â Â Â advancedVisible = visible;
Â Â Â Â toggleBtn.textContent = visible ? "Hide Advanced Options" : "Show Advanced Options";
Â Â 
Â Â Â Â // Show/hide all `.frequency-options` panels
Â Â Â Â document.querySelectorAll(".frequency-options").forEach(option => {
Â Â Â Â Â Â option.style.display = visible ? "block" : "none";
Â Â Â Â });
Â Â 
Â Â Â Â // Always show frequency dropdown container
Â Â Â Â const frequencyContainer = document.getElementById("recur-frequency-container");
Â Â Â Â if (frequencyContainer) frequencyContainer.style.display = "block";
Â Â 
Â Â Â Â // Handle extras like 'Recur indefinitely' and 'Specific Dates'
Â Â Â Â const advancedControls = [
Â Â Â Â Â Â Â Â { checkboxId: "recur-indefinitely" },
Â Â Â Â Â Â Â Â { checkboxId: "recur-specific-dates" }
Â Â Â Â Â Â ];


Â Â Â Â advancedControls.forEach(({ checkboxId, panelId }) => {
Â Â Â Â Â Â const checkbox = document.getElementById(checkboxId);
Â Â Â Â Â Â if (!checkbox) return;
Â Â 
Â Â Â Â Â Â const label = checkbox.closest("label");
Â Â Â Â Â Â if (label) {
Â Â Â Â Â Â Â Â label.style.display = visible ? "flex" : "none";
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â const defaultBoxContainer = document.getElementById("set-default-recurring-container");
Â Â Â Â if (defaultBoxContainer) {
Â Â Â Â Â Â defaultBoxContainer.style.display = visible ? "block" : "none";
Â Â Â Â }

Â Â }

function updateRecurringPanel(currentCycleData = null) {
Â Â Â Â console.log('ğŸ”„ Updating recurring panel (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const recurringList = document.getElementById("recurring-task-list");
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = window.loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateRecurringPanel');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â let cycleData = currentCycleData;
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â cycleData = cycles[activeCycle];
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No cycle data found for recurring panel');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Processing recurring templates:', Object.keys(cycleData.recurringTemplates || {}).length);
Â Â Â Â 
Â Â Â Â const templateTasks = Object.values(cycleData.recurringTemplates || {});
Â Â Â Â const recurringTasks = templateTasks.map(template => {
Â Â Â Â Â Â Â Â const existingTask = cycleData.tasks.find(t => t.id === template.id);
Â Â Â Â Â Â Â Â return existingTask || template;
Â Â Â Â });

Â Â Â Â recurringList.innerHTML = "";

Â Â Â Â if (recurringTasks.length === 0) {
Â Â Â Â Â Â Â Â console.log('ğŸ“‹ No recurring tasks found, hiding panel');
Â Â Â Â Â Â Â Â document.getElementById("recurring-panel-overlay")?.classList.add("hidden");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â document.querySelectorAll(".recurring-task-item").forEach(el => {
Â Â Â Â Â Â Â Â el.classList.remove("selected");
Â Â Â Â });

Â Â Â Â recurringTasks.forEach(task => {
Â Â Â Â Â Â Â Â if (!task || !task.id || !task.text) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn("âš  Skipping malformed recurring task in panel:", task);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const item = document.createElement("li");
Â Â Â Â Â Â Â Â item.className = "recurring-task-item";
Â Â Â Â Â Â Â Â item.setAttribute("data-task-id", task.id);

Â Â Â Â Â Â Â Â item.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â <input type="checkbox"Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â class="recurring-check"Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id="recurring-check-${task.id}"Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â name="recurring-check-${task.id}"Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â aria-label="Mark this task temporarily">
Â Â Â Â Â Â Â Â Â Â Â Â <span class="recurring-task-text">${task.text}</span>
Â Â Â Â Â Â Â Â Â Â Â Â <button title="Remove from Recurring" class="recurring-remove-btn">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â <i class='fas fa-trash recurring-trash-icon'></i>
Â Â Â Â Â Â Â Â Â Â Â Â </button>
Â Â Â Â Â Â Â Â `;

Â Â Â Â Â Â Â Â const checkbox = item.querySelector(".recurring-check");
Â Â Â Â Â Â Â Â checkbox.addEventListener("click", (e) => {
Â Â Â Â Â Â Â Â Â Â Â Â e.stopPropagation();
Â Â Â Â Â Â Â Â Â Â Â Â item.classList.toggle("checked");
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â checkbox.classList.add("hidden");

Â Â Â Â Â Â Â Â // âœ… Handle remove button with Schema 2.5 only
Â Â Â Â Â Â Â Â item.querySelector("button").addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â showConfirmationModal({
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "Remove Recurring Task",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: `Are you sure you want to remove "${task.text}" from recurring tasks?`,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Remove",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmed) return;

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = window.loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for task removal');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove recurrence from the live task
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const liveTask = currentCycle.tasks.find(t => t.id === task.id);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (liveTask) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â liveTask.recurring = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â delete liveTask.recurringSettings;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Delete from recurringTemplates
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â delete currentCycle.recurringTemplates[task.id];

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("â†©ï¸ Recurring turned off for this task.", "info", 5000);

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove recurring visual state
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const matchingTaskItem = document.querySelector(`.task[data-task-id="${task.id}"]`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (matchingTaskItem) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const recurringBtn = matchingTaskItem.querySelector(".recurring-btn");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (recurringBtn) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringBtn.classList.remove("active");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringBtn.setAttribute("aria-pressed", "false");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringBtn.disabled = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â matchingTaskItem.classList.remove("recurring");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â matchingTaskItem.removeAttribute("data-recurring-settings");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â item.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringPanelButtonVisibility();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const remaining = Object.values(currentCycle.recurringTemplates || {});
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (remaining.length === 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("recurring-panel-overlay")?.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("undo-btn").hidden = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("redo-btn").hidden = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â // âœ… Handle task row selection for preview
Â Â Â Â Â Â Â Â item.addEventListener("click", (e) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â e.target.closest(".recurring-remove-btn") ||
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â e.target.closest("input[type='checkbox']")
Â Â Â Â Â Â Â Â Â Â Â Â ) return;

Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".recurring-task-item").forEach(el => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â el.classList.remove("selected");
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â item.classList.add("selected");

Â Â Â Â Â Â Â Â Â Â Â Â const taskId = item.dataset.taskId;
Â Â Â Â Â Â Â Â Â Â Â Â const fullTask = cycleData.tasks.find(t => t.id === taskId) || task;
Â Â Â Â Â Â Â Â Â Â Â Â showTaskSummaryPreview(fullTask);
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â recurringList.appendChild(item);
Â Â Â Â });

Â Â Â Â updateRecurringSummary();
Â Â Â Â console.log('âœ… Recurring panel updated successfully');
}

// Make updateRecurringPanel globally accessible for the notification module
window.updateRecurringPanel = updateRecurringPanel;
Â Â 
Â Â function openRecurringSettingsPanelForTask(taskIdToPreselect) {
Â Â Â Â Â Â console.log('âš™ï¸ Opening recurring settings panel (Schema 2.5 only)...', taskIdToPreselect);
Â Â Â Â Â Â 
Â Â Â Â Â Â updateRecurringPanel(); // Render panel fresh
Â Â 
Â Â Â Â Â Â // Find and preselect the correct task
Â Â Â Â Â Â const itemToSelect = document.querySelector(`.recurring-task-item[data-task-id="${taskIdToPreselect}"]`);
Â Â Â Â Â Â if (itemToSelect) {
Â Â Â Â Â Â Â Â Â Â itemToSelect.classList.add("selected");
Â Â 
Â Â Â Â Â Â Â Â Â Â const checkbox = itemToSelect.querySelector("input[type='checkbox']");
Â Â Â Â Â Â Â Â Â Â if (checkbox) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkbox.checked = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â itemToSelect.classList.add("checked");
Â Â Â Â Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â Â Â Â Â // âœ… Update the preview with Schema 2.5 only
Â Â Â Â Â Â Â Â Â Â const schemaData = window.loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for task preview');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â const task = cycles[activeCycle]?.tasks.find(t => t.id === taskIdToPreselect);
Â Â Â Â Â Â Â Â Â Â if (task) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â showTaskSummaryPreview(task);
Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Task not found for preview:', taskIdToPreselect);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â // Show panel
Â Â Â Â Â Â document.getElementById("recurring-panel-overlay")?.classList.remove("hidden");
Â Â 
Â Â Â Â Â Â // Make sure checkboxes and toggle show correctly
Â Â Â Â Â Â updateRecurringSettingsVisibility();
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log('âœ… Recurring settings panel opened successfully');
Â Â }



Â Â function updateRecurringSettingsVisibility() {
Â Â Â Â const anySelected = document.querySelector(".recurring-task-item.selected");
Â Â Â Â const settingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â const checkboxes = document.querySelectorAll(".recurring-check");
Â Â Â Â const changeBtns = document.querySelectorAll(".change-recurring-btn");
Â Â Â Â const toggleContainer = document.getElementById("recurring-toggle-actions");
Â Â Â Â const toggleBtn = document.getElementById("toggle-check-all");
Â Â Â Â const taskCount = document.querySelectorAll(".recurring-task-item").length;
Â Â 
Â Â Â Â const show = !!anySelected;
Â Â 
Â Â Â Â if (settingsPanel) {
Â Â Â Â Â Â settingsPanel.classList.toggle("hidden", !show);
Â Â 
Â Â Â Â Â Â // Show or hide checkboxes
Â Â Â Â Â Â checkboxes.forEach(box => {
Â Â Â Â Â Â Â Â box.classList.toggle("hidden", !show);
Â Â Â Â Â Â });
Â Â 
Â Â Â Â Â Â // Hide change buttons when panel is open
Â Â Â Â Â Â changeBtns.forEach(btn => {
Â Â Â Â Â Â Â Â btn.classList.toggle("hidden", show);
Â Â Â Â Â Â });
Â Â Â Â }
Â Â 
Â Â Â Â // âœ… Only show toggle if panel is open AND checkboxes are visible AND more than one task
Â Â Â Â const checkboxesVisible = Array.from(checkboxes).some(cb => !cb.classList.contains("hidden"));
Â Â Â Â const shouldShowToggle = show && taskCount > 1 && checkboxesVisible;
Â Â Â Â toggleContainer?.classList.toggle("hidden", !shouldShowToggle);
Â Â 
Â Â Â Â // Update button label (optional)
Â Â Â Â if (toggleBtn && shouldShowToggle) {
Â Â Â Â Â Â const anyUnchecked = Array.from(checkboxes).some(cb => !cb.checked && !cb.classList.contains("hidden"));
Â Â Â Â Â Â toggleBtn.textContent = anyUnchecked ? "Check All" : "Uncheck All";
Â Â Â Â }
Â Â 
Â Â Â Â updateRecurringSummary();
Â Â }

Â Â document.getElementById("toggle-check-all").addEventListener("click", () => {
Â Â Â Â const checkboxes = document.querySelectorAll(".recurring-check:not(.hidden)");
Â Â Â Â const anyUnchecked = Array.from(checkboxes).some(cb => !cb.checked);
Â Â 
Â Â Â Â checkboxes.forEach(cb => {
Â Â Â Â Â Â cb.checked = anyUnchecked;
Â Â Â Â Â Â cb.closest(".recurring-task-item").classList.toggle("checked", anyUnchecked);
Â Â Â Â });
Â Â 
Â Â Â Â // ğŸ” Update the label based on what you just did
Â Â Â Â const toggleCheckAllBtn = document.getElementById("toggle-check-all");
Â Â Â Â toggleCheckAllBtn.textContent = anyUnchecked ? "Uncheck All" : "Check All";
Â Â 
Â Â Â Â updateRecurringSummary();
Â Â });
Â Â 
Â Â function loadRecurringSettingsForTask(task) {
Â Â Â Â if (!task) return;
Â Â 
Â Â Â Â const freqSelect = document.getElementById("recur-frequency");
Â Â Â Â const recurCheckbox = document.getElementById("recur-indefinitely");
Â Â Â Â const recurCountInput = document.getElementById("recur-count-input");
Â Â Â Â const countContainer = document.getElementById("recur-count-container");
Â Â 
Â Â Â Â if (freqSelect && task.recurFrequency) {
Â Â Â Â Â Â Â Â freqSelect.value = task.recurFrequency;
Â Â Â Â Â Â Â Â const changeEvent = new Event("change");
Â Â Â Â Â Â Â Â freqSelect.dispatchEvent(changeEvent);
Â Â Â Â Â Â }
Â Â 
Â Â Â Â if (recurCheckbox) {
Â Â Â Â Â Â recurCheckbox.checked = task.recurIndefinitely ?? true;
Â Â Â Â }
Â Â 
Â Â Â Â if (recurCountInput && task.recurCount != null) {
Â Â Â Â Â Â recurCountInput.value = task.recurCount;
Â Â Â Â }
Â Â Â Â updateRecurCountVisibility();
Â Â Â Â updateRecurringSummary();
Â Â }






Â Â document.getElementById("specific-date-specific-time").addEventListener("change", (e) => {
Â Â Â Â const timeContainer = document.getElementById("specific-date-time-container");
Â Â Â Â timeContainer.classList.toggle("hidden", !e.target.checked);
Â Â Â Â updateRecurringSummary();
Â Â });
Â Â 







Â Â 

Â Â function saveRecurringTemplate(task, cycleName, savedMiniCycles) {
Â Â Â Â Â Â console.log('ğŸ’¾ Saving recurring template (Schema 2.5 only)...');
Â Â Â Â Â Â 
Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveRecurringTemplate');
Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â 
Â Â Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â Â Â console.error(`âŒ Cannot save recurring template. Active cycle not found.`);
Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â if (!currentCycle.recurringTemplates) {
Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates = {};
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â console.log('ğŸ“Š Saving template for task:', task.id);
Â Â 
Â Â Â Â Â Â currentCycle.recurringTemplates[task.id] = {
Â Â Â Â Â Â Â Â Â Â id: task.id,
Â Â Â Â Â Â Â Â Â Â text: task.text,
Â Â Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â Â Â recurringSettings: task.recurringSettings,
Â Â Â Â Â Â Â Â Â Â highPriority: task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â dueDate: task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â lastTriggeredTimestamp: null,
Â Â Â Â Â Â Â Â Â Â schemaVersion: task.schemaVersion || 2
Â Â Â Â Â Â };
Â Â 
Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â 
Â Â Â Â Â Â console.log('âœ… Recurring template saved to Schema 2.5');
Â Â }
function deleteRecurringTemplate(taskId, cycleName) {
Â Â Â Â console.log('ğŸ—‘ï¸ Deleting recurring template (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for deleteRecurringTemplate');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â console.error(`âŒ Active cycle not found for deleteRecurringTemplate.`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â if (!currentCycle.recurringTemplates || !currentCycle.recurringTemplates[taskId]) {
Â Â Â Â Â Â Â Â console.warn(`âš  Task "${taskId}" not found in recurring templates.`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ” Deleting template for task:', taskId);

Â Â Â Â // Delete the task template
Â Â Â Â delete currentCycle.recurringTemplates[taskId];

Â Â Â Â // Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring template deleted from Schema 2.5');
}

function saveAlwaysShowRecurringSetting() {
Â Â Â Â console.log('ğŸ’¾ Saving always show recurring setting (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const alwaysShow = document.getElementById("always-show-recurring").checked;
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveAlwaysShowRecurringSetting');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.settings.alwaysShowRecurring = alwaysShow;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Always show recurring setting saved to Schema 2.5:', alwaysShow);
Â Â Â Â 
Â Â Â Â refreshTaskListUI();
Â Â Â Â updateRecurringButtonVisibility();
}

function loadAlwaysShowRecurringSetting() {
Â Â Â Â console.log('ğŸ“¥ Loading always show recurring setting (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for loadAlwaysShowRecurringSetting');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const isEnabled = schemaData.settings.alwaysShowRecurring || false;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Loaded always show recurring setting:', isEnabled);
Â Â Â Â 
Â Â Â Â document.getElementById("always-show-recurring").checked = isEnabled;
}

document.getElementById("always-show-recurring").addEventListener("change", saveAlwaysShowRecurringSetting);

document.getElementById("apply-recurring-settings")?.addEventListener("click", () => {
Â Â Â Â console.log('ğŸ“ Applying recurring settings (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for apply recurring settings');
Â Â Â Â Â Â Â Â showNotification("âŒ Schema 2.5 data required.", "error");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycleData) {
Â Â Â Â Â Â Â Â showNotification("âš  No active cycle found.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const checkedEls = document.querySelectorAll(".recurring-check:checked");

Â Â Â Â if (!checkedEls.length) {
Â Â Â Â Â Â Â Â showNotification("âš  No tasks checked to apply settings.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const settings = normalizeRecurringSettings(buildRecurringSettingsFromPanel());

Â Â Â Â // ğŸ•’ Set defaultRecurTime if not using specific time
Â Â Â Â if (!settings.specificTime && !settings.defaultRecurTime) {
Â Â Â Â Â Â Â Â settings.defaultRecurTime = new Date().toISOString();
Â Â Â Â }

Â Â Â Â // ğŸ’¾ Save default recurring settings if requested
Â Â Â Â if (document.getElementById("set-default-recurring")?.checked) {
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.defaultRecurringSettings = settings;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â showNotification("âœ… Default recurring settings saved!", "success", 1500);
Â Â Â Â }

Â Â Â Â if (!cycleData.recurringTemplates) {
Â Â Â Â Â Â Â Â cycleData.recurringTemplates = {};
Â Â Â Â }

Â Â Â Â checkedEls.forEach(checkbox => {
Â Â Â Â Â Â Â Â const taskEl = checkbox.closest("[data-task-id]");
Â Â Â Â Â Â Â Â const taskId = taskEl?.dataset.taskId;
Â Â Â Â Â Â Â Â if (!taskId || !taskEl) return;

Â Â Â Â Â Â Â Â let task = cycleData.tasks.find(t => t.id === taskId);
Â Â Â Â Â Â Â Â if (!task) {
Â Â Â Â Â Â Â Â Â Â Â Â task = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: taskId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: taskEl.querySelector(".recurring-task-text")?.textContent || "Untitled Task",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings: structuredClone(settings),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… Apply recurring settings to task
Â Â Â Â Â Â Â Â task.recurring = true;
Â Â Â Â Â Â Â Â task.schemaVersion = 2;
Â Â Â Â Â Â Â Â task.recurringSettings = structuredClone(settings);

Â Â Â Â Â Â Â Â // âœ… Update recurringTemplates
Â Â Â Â Â Â Â Â cycleData.recurringTemplates[task.id] = {
Â Â Â Â Â Â Â Â Â Â Â Â id: task.id,
Â Â Â Â Â Â Â Â Â Â Â Â text: task.text,
Â Â Â Â Â Â Â Â Â Â Â Â dueDate: task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â Â Â highPriority: task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings: structuredClone(settings),
Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â };

Â Â Â Â Â Â Â Â // âœ… Update DOM
Â Â Â Â Â Â Â Â taskEl.classList.add("recurring");
Â Â Â Â Â Â Â Â taskEl.setAttribute("data-recurring-settings", JSON.stringify(settings));
Â Â Â Â Â Â Â Â const recurringBtn = taskEl.querySelector(".recurring-btn");
Â Â Â Â Â Â Â Â if (recurringBtn) {
Â Â Â Â Â Â Â Â Â Â Â Â recurringBtn.classList.add("active");
Â Â Â Â Â Â Â Â Â Â Â Â recurringBtn.setAttribute("aria-pressed", "true");
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â syncRecurringStateToDOM(taskEl, settings);
Â Â Â Â });

Â Â Â Â // âœ… Save to Schema 2.5
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â updateRecurringSummary();
Â Â Â Â showNotification("âœ… Recurring settings applied!", "success", 2000);
Â Â Â Â updateRecurringPanel();

Â Â Â Â // âœ… Clean up UI state - remove selections and hide panels
Â Â Â Â document.querySelectorAll(".recurring-task-item").forEach(el => {
Â Â Â Â Â Â Â Â el.classList.remove("selected", "checked");
Â Â Â Â });

Â Â Â Â const settingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â settingsPanel?.classList.add("hidden");

Â Â Â Â // âœ… Explicitly hide checkboxes and toggle container
Â Â Â Â document.querySelectorAll(".recurring-check").forEach(cb => {
Â Â Â Â Â Â Â Â cb.classList.add("hidden");
Â Â Â Â Â Â Â Â cb.checked = false;
Â Â Â Â });

Â Â Â Â const toggleContainer = document.getElementById("recurring-toggle-actions");
Â Â Â Â toggleContainer?.classList.add("hidden");

Â Â Â Â const preview = document.getElementById("recurring-summary-preview");
Â Â Â Â if (preview) preview.classList.add("hidden");

Â Â Â Â updateRecurringPanelButtonVisibility();
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring settings applied successfully');
});
Â Â 


Â Â function normalizeRecurringSettings(settings = {}) {
Â Â Â Â return {
Â Â Â Â Â Â frequency: settings.frequency || "daily",
Â Â Â Â Â Â indefinitely: settings.indefinitely !== false,
Â Â Â Â Â Â count: settings.count ?? null,
Â Â Â Â Â Â time: settings.time || null,
Â Â 
Â Â Â Â Â Â specificDates: {
Â Â Â Â Â Â Â Â enabled: settings.specificDates?.enabled || false,
Â Â Â Â Â Â Â Â dates: Array.isArray(settings.specificDates?.dates) ? settings.specificDates.dates : []
Â Â Â Â Â Â },
Â Â 
Â Â Â Â Â Â hourly: {
Â Â Â Â Â Â Â Â useSpecificMinute: settings.hourly?.useSpecificMinute || false,
Â Â Â Â Â Â Â Â minute: settings.hourly?.minute || 0
Â Â Â Â Â Â },
Â Â 
Â Â Â Â Â Â weekly: {
Â Â Â Â Â Â Â Â days: Array.isArray(settings.weekly?.days) ? settings.weekly.days : []
Â Â Â Â Â Â },
Â Â 
Â Â Â Â Â Â biweekly: {
Â Â Â Â Â Â Â Â days: Array.isArray(settings.biweekly?.days) ? settings.biweekly.days : []
Â Â Â Â Â Â },
Â Â 
Â Â Â Â Â Â monthly: {
Â Â Â Â Â Â Â Â days: Array.isArray(settings.monthly?.days) ? settings.monthly.days : []
Â Â Â Â Â Â },
Â Â 
Â Â Â Â Â Â yearly: {
Â Â Â Â Â Â Â Â months: Array.isArray(settings.yearly?.months) ? settings.yearly.months : [],
Â Â Â Â Â Â Â Â useSpecificDays: settings.yearly?.useSpecificDays || false,
Â Â Â Â Â Â Â Â applyDaysToAll: settings.yearly?.applyDaysToAll !== false, // default is true
Â Â Â Â Â Â Â Â daysByMonth: settings.yearly?.daysByMonth || {}
Â Â Â Â Â Â }
Â Â Â Â };
Â Â }

Â Â function buildRecurringSettingsFromPanel() {
Â Â Â Â const frequency = document.getElementById("recur-frequency").value;
Â Â Â Â const indefinitely = document.getElementById("recur-indefinitely").checked;
Â Â Â Â const count = indefinitely ? null : parseInt(document.getElementById("recur-count-input").value) || 1;
Â Â Â Â const settings = {
Â Â Â Â Â Â frequency,
Â Â Â Â Â Â indefinitely,
Â Â Â Â Â Â count,
Â Â Â Â Â Â useSpecificTime: false,
Â Â Â Â Â Â time: null,
Â Â Â Â Â Â specificDates: {
Â Â Â Â Â Â Â Â enabled: false,
Â Â Â Â Â Â Â Â dates: []
Â Â Â Â Â Â },
Â Â Â Â Â Â daily: {},
Â Â Â Â Â Â hourly: {},
Â Â Â Â Â Â weekly: {},
Â Â Â Â Â Â biweekly: {},
Â Â Â Â Â Â monthly: {},
Â Â Â Â Â Â yearly: {}
Â Â Â Â };
Â Â 
Â Â Â Â // âœ… Specific Dates Mode
Â Â Â Â if (document.getElementById("recur-specific-dates").checked) {
Â Â Â Â Â Â const dateInputs = document.querySelectorAll("#specific-date-list input[type='date']");
Â Â Â Â Â Â settings.specificDates.enabled = true;
Â Â Â Â Â Â settings.specificDates.dates = Array.from(dateInputs).map(input => input.value).filter(Boolean);
Â Â 
Â Â Â Â Â Â if (document.getElementById("specific-date-specific-time").checked) {
Â Â Â Â Â Â Â Â settings.useSpecificTime = true;
Â Â Â Â Â Â Â Â settings.time = {
Â Â Â Â Â Â Â Â Â Â hour: parseInt(document.getElementById("specific-date-hour").value) || 0,
Â Â Â Â Â Â Â Â Â Â minute: parseInt(document.getElementById("specific-date-minute").value) || 0,
Â Â Â Â Â Â Â Â Â Â meridiem: document.getElementById("specific-date-meridiem").value,
Â Â Â Â Â Â Â Â Â Â military: document.getElementById("specific-date-military").checked
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â // âœ… Time block for non-specific-dates
Â Â Â Â Â Â const timeId = frequency;
Â Â Â Â Â Â const timeEnabled = document.getElementById(`${timeId}-specific-time`)?.checked;
Â Â 
// âœ… Time block for non-specific-dates â€” EXCLUDE hourly!
if (frequency !== "hourly" && timeEnabled) {
Â Â settings.useSpecificTime = true;
Â Â settings.time = {
Â Â Â Â hour: parseInt(document.getElementById(`${timeId}-hour`).value) || 0,
Â Â Â Â minute: parseInt(document.getElementById(`${timeId}-minute`).value) || 0,
Â Â Â Â meridiem: document.getElementById(`${timeId}-meridiem`).value,
Â Â Â Â military: document.getElementById(`${timeId}-military`).checked
Â Â };
}
Â Â 
Â Â Â Â Â Â // âœ… Hourly Specific Minute
Â Â Â Â Â Â if (frequency === "hourly") {
Â Â Â Â Â Â Â Â const useSpecificMinute = document.getElementById("hourly-specific-time")?.checked;
Â Â Â Â Â Â Â Â const minuteEl = document.getElementById("hourly-minute");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â settings.hourly = {
Â Â Â Â Â Â Â Â Â Â useSpecificMinute: !!useSpecificMinute,
Â Â Â Â Â Â Â Â Â Â minute: useSpecificMinute && minuteEl ? parseInt(minuteEl.value) || 0 : 0
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â // âœ… Weekly & Biweekly
Â Â Â Â Â Â if (frequency === "weekly" || frequency === "biweekly") {
Â Â Â Â Â Â Â Â const selector = `.${frequency}-day-box.selected`;
Â Â Â Â Â Â Â Â settings[frequency] = {
Â Â Â Â Â Â Â Â Â Â useSpecificDays: document.getElementById(`${frequency}-specific-days`)?.checked,
Â Â Â Â Â Â Â Â Â Â days: Array.from(document.querySelectorAll(selector)).map(el => el.dataset.day)
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â // âœ… Monthly
Â Â Â Â Â Â if (frequency === "monthly") {
Â Â Â Â Â Â Â Â settings.monthly = {
Â Â Â Â Â Â Â Â Â Â useSpecificDays: document.getElementById("monthly-specific-days")?.checked,
Â Â Â Â Â Â Â Â Â Â days: Array.from(document.querySelectorAll(".monthly-day-box.selected")).map(el => parseInt(el.dataset.day))
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â // âœ… Yearly
Â Â Â Â Â Â if (frequency === "yearly") {
Â Â Â Â Â Â Â Â const applyAll = document.getElementById("yearly-apply-days-to-all")?.checked;
Â Â Â Â Â Â Â Â const useMonths = document.getElementById("yearly-specific-months")?.checked;
Â Â Â Â Â Â Â Â const useDays = document.getElementById("yearly-specific-days")?.checked;
Â Â 
Â Â Â Â Â Â Â Â settings.yearly = {
Â Â Â Â Â Â Â Â Â Â useSpecificMonths: useMonths,
Â Â Â Â Â Â Â Â Â Â months: getSelectedYearlyMonths(),
Â Â Â Â Â Â Â Â Â Â useSpecificDays: useDays,
Â Â Â Â Â Â Â Â Â Â daysByMonth: applyAll ? { all: selectedYearlyDays["all"] || [] } : { ...selectedYearlyDays },
Â Â Â Â Â Â Â Â Â Â applyDaysToAll: applyAll
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }
Â Â Â Â }
Â Â 
Â Â Â Â return settings;
Â Â }
Â Â 

function clearNonRelevantRecurringFields(task, frequency) {
Â Â const allowedFields = {
Â Â Â Â daily: ["dailyTime"],
Â Â Â Â weekly: ["weeklyDays"],
Â Â Â Â biweekly: ["biweeklyDays"],
Â Â Â Â monthly: ["monthlyDays"],
Â Â Â Â yearly: ["yearlyMonths", "yearlyDates"],
Â Â Â Â hourly: [],
Â Â };

Â Â const allExtraFields = [
Â Â Â Â "specificDates", "specificTime",
Â Â Â Â "dailyTime", "weeklyDays", "biweeklyDays", "monthlyDays",
Â Â Â Â "yearlyMonths", "yearlyDates"
Â Â ];

Â Â const keep = allowedFields[frequency] || [];
Â Â task.recurringSettings = Object.fromEntries(
Â Â Â Â Object.entries(task.recurringSettings).filter(([key]) =>
Â Â Â Â Â Â ["frequency", "count", "indefinitely", ...keep].includes(key)
Â Â Â Â )
Â Â );
}

function syncRecurringStateToDOM(taskEl, recurringSettings) {
Â Â taskEl.setAttribute("data-recurring-settings", JSON.stringify(recurringSettings));
Â Â const recurringBtn = taskEl.querySelector(".recurring-btn");
Â Â if (recurringBtn) {
Â Â Â Â recurringBtn.classList.add("active");
Â Â Â Â recurringBtn.setAttribute("aria-pressed", "true");
Â Â }
}











Â Â const cancelBtn = document.getElementById("cancel-recurring-settings");

Â Â cancelBtn?.addEventListener("click", () => {
Â Â Â Â const settingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â settingsPanel?.classList.add("hidden");
Â Â 
Â Â Â Â // Deselect all selected tasks
Â Â Â Â document.querySelectorAll(".recurring-task-item").forEach(el => {
Â Â Â Â Â Â el.classList.remove("selected");
Â Â Â Â Â Â el.querySelector("input[type='checkbox']").checked = false;
Â Â Â Â });
Â Â 
Â Â Â Â // Hide checkboxes and uncheck them
Â Â Â Â document.querySelectorAll(".recurring-check").forEach(cb => {
Â Â Â Â Â Â cb.checked = false;
Â Â Â Â Â Â cb.classList.add("hidden");
Â Â Â Â Â Â cb.closest(".recurring-task-item")?.classList.remove("checked");
Â Â Â Â });
Â Â 
Â Â Â Â // Hide the summary preview if visible
Â Â Â Â const preview = document.getElementById("recurring-summary-preview");
Â Â Â Â if (preview) preview.classList.add("hidden");
Â Â 
Â Â Â Â updateRecurringSettingsVisibility();
Â Â });





Â Â document.getElementById("recur-indefinitely").addEventListener("change", (e) => {
Â Â Â Â const countContainer = document.getElementById("recur-count-container");
Â Â Â Â const recurCount = document.getElementById("recur-count-input");
Â Â Â Â const hidden = e.target.checked;
Â Â Â Â countContainer.classList.toggle("hidden", hidden);
Â Â Â Â updateRecurCountVisibility();
Â Â Â Â updateRecurringSummary();
Â Â });

Â Â function setupBiweeklyDayToggle() {
Â Â Â Â document.querySelectorAll(".biweekly-day-box").forEach(box => {
Â Â Â Â Â Â box.addEventListener("click", () => {
Â Â Â Â Â Â Â Â box.classList.toggle("selected");
Â Â Â Â Â Â });
Â Â Â Â });
Â Â }

Â Â setupBiweeklyDayToggle();
Â Â document.addEventListener("click", (e) => {
Â Â Â Â const panel = document.getElementById("recurring-panel");
Â Â Â Â const taskList = document.getElementById("recurring-task-list");
Â Â Â Â const settingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â const overlay = document.getElementById("recurring-panel-overlay");
Â Â Â Â const summaryPreview = document.getElementById("recurring-summary-preview");
Â Â 
Â Â Â Â if (!overlay || overlay.classList.contains("hidden")) return;
Â Â 
Â Â Â Â if (taskList.contains(e.target) || settingsPanel.contains(e.target)) return;
Â Â 
Â Â Â Â // ğŸ”½ New block for hiding summary preview
Â Â Â Â if (summaryPreview && !summaryPreview.contains(e.target) && !taskList.contains(e.target)) {
Â Â Â Â Â Â summaryPreview.classList.add("hidden");
Â Â Â Â Â Â document.querySelectorAll(".recurring-task-item").forEach(el => el.classList.remove("selected"));
Â Â Â Â }
Â Â });









Â Â function setupMilitaryTimeToggle(prefix) {
Â Â Â Â const toggle = document.getElementById(`${prefix}-military`);
Â Â Â Â const hourInput = document.getElementById(`${prefix}-hour`);
Â Â Â Â const meridiemSelect = document.getElementById(`${prefix}-meridiem`);
Â Â 
Â Â Â Â // âœ… Add better error handling
Â Â Â Â if (!toggle || !hourInput || !meridiemSelect) {
Â Â Â Â Â Â console.warn(`âš ï¸ Missing elements for military time toggle: ${prefix}`);
Â Â Â Â Â Â return;
Â Â Â Â }
Â Â 
Â Â Â Â toggle.addEventListener("change", () => {
Â Â Â Â Â Â const is24Hour = toggle.checked;
Â Â 
Â Â Â Â Â Â // âœ… Add try-catch for safer property updates
Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â hourInput.min = is24Hour ? 0 : 1;
Â Â Â Â Â Â Â Â hourInput.max = is24Hour ? 23 : 12;
Â Â Â Â Â Â Â Â meridiemSelect.classList.toggle("hidden", is24Hour);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Update summary when time format changes
Â Â Â Â Â Â Â Â if (typeof updateRecurringSummary === 'function') {
Â Â Â Â Â Â Â Â Â Â updateRecurringSummary();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Error updating military time toggle for ${prefix}:`, error);
Â Â Â Â Â Â }
Â Â Â Â });
Â Â }

Â Â function setupTimeConversion({
Â Â Â Â hourInputId,
Â Â Â Â minuteInputId,
Â Â Â Â meridiemSelectId,
Â Â Â Â militaryCheckboxId
Â Â }) {
Â Â Â Â const hourInput = document.getElementById(hourInputId);
Â Â Â Â const minuteInput = document.getElementById(minuteInputId);
Â Â Â Â const meridiemSelect = document.getElementById(meridiemSelectId);
Â Â Â Â const militaryToggle = document.getElementById(militaryCheckboxId);
Â Â 
Â Â Â Â if (!hourInput || !minuteInput || !meridiemSelect || !militaryToggle) return;
Â Â 
Â Â Â Â militaryToggle.addEventListener("change", () => {
Â Â Â Â Â Â const is24Hour = militaryToggle.checked;
Â Â Â Â Â Â let hour = parseInt(hourInput.value) || 0;
Â Â Â Â Â Â let meridiem = meridiemSelect.value;
Â Â 
Â Â Â Â Â Â if (is24Hour) {
Â Â Â Â Â Â Â Â // Convert from 12h to 24h
Â Â Â Â Â Â Â Â if (meridiem === "AM") {
Â Â Â Â Â Â Â Â Â Â hour = hour === 12 ? 0 : hour;
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â hour = hour === 12 ? 12 : hour + 12;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â hourInput.value = hour;
Â Â Â Â Â Â Â Â meridiemSelect.classList.add("hidden");
Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â // Convert from 24h to 12h
Â Â Â Â Â Â Â Â if (hour === 0) {
Â Â Â Â Â Â Â Â Â Â hourInput.value = 12;
Â Â Â Â Â Â Â Â Â Â meridiemSelect.value = "AM";
Â Â Â Â Â Â Â Â } else if (hour < 12) {
Â Â Â Â Â Â Â Â Â Â hourInput.value = hour;
Â Â Â Â Â Â Â Â Â Â meridiemSelect.value = "AM";
Â Â Â Â Â Â Â Â } else if (hour === 12) {
Â Â Â Â Â Â Â Â Â Â hourInput.value = 12;
Â Â Â Â Â Â Â Â Â Â meridiemSelect.value = "PM";
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â hourInput.value = hour - 12;
Â Â Â Â Â Â Â Â Â Â meridiemSelect.value = "PM";
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â meridiemSelect.classList.remove("hidden");
Â Â Â Â Â Â }
Â Â Â Â });
Â Â }






Â Â function generateMonthlyDayGrid() {
Â Â Â Â const container = document.querySelector(".monthly-days");
Â Â Â Â if (!container) return;
Â Â 
Â Â Â Â container.innerHTML = "";
Â Â 
Â Â Â Â for (let i = 1; i <= 31; i++) {
Â Â Â Â Â Â const dayBox = document.createElement("div");
Â Â Â Â Â Â dayBox.className = "monthly-day-box";
Â Â Â Â Â Â dayBox.setAttribute("data-day", i);
Â Â Â Â Â Â dayBox.textContent = i;
Â Â 
Â Â Â Â Â Â // Toggle selection on click
Â Â Â Â Â Â dayBox.addEventListener("click", () => {
Â Â Â Â Â Â Â Â dayBox.classList.toggle("selected");
Â Â Â Â Â Â });
Â Â 
Â Â Â Â Â Â container.appendChild(dayBox);
Â Â Â Â }
Â Â }

Â Â 

Â Â function setupWeeklyDayToggle() {
Â Â Â Â document.querySelectorAll(".weekly-day-box").forEach(box => {
Â Â Â Â Â Â box.addEventListener("click", () => {
Â Â Â Â Â Â Â Â box.classList.toggle("selected");
Â Â Â Â Â Â });
Â Â Â Â });
Â Â }



Â Â function generateYearlyMonthGrid() {
Â Â Â Â const container = document.querySelector(".yearly-months");
Â Â Â Â if (!container) return;
Â Â 
Â Â Â Â const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
Â Â 
Â Â Â Â container.innerHTML = "";
Â Â 
Â Â Â Â monthNames.forEach((name, index) => {
Â Â Â Â Â Â const monthBox = document.createElement("div");
Â Â Â Â Â Â monthBox.className = "yearly-month-box";
Â Â Â Â Â Â monthBox.setAttribute("data-month", index + 1);
Â Â Â Â Â Â monthBox.textContent = name;
Â Â 
Â Â Â Â Â Â monthBox.addEventListener("click", () => {
Â Â Â Â Â Â Â Â // Toggle selection
Â Â Â Â Â Â Â Â monthBox.classList.toggle("selected");
Â Â 
Â Â Â Â Â Â Â Â const selectedMonths = getSelectedYearlyMonths();
Â Â 
Â Â Â Â Â Â Â Â // âœ… Reveal or hide the specific-days checkbox label
Â Â Â Â Â Â Â Â const specificDaysLabel = document.getElementById("yearly-specific-days-label");
Â Â Â Â Â Â Â Â if (specificDaysLabel) {
Â Â Â Â Â Â Â Â Â Â specificDaysLabel.classList.toggle("hidden", selectedMonths.length === 0);
Â Â Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â Â Â // Show/hide day container based on selection + checkbox state
Â Â Â Â Â Â Â Â const yearlySpecificDaysCheckbox = document.getElementById("yearly-specific-days");
Â Â Â Â Â Â Â Â const yearlyDayContainer = document.getElementById("yearly-day-container");
Â Â 
Â Â Â Â Â Â Â Â if (yearlySpecificDaysCheckbox && yearlyDayContainer) {
Â Â Â Â Â Â Â Â Â Â const shouldShow = yearlySpecificDaysCheckbox.checked && selectedMonths.length > 0;
Â Â Â Â Â Â Â Â Â Â yearlyDayContainer.classList.toggle("hidden", !shouldShow);
Â Â Â Â Â Â Â Â }
Â Â 
Â Â Â Â Â Â Â Â // Update dropdown
Â Â Â Â Â Â Â Â const yearlyMonthSelect = document.getElementById("yearly-month-select");
Â Â Â Â Â Â Â Â if (yearlyMonthSelect) {
Â Â Â Â Â Â Â Â Â Â yearlyMonthSelect.innerHTML = "";
Â Â 
Â Â Â Â Â Â Â Â Â Â selectedMonths.forEach((monthNum) => {
Â Â Â Â Â Â Â Â Â Â Â Â const option = document.createElement("option");
Â Â Â Â Â Â Â Â Â Â Â Â option.value = monthNum;
Â Â Â Â Â Â Â Â Â Â Â Â option.textContent = new Date(0, monthNum - 1).toLocaleString('default', { month: 'long' });
Â Â Â Â Â Â Â Â Â Â Â Â yearlyMonthSelect.appendChild(option);
Â Â Â Â Â Â Â Â Â Â });
Â Â 
Â Â Â Â Â Â Â Â Â Â if (selectedMonths.length > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â const currentMonth = index + 1;
Â Â Â Â Â Â Â Â Â Â Â Â yearlyMonthSelect.value = currentMonth;
Â Â Â Â Â Â Â Â Â Â Â Â generateYearlyDayGrid(currentMonth);
Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelector(".yearly-days").innerHTML = "";
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â });
Â Â 
Â Â Â Â Â Â container.appendChild(monthBox);
Â Â Â Â });
Â Â }

Â Â 
Â Â function generateYearlyDayGrid(monthNumber) {
Â Â Â Â const container = document.querySelector(".yearly-days");
Â Â Â Â if (!container) return;
Â Â 
Â Â Â Â container.innerHTML = "";
Â Â 
Â Â Â Â const daysInMonth = new Date(2025, monthNumber, 0).getDate();
Â Â Â Â const selectedDays = selectedYearlyDays[monthNumber] || [];
Â Â const applyToAll = yearlyApplyToAllCheckbox?.checked;
const activeMonths = getSelectedYearlyMonths();

// If "apply to all" is checked, use the shared day list
const sharedDays = selectedYearlyDays["all"] || [];

for (let i = 1; i <= daysInMonth; i++) {
Â Â const dayBox = document.createElement("div");
Â Â dayBox.className = "yearly-day-box";
Â Â dayBox.setAttribute("data-day", i);
Â Â dayBox.textContent = i;

Â Â const isSelected = applyToAll
Â Â Â Â ? sharedDays.includes(i)
Â Â Â Â : selectedDays.includes(i);

Â Â if (isSelected) {
Â Â Â Â dayBox.classList.add("selected");
Â Â }

Â Â dayBox.addEventListener("click", () => {
Â Â Â Â dayBox.classList.toggle("selected");
Â Â Â Â const isNowSelected = dayBox.classList.contains("selected");

Â Â Â Â if (applyToAll) {
Â Â Â Â Â Â // Update sharedDays
Â Â Â Â Â Â if (isNowSelected && !sharedDays.includes(i)) {
Â Â Â Â Â Â Â Â sharedDays.push(i);
Â Â Â Â Â Â } else if (!isNowSelected && sharedDays.includes(i)) {
Â Â Â Â Â Â Â Â const idx = sharedDays.indexOf(i);
Â Â Â Â Â Â Â Â sharedDays.splice(idx, 1);
Â Â Â Â Â Â }

Â Â Â Â Â Â selectedYearlyDays["all"] = sharedDays;

Â Â Â Â Â Â // Sync all selected months
Â Â Â Â Â Â activeMonths.forEach(month => {
Â Â Â Â Â Â Â Â selectedYearlyDays[month] = [...sharedDays];
Â Â Â Â Â Â });
Â Â Â Â } else {
Â Â Â Â Â Â // Regular mode, per-month
Â Â Â Â Â Â const current = selectedYearlyDays[monthNumber] || [];
Â Â Â Â Â Â if (isNowSelected && !current.includes(i)) {
Â Â Â Â Â Â Â Â current.push(i);
Â Â Â Â Â Â } else if (!isNowSelected && current.includes(i)) {
Â Â Â Â Â Â Â Â const idx = current.indexOf(i);
Â Â Â Â Â Â Â Â current.splice(idx, 1);
Â Â Â Â Â Â }
Â Â Â Â Â Â selectedYearlyDays[monthNumber] = current;
Â Â Â Â }
Â Â });

Â Â container.appendChild(dayBox);
}

Â Â }
Â Â 
Â Â function handleYearlyApplyToAllChange() {
Â Â Â Â const checkbox = document.getElementById("yearly-apply-days-to-all");
Â Â Â Â const dropdown = document.getElementById("yearly-month-select");
Â Â Â Â const selectedMonths = getSelectedYearlyMonths();
Â Â 
Â Â Â Â if (!checkbox || !dropdown) return;
Â Â 
Â Â Â Â if (checkbox.checked) {
Â Â Â Â Â Â dropdown.classList.add("hidden");
Â Â Â Â Â Â if (selectedMonths.length > 0) {
Â Â Â Â Â Â Â Â generateYearlyDayGrid(selectedMonths[0]); // Use any selected month for grid
Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â dropdown.classList.remove("hidden");
Â Â Â Â Â Â const selectedMonth = parseInt(dropdown.value);
Â Â Â Â Â Â generateYearlyDayGrid(selectedMonth);
Â Â Â Â }
Â Â }


Â Â function getSelectedYearlyMonths() {
Â Â Â Â return Array.from(document.querySelectorAll(".yearly-month-box.selected"))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .map(el => parseInt(el.dataset.month));
Â Â }

Â Â function getSelectedMonthlyDays() {
Â Â Â Â return Array.from(document.querySelectorAll(".monthly-day-box.selected"))
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .map(el => parseInt(el.dataset.day));
Â Â }
Â Â 

function setupSpecificDatesPanel() {
Â Â const checkbox = document.getElementById("recur-specific-dates");
Â Â const panel = document.getElementById("specific-dates-panel");
Â Â const timeOptions = document.getElementById("specific-date-time-options");
Â Â const addBtn = document.getElementById("add-specific-date");
Â Â const list = document.getElementById("specific-date-list");

Â Â // âœ… Add error handling for missing elements
Â Â if (!checkbox || !panel || !timeOptions || !addBtn || !list) {
Â Â Â Â console.warn("âš ï¸ Missing elements for specific dates panel setup");
Â Â Â Â return;
Â Â }

Â Â const createDateInput = (isFirst = false) => {
Â Â Â Â const wrapper = document.createElement("div");
Â Â Â Â wrapper.className = "specific-date-item";

Â Â Â Â const input = document.createElement("input");
Â Â Â Â input.type = "date";
Â Â Â Â const index = list.children.length;
Â Â Â Â input.setAttribute("aria-label", isFirst ? "First specific date" : `Specific date ${index + 1}`);
Â Â Â Â input.required = true;
Â Â Â Â 
Â Â Â Â // âœ… Better error handling for date setting
Â Â Â Â try {
Â Â Â Â Â Â input.valueAsDate = getTomorrow();
Â Â Â Â } catch (error) {
Â Â Â Â Â Â console.warn("âš ï¸ Could not set default date:", error);
Â Â Â Â }

Â Â Â Â if (isFirst) {
Â Â Â Â Â Â Â Â input.classList.add("first-specific-date");
Â Â Â Â }

Â Â Â Â input.addEventListener("change", () => {
Â Â Â Â Â Â if (isFirst && !input.value) {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â input.valueAsDate = getTomorrow();
Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â console.warn("âš ï¸ Could not reset date:", error);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â Â Â updateRecurringSummary(); // âœ… Add this to update summary when date changes
Â Â Â Â });

Â Â Â Â wrapper.appendChild(input);

Â Â Â Â if (!isFirst) {
Â Â Â Â Â Â const trash = document.createElement("button");
Â Â Â Â Â Â trash.type = "button";
Â Â Â Â Â Â trash.className = "trash-btn";
Â Â Â Â Â Â trash.innerHTML = "<i class='fas fa-trash recurring-date-trash-icon'></i>";
Â Â Â Â Â Â trash.title = "Remove this date";

Â Â Â Â Â Â trash.addEventListener("click", () => {
Â Â Â Â Â Â Â Â wrapper.remove();
Â Â Â Â Â Â Â Â updateRecurCountVisibility();
Â Â Â Â Â Â Â Â updateRecurringSummary();
Â Â Â Â Â Â });
Â Â Â Â Â Â wrapper.appendChild(trash);
Â Â Â Â }

Â Â Â Â list.appendChild(wrapper);
Â Â Â Â updateRecurringSummary(); // âœ… Update summary when new date is added
Â Â };

Â Â // Rest of the function remains the same...
Â Â checkbox.addEventListener("change", () => {
Â Â Â Â const shouldShow = checkbox.checked;
Â Â 
Â Â Â Â panel.classList.toggle("hidden", !shouldShow);
Â Â Â Â timeOptions.classList.toggle("hidden", !shouldShow);
Â Â 
Â Â Â Â document.querySelectorAll(".frequency-options").forEach(panel => {
Â Â Â Â Â Â panel.classList.add("hidden");
Â Â Â Â });
Â Â 
Â Â Â Â document.getElementById("recur-frequency-container").classList.toggle("hidden", shouldShow);
Â Â Â Â document.getElementById("recur-indefinitely").closest("label").classList.toggle("hidden", shouldShow);
Â Â 
Â Â Â Â const advancedBtn = document.getElementById("toggle-advanced-settings");
Â Â Â Â if (advancedBtn) {
Â Â Â Â Â Â advancedBtn.classList.toggle("hidden", shouldShow);
Â Â Â Â }
Â Â 
Â Â Â Â if (shouldShow && list.children.length === 0) {
Â Â Â Â Â Â createDateInput(true);
Â Â Â Â }
Â Â 
Â Â Â Â if (!shouldShow) {
Â Â Â Â Â Â document.getElementById("specific-date-specific-time").checked = false;
Â Â Â Â Â Â document.getElementById("specific-date-time-container").classList.add("hidden");
Â Â 
Â Â Â Â Â Â const freqSelect = document.getElementById("recur-frequency");
Â Â Â Â Â Â if (freqSelect) {
Â Â Â Â Â Â Â Â const event = new Event("change");
Â Â Â Â Â Â Â Â freqSelect.dispatchEvent(event);
Â Â Â Â Â Â }
Â Â Â Â }
Â Â 
Â Â Â Â updateRecurCountVisibility();
Â Â Â Â updateRecurringSummary();
Â Â });

Â Â addBtn.addEventListener("click", () => {
Â Â Â Â createDateInput(false);
Â Â });

Â Â updateRecurringSummary();
}
Â Â 
Â Â function getTomorrow() {
Â Â Â Â try {
Â Â Â Â Â Â const tomorrow = new Date();
Â Â Â Â Â Â tomorrow.setDate(tomorrow.getDate() + 1);
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Validate the date is reasonable
Â Â Â Â Â Â if (isNaN(tomorrow.getTime()) || tomorrow.getFullYear() > 2100) {
Â Â Â Â Â Â Â Â throw new Error("Invalid date generated");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â return tomorrow;
Â Â Â Â } catch (error) {
Â Â Â Â Â Â console.warn("âš ï¸ Error generating tomorrow's date:", error);
Â Â Â Â Â Â // âœ… Fallback to a basic future date
Â Â Â Â Â Â const fallback = new Date();
Â Â Â Â Â Â fallback.setDate(fallback.getDate() + 1);
Â Â Â Â Â Â return fallback;
Â Â Â Â }
Â Â }

Â Â function updateRecurCountVisibility() {
Â Â Â Â const isIndefinite = document.getElementById("recur-indefinitely").checked;
Â Â Â Â const isUsingSpecificDates = document.getElementById("recur-specific-dates").checked;
Â Â Â Â const countContainer = document.getElementById("recur-count-container");
Â Â 
Â Â Â Â // Only show if NOT using specific dates AND NOT recurring indefinitely
Â Â Â Â const shouldShow = !isUsingSpecificDates && !isIndefinite;
Â Â Â Â countContainer.classList.toggle("hidden", !shouldShow);
Â Â }




function updateRecurringButtonVisibility() {
Â Â Â Â console.log('ğŸ”„ Updating recurring button visibility (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateRecurringButtonVisibility');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle, settings } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn("âš ï¸ No active cycle found for recurring button visibility");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Checking visibility conditions:', {
Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â autoReset: cycleData.autoReset,
Â Â Â Â Â Â Â Â deleteCheckedTasks: cycleData.deleteCheckedTasks,
Â Â Â Â Â Â Â Â alwaysShowRecurring: settings.alwaysShowRecurring
Â Â Â Â });
Â Â Â Â 
Â Â Â Â const autoReset = cycleData.autoReset || false;
Â Â Â Â const deleteCheckedEnabled = cycleData.deleteCheckedTasks || false;
Â Â Â Â const alwaysShowRecurring = settings.alwaysShowRecurring || false;
Â Â Â Â 
Â Â Â Â // Check if buttons should be visible
Â Â Â Â const shouldShowButtons = alwaysShowRecurring || (!autoReset && deleteCheckedEnabled);
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Button visibility decision:', {
Â Â Â Â Â Â Â Â shouldShow: shouldShowButtons,
Â Â Â Â Â Â Â Â reason: alwaysShowRecurring ? 'Always show enabled' :Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (!autoReset && deleteCheckedEnabled) ? 'Manual mode with delete enabled' :Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 'Conditions not met'
Â Â Â Â });

Â Â Â Â document.querySelectorAll(".task").forEach(taskItem => {
Â Â Â Â Â Â Â Â const recurringButton = taskItem.querySelector(".recurring-btn");
Â Â Â Â Â Â Â Â if (!recurringButton) return;

Â Â Â Â Â Â Â Â if (shouldShowButtons) {
Â Â Â Â Â Â Â Â Â Â Â Â recurringButton.classList.remove("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ‘ï¸ Showing recurring button for task:', taskItem.dataset.taskId);
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â recurringButton.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ™ˆ Hiding recurring button for task:', taskItem.dataset.taskId);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring button visibility update completed');
}

function isAlwaysShowRecurringEnabled() {
Â Â Â Â console.log('ğŸ” Checking always show recurring enabled (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for isAlwaysShowRecurringEnabled');
Â Â Â Â Â Â Â Â return false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Check Schema 2.5 setting first, then DOM as fallback
Â Â Â Â const result = schemaData.settings.alwaysShowRecurring ||Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.getElementById("always-show-recurring")?.checked ||Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â false;
Â Â Â Â 
Â Â Â Â console.log('âœ… Always show recurring enabled:', result);
Â Â Â Â return result;
}
Â Â 
function updateRecurringPanelButtonVisibility() {
Â Â Â Â console.log('ğŸ”„ Updating recurring panel button visibility (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateRecurringPanelButtonVisibility');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â const button = document.getElementById("open-recurring-panel");
Â Â Â Â 
Â Â Â Â if (!cycleData || !Array.isArray(cycleData.tasks) || !button) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Missing cycle data, tasks array, or button element');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Checking for recurring tasks:', {
Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â taskCount: cycleData.tasks.length,
Â Â Â Â Â Â Â Â templateCount: Object.keys(cycleData.recurringTemplates || {}).length
Â Â Â Â });
Â Â Â Â 
Â Â Â Â const hasRecurring =
Â Â Â Â Â Â Â Â cycleData.tasks.some(task => task.recurring) ||
Â Â Â Â Â Â Â Â Object.keys(cycleData.recurringTemplates || {}).length > 0;
Â Â Â Â 
Â Â Â Â button.classList.toggle("hidden", !hasRecurring);
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring panel button visibility updated:', {
Â Â Â Â Â Â Â Â hasRecurring,
Â Â Â Â Â Â Â Â buttonVisible: !hasRecurring ? 'hidden' : 'visible'
Â Â Â Â });
}
Â Â 
function updateRecurringSummary() {
Â Â Â Â console.log('ğŸ“ Updating recurring summary (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const summaryEl = document.getElementById("recurring-summary");
Â Â Â Â if (!summaryEl) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Recurring summary element not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â // âœ… Build settings from the panel input
Â Â Â Â const settings = buildRecurringSettingsFromPanel();
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Built settings from panel:', settings);

Â Â Â Â // âœ… Simulate fallback default time (for preview only)
Â Â Â Â if (!settings.useSpecificTime && !settings.defaultRecurTime) {
Â Â Â Â Â Â Â Â settings.defaultRecurTime = new Date().toISOString();
Â Â Â Â Â Â Â Â console.log('ğŸ•’ Added default recur time for preview');
Â Â Â Â }

Â Â Â Â // âœ… Generate summary text using the shared utility
Â Â Â Â const summaryText = buildRecurringSummaryFromSettings(settings);
Â Â Â Â 
Â Â Â Â console.log('ğŸ“„ Generated summary text:', summaryText);

Â Â Â Â // âœ… Apply to DOM
Â Â Â Â summaryEl.textContent = summaryText;
Â Â Â Â summaryEl.classList.remove("hidden");
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring summary updated successfully');
}

function parseDateAsLocal(dateStr) {
Â Â Â Â console.log('ğŸ“… Parsing date as local:', dateStr);
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â const [year, month, day] = dateStr.split("-").map(Number);
Â Â Â Â Â Â Â Â const result = new Date(year, month - 1, day); // month is 0-indexed
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Date parsed successfully:', result);
Â Â Â Â Â Â Â Â return result;
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.error('âŒ Error parsing date:', error);
Â Â Â Â Â Â Â Â return new Date(); // fallback to today
Â Â Â Â }
}

function attachRecurringSummaryListeners() {
Â Â Â Â console.log('ğŸ”— Attaching recurring summary listeners (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const panel = document.getElementById("recurring-settings-panel");
Â Â Â Â if (!panel) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Recurring settings panel not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â safeAddEventListener(panel, "change", handleRecurringChange);
Â Â Â Â safeAddEventListener(panel, "click", handleRecurringClick);
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring summary listeners attached successfully');
}

function showTaskSummaryPreview(task) {
Â Â Â Â console.log('ğŸ‘ï¸ Showing task summary preview (Schema 2.5 only)...', task?.id);
Â Â Â Â 
Â Â Â Â if (!task || !task.id) {
Â Â Â Â Â Â Â Â console.warn("âš ï¸ No valid task provided for recurring preview.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const summaryContainer = document.getElementById("recurring-summary-preview") || createTaskSummaryPreview();
Â Â Â Â summaryContainer.innerHTML = "";

Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for showTaskSummaryPreview');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for task preview');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Looking for recurring settings for task:', task.id);
Â Â Â Â 
Â Â Â Â const recurringSettings = task.recurringSettings ||
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle?.recurringTemplates?.[task.id]?.recurringSettings;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Found recurring settings:', !!recurringSettings);

Â Â Â Â // ğŸ·ï¸ Label
Â Â Â Â const label = document.createElement("div");
Â Â Â Â label.textContent = "Current Recurring Settings:";
Â Â Â Â label.className = "summary-label";
Â Â Â Â summaryContainer.appendChild(label);

Â Â Â Â // ğŸ“„ Summary Text
Â Â Â Â const summaryText = document.createElement("div");
Â Â Â Â summaryText.className = "summary-text";
Â Â Â Â summaryText.textContent = recurringSettings
Â Â Â Â Â Â Â Â ? getRecurringSummaryText(recurringSettings)
Â Â Â Â Â Â Â Â : "This task is not marked as recurring.";
Â Â Â Â summaryContainer.appendChild(summaryText);

Â Â Â Â // ğŸ”˜ Change Button
Â Â Â Â const changeBtn = document.createElement("button");
Â Â Â Â changeBtn.textContent = "Change Recurring Settings";
Â Â Â Â changeBtn.className = "change-recurring-btn";
Â Â Â Â changeBtn.setAttribute("aria-label", "Change recurring settings for this task");

Â Â Â Â const settingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â if (settingsPanel && !settingsPanel.classList.contains("hidden")) {
Â Â Â Â Â Â Â Â changeBtn.classList.add("hidden");
Â Â Â Â }

Â Â Â Â changeBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â console.log('ğŸ”˜ Opening recurring settings panel for task:', task.id);
Â Â Â Â Â Â Â Â openRecurringSettingsPanelForTask(task.id);
Â Â Â Â });

Â Â Â Â summaryContainer.appendChild(changeBtn);
Â Â Â Â summaryContainer.classList.remove("hidden");
Â Â Â Â 
Â Â Â Â console.log('âœ… Task summary preview displayed successfully');
}
Â Â // Helper to create the preview container if it doesnâ€™t exist yet
Â Â function createTaskSummaryPreview() {
Â Â Â Â const container = document.createElement("div");
Â Â Â Â container.id = "recurring-summary-preview";
Â Â Â Â container.className = "recurring-summary recurring-summary-preview hidden";
Â Â Â Â document.getElementById("recurring-panel").appendChild(container);
Â Â Â Â return container;
Â Â }
Â Â 

// Before:
function getRecurringSummaryText(template) {
Â Â return buildRecurringSummaryFromSettings(template.recurringSettings || {});
}




// âœ… Shared utility: Build a recurring summary string from a settings object
function buildRecurringSummaryFromSettings(settings = {}) {
Â Â const freq = settings.frequency || "daily";
Â Â const indefinitely = settings.indefinitely ?? true;
Â Â const count = settings.count;

Â Â // === âœ… SPECIFIC DATES OVERRIDE ===
Â Â if (settings.specificDates?.enabled && settings.specificDates.dates?.length) {
Â Â Â Â const formattedDates = settings.specificDates.dates.map(dateStr => {
Â Â Â Â Â Â const date = parseDateAsLocal(dateStr);
Â Â Â Â Â Â return date.toLocaleDateString(undefined, {
Â Â Â Â Â Â Â Â year: "numeric",
Â Â Â Â Â Â Â Â month: "short",
Â Â Â Â Â Â Â Â day: "numeric",
Â Â Â Â Â Â Â Â weekday: "short"
Â Â Â Â Â Â });
Â Â Â Â });

Â Â Â Â let summary = `ğŸ“… Specific dates: ${formattedDates.join(", ")}`;

Â Â Â Â // Optionally show time for specific dates
Â Â Â Â if (settings.time) {
Â Â Â Â Â Â const { hour, minute, meridiem, military } = settings.time;
Â Â Â Â Â Â const formattedTime = military
Â Â Â Â Â Â Â Â ? `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`
Â Â Â Â Â Â Â Â : `${hour}:${minute.toString().padStart(2, "0")} ${meridiem}`;
Â Â Â Â Â Â summary += ` â° at ${formattedTime}`;
Â Â Â Â } else if (!settings.useSpecificTime && settings.defaultRecurTime) {
Â Â Â Â Â Â const time = new Date(settings.defaultRecurTime);
Â Â Â Â Â Â const fallbackTime = time.toLocaleTimeString([], {
Â Â Â Â Â Â Â Â hour: "2-digit",
Â Â Â Â Â Â Â Â minute: "2-digit"
Â Â Â Â Â Â });
Â Â Â Â Â Â summary += ` â° at ${fallbackTime}`;
Â Â Â Â }

Â Â Â Â return summary;
Â Â }

Â Â // === ğŸ” Normal Recurrence Fallback ===
Â Â let summaryText = `â± Repeats ${freq}`;
Â Â if (!indefinitely && count) {
Â Â Â Â summaryText += ` for ${count} time${count !== 1 ? "s" : ""}`;
Â Â } else {
Â Â Â Â summaryText += " indefinitely";
Â Â }

Â Â // === TIME HANDLING ===
Â Â if (settings.time && (settings.useSpecificTime ?? true)) {
Â Â Â Â const { hour, minute, meridiem, military } = settings.time;
Â Â Â Â const formatted = military
Â Â Â Â Â Â ? `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`
Â Â Â Â Â Â : `${hour}:${minute.toString().padStart(2, "0")} ${meridiem}`;
Â Â Â Â summaryText += ` at ${formatted}`;
Â Â } else if (!settings.useSpecificTime && settings.defaultRecurTime) {
Â Â Â Â const time = new Date(settings.defaultRecurTime);
Â Â Â Â const fallbackTime = time.toLocaleTimeString([], {
Â Â Â Â Â Â hour: "2-digit",
Â Â Â Â Â Â minute: "2-digit"
Â Â Â Â });
Â Â Â Â summaryText += ` at ${fallbackTime}`;
Â Â }

Â Â // === HOURLY ===
Â Â if (freq === "hourly" && settings.hourly?.useSpecificMinute) {
Â Â Â Â summaryText += ` every hour at :${settings.hourly.minute.toString().padStart(2, "0")}`;
Â Â }

Â Â // === WEEKLY & BIWEEKLY ===
Â Â if ((freq === "weekly" || freq === "biweekly") && settings[freq]?.days?.length) {
Â Â Â Â summaryText += ` on ${settings[freq].days.join(", ")}`;
Â Â }

Â Â // === MONTHLY ===
Â Â if (freq === "monthly" && settings.monthly?.days?.length) {
Â Â Â Â summaryText += ` on day${settings.monthly.days.length > 1 ? "s" : ""} ${settings.monthly.days.join(", ")}`;
Â Â }

Â Â // === YEARLY ===
Â Â if (freq === "yearly") {
Â Â Â Â const months = settings.yearly?.months || [];
Â Â Â Â const daysByMonth = settings.yearly?.daysByMonth || {};

Â Â Â Â if (months.length) {
Â Â Â Â Â Â const monthNames = months.map(m => new Date(0, m - 1).toLocaleString("default", { month: "short" }));
Â Â Â Â Â Â summaryText += ` in ${monthNames.join(", ")}`;
Â Â Â Â }

Â Â Â Â if (settings.yearly?.useSpecificDays) {
Â Â Â Â Â Â if (settings.yearly.applyDaysToAll && daysByMonth.all?.length) {
Â Â Â Â Â Â Â Â summaryText += ` on day${daysByMonth.all.length > 1 ? "s" : ""} ${daysByMonth.all.join(", ")}`;
Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â const parts = months.map(month => {
Â Â Â Â Â Â Â Â Â Â const days = daysByMonth[month] || [];
Â Â Â Â Â Â Â Â Â Â if (days.length === 0) return null;
Â Â Â Â Â Â Â Â Â Â const monthName = new Date(0, month - 1).toLocaleString("default", { month: "short" });
Â Â Â Â Â Â Â Â Â Â return `${monthName}: ${days.join(", ")}`;
Â Â Â Â Â Â Â Â }).filter(Boolean);

Â Â Â Â Â Â Â Â if (parts.length) {
Â Â Â Â Â Â Â Â Â Â summaryText += ` on ${parts.join("; ")}`;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }

Â Â return summaryText;
}

// Usage in summary preview:
// const summary = buildRecurringSummaryFromSettings(task.recurringSettings);

function removeRecurringTasksFromCycle(taskElements, cycleData) {
Â Â Â Â taskElements.forEach(taskEl => {
Â Â Â Â Â Â Â Â const taskId = taskEl.dataset.taskId;
Â Â Â Â Â Â Â Â const isRecurring = taskEl.classList.contains("recurring");

Â Â Â Â Â Â Â Â if (isRecurring) {
Â Â Â Â Â Â Â Â Â Â Â Â // Remove from DOM
Â Â Â Â Â Â Â Â Â Â Â Â taskEl.remove();
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… IMPORTANT: Only remove from tasks array, keep in recurringTemplates
Â Â Â Â Â Â Â Â Â Â Â Â if (cycleData.tasks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskIndex = cycleData.tasks.findIndex(t => t.id === taskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (taskIndex !== -1) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycleData.tasks.splice(taskIndex, 1);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Keep in recurringTemplates so they can be recreated
Â Â Â Â Â Â Â Â Â Â Â Â // DON'T delete from recurringTemplates here
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}

function handleRecurringTasksAfterReset() {
Â Â Â Â console.log('ğŸ”„ Handling recurring tasks after reset (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for handleRecurringTasksAfterReset');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle data found for recurring task reset');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Processing recurring tasks reset for cycle:', activeCycle);
Â Â Â Â 
Â Â Â Â const taskElements = [...taskList.querySelectorAll(".task")];
Â Â Â Â console.log('ğŸ” Found task elements for processing:', taskElements.length);
Â Â Â Â 
Â Â Â Â // âœ… Reuse the same helper function
Â Â Â Â removeRecurringTasksFromCycle(taskElements, cycleData);
Â Â Â Â 
Â Â Â Â // âœ… Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('ğŸ’¾ Recurring tasks reset saved to Schema 2.5');
Â Â Â Â 
Â Â Â Â // âœ… Update UI components
Â Â Â Â updateProgressBar();
Â Â Â Â updateStatsPanel();
Â Â Â Â checkCompleteAllButton();
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring tasks after reset handling completed');
}


function convert12To24(hour, meridiem) {
Â Â hour = parseInt(hour, 10);
Â Â if (meridiem === "PM" && hour !== 12) return hour + 12;
Â Â if (meridiem === "AM" && hour === 12) return 0;
Â Â return hour;
}


// âœ… Main logic to determine if a task should recur today
function shouldTaskRecurNow(settings, now = new Date()) {
Â // âœ… Specific Dates override allâ€¦ but still honor specificâ€‘time if set
if (settings.specificDates?.enabled) {
Â Â const todayMatch = settings.specificDates.dates?.some(dateStr => {
Â Â Â Â const date = parseDateAsLocal(dateStr);
Â Â Â Â return date.getFullYear() === now.getFullYear()
Â Â Â Â Â Â Â Â && date.getMonth()Â  === now.getMonth()
Â Â Â Â Â Â Â Â && date.getDate() Â  === now.getDate();
Â Â });
Â Â if (!todayMatch) return false;

Â Â // Only trigger at the exact time if the user checked â€œspecific timeâ€
Â Â if (settings.time) {
Â Â Â Â const hour Â  = settings.time.military
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ? settings.time.hour
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â : convert12To24(settings.time.hour, settings.time.meridiem);
Â Â Â Â const minute = settings.time.minute;
Â Â Â Â return now.getHours() === hour && now.getMinutes() === minute;
Â Â }

Â Â return true;
}

Â Â const weekday = now.toLocaleDateString("en-US", { weekday: "short" });
Â Â const day = now.getDate();
Â Â const month = now.getMonth() + 1;

Â Â switch (settings.frequency) {
case "daily":
Â Â if (settings.time) {
Â Â Â Â const hour = settings.time.military
Â Â Â Â Â Â ? settings.time.hour
Â Â Â Â Â Â : convert12To24(settings.time.hour, settings.time.meridiem);
Â Â Â Â const minute = settings.time.minute;
Â Â Â Â return now.getHours() === hour && now.getMinutes() === minute;
Â Â }
Â Â return now.getHours() === 0 && now.getMinutes() === 0;

Â Â Â case "weekly":
case "biweekly":
Â Â if (!settings[settings.frequency]?.days?.includes(weekday)) return false;

Â Â if (settings.time) {
Â Â Â Â const hour = settings.time.military
Â Â Â Â Â Â ? settings.time.hour
Â Â Â Â Â Â : convert12To24(settings.time.hour, settings.time.meridiem);
Â Â Â Â const minute = settings.time.minute;
Â Â Â Â return now.getHours() === hour && now.getMinutes() === minute;
Â Â }

Â Â return true; // if no time set, recur any time today


Â Â Â case "monthly":
Â Â if (!settings.monthly?.days?.includes(day)) return false;

Â Â if (settings.time) {
Â Â Â Â const hour = settings.time.military
Â Â Â Â Â Â ? settings.time.hour
Â Â Â Â Â Â : convert12To24(settings.time.hour, settings.time.meridiem);
Â Â Â Â const minute = settings.time.minute;
Â Â Â Â return now.getHours() === hour && now.getMinutes() === minute;
Â Â }

Â Â return true; // If no time is set, trigger any time during the day

Â Â Â Â case "yearly":
Â Â if (!settings.yearly?.months?.includes(month)) return false;

Â Â if (settings.yearly.useSpecificDays) {
Â Â Â Â const daysByMonth = settings.yearly.daysByMonth || {};
Â Â Â Â const days = settings.yearly.applyDaysToAll
Â Â Â Â Â Â ? daysByMonth.all || []
Â Â Â Â Â Â : daysByMonth[month] || [];

Â Â Â Â if (!days.includes(day)) return false;
Â Â }

Â Â if (settings.time) {
Â Â Â Â const hour = settings.time.military
Â Â Â Â Â Â ? settings.time.hour
Â Â Â Â Â Â : convert12To24(settings.time.hour, settings.time.meridiem);
Â Â Â Â const minute = settings.time.minute;
Â Â Â Â return now.getHours() === hour && now.getMinutes() === minute;
Â Â }

Â Â return true; // If no time is set, recur any time that day

Â Â Â Â case "hourly":
Â Â Â Â Â Â if (settings.hourly?.useSpecificMinute) {
Â Â Â Â Â Â Â Â const minute = now.getMinutes();
Â Â Â Â Â Â Â Â return minute === settings.hourly.minute;
Â Â Â Â Â Â }
Â Â Â Â Â Â return now.getMinutes() === 0;

Â Â Â Â default:
Â Â Â Â Â Â return false;
Â Â }
}







// âœ… Helper: Check if a recurring task should be recreated
function shouldRecreateRecurringTask(template, taskList, now) {
Â Â const { id, text, recurringSettings, recurring, lastTriggeredTimestamp, suppressUntil } = template;

Â Â if (!recurring || !recurringSettings) return false;

Â Â // ğŸ”’ Already exists?
Â Â if (taskList.some(task => task.id === id)) return false;

Â Â // â¸ï¸ Suppressed?
Â Â if (suppressUntil && new Date(suppressUntil) > now) {
Â Â Â Â console.log(`â¸ Skipping "${text}" â€” suppressed until ${suppressUntil}`);
Â Â Â Â return false;
Â Â }

Â Â // â± Triggered recently?
Â Â if (lastTriggeredTimestamp) {
Â Â Â Â const last = new Date(lastTriggeredTimestamp);
Â Â Â Â const sameMinute =
Â Â Â Â Â Â last.getFullYear() === now.getFullYear() &&
Â Â Â Â Â Â last.getMonth()Â  Â  === now.getMonth()Â  Â  &&
Â Â Â Â Â Â last.getDate() Â  Â  === now.getDate() Â  Â  &&
Â Â Â Â Â Â last.getHours()Â  Â  === now.getHours()Â  Â  &&
Â Â Â Â Â Â last.getMinutes()Â  === now.getMinutes();
Â Â Â Â if (sameMinute) return false;
Â Â }

Â Â // ğŸ§  Recurrence match?
Â Â return shouldTaskRecurNow(recurringSettings, now);
}

function watchRecurringTasks() {
Â Â Â Â console.log('ğŸ‘ï¸ Watching recurring tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for watchRecurringTasks');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for recurring task watch');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const templates = cycleData.recurringTemplates || {};
Â Â Â Â const taskList = cycleData.tasks || [];

Â Â Â Â if (!Object.keys(templates).length) {
Â Â Â Â Â Â Â Â console.log('ğŸ“‹ No recurring templates found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ” Checking recurring templates:', Object.keys(templates).length);

Â Â Â Â const now = new Date();
Â Â Â Â let taskAdded = false;

Â Â Â Â Object.values(templates).forEach(template => {
Â Â Â Â Â Â Â Â // â›” Prevent re-adding if task already exists by ID
Â Â Â Â Â Â Â Â if (taskList.some(task => task.id === template.id)) return;
Â Â Â Â Â Â Â Â if (!shouldRecreateRecurringTask(template, taskList, now)) return;

Â Â Â Â Â Â Â Â console.log("â± Autoâ€‘recreating recurring task:", template.text);

Â Â Â Â Â Â Â Â addTask(
Â Â Â Â Â Â Â Â Â Â Â Â template.text,
Â Â Â Â Â Â Â Â Â Â Â Â false,Â  // not completed
Â Â Â Â Â Â Â Â Â Â Â Â false,Â  // shouldSave = false (batch save at end)
Â Â Â Â Â Â Â Â Â Â Â Â template.dueDate,
Â Â Â Â Â Â Â Â Â Â Â Â template.highPriority,
Â Â Â Â Â Â Â Â Â Â Â Â true, Â  // isLoading = true
Â Â Â Â Â Â Â Â Â Â Â Â template.remindersEnabled,
Â Â Â Â Â Â Â Â Â Â Â Â true, Â  // recurring = true
Â Â Â Â Â Â Â Â Â Â Â Â template.id,
Â Â Â Â Â Â Â Â Â Â Â Â template.recurringSettings
Â Â Â Â Â Â Â Â );

Â Â Â Â Â Â Â Â template.lastTriggeredTimestamp = now.getTime();
Â Â Â Â Â Â Â Â taskAdded = true;
Â Â Â Â });

Â Â Â Â if (taskAdded) {
Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Recurring tasks added and saved to Schema 2.5');
Â Â Â Â }
}

function setupRecurringWatcher() {
Â Â Â Â console.log('âš™ï¸ Setting up recurring watcher (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for setupRecurringWatcher');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for recurring watcher setup');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const recurringTemplates = cycleData.recurringTemplates || {};
Â Â Â Â 
Â Â Â Â if (Object.keys(recurringTemplates).length === 0) {
Â Â Â Â Â Â Â Â console.log('ğŸ“‹ No recurring templates found, skipping watcher setup');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ”„ Setting up recurring task watcher with', Object.keys(recurringTemplates).length, 'templates');

Â Â Â Â watchRecurringTasks();
Â Â Â Â setInterval(watchRecurringTasks, 30000);

Â Â Â Â document.addEventListener("visibilitychange", () => {
Â Â Â Â Â Â Â Â if (document.visibilityState === "visible") {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ‘ï¸ Page became visible, checking recurring tasks');
Â Â Â Â Â Â Â Â Â Â Â Â watchRecurringTasks();
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Recurring watcher setup completed');
}




/**
Â * Setupsettingsmenu function.
Â *
Â * @returns {void}
Â */
function setupSettingsMenu() {
Â Â Â Â const settingsModal = document.querySelector(".settings-modal");
Â Â Â Â const settingsModalContent = document.querySelector(".settings-modal-content");
Â Â Â Â const openSettingsBtn = document.getElementById("open-settings");
Â Â Â Â const closeSettingsBtn = document.getElementById("close-settings");

Â Â Â Â /**
Â Â Â Â Â * Opens the settings menu.
Â Â Â Â Â *
Â Â Â Â Â * @param {Event} event - The click event.
Â Â Â Â Â */
Â Â Â Â function openSettings(event) {
Â Â Â Â Â Â Â Â event.stopPropagation();
Â Â Â Â Â Â Â Â settingsModal.style.display = "flex";
Â Â Â Â Â Â Â Â hideMainMenu();
Â Â Â Â }

Â Â Â Â /**
Â Â Â Â Â * Closes the settings menu.
Â Â Â Â Â */
Â Â Â Â function closeSettings() {
Â Â Â Â Â Â Â Â settingsModal.style.display = "none";
Â Â Â Â }

Â Â Â Â function closeOnClickOutside(event) {
Â Â Â Â Â Â Â Â if (settingsModal.style.display === "flex" &&Â 
Â Â Â Â Â Â Â Â Â Â Â Â !settingsModalContent.contains(event.target) &&Â 
Â Â Â Â Â Â Â Â Â Â Â Â event.target !== openSettingsBtn) {
Â Â Â Â Â Â Â Â Â Â Â Â settingsModal.style.display = "none";
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â // âœ… Remove previous listeners before adding new ones
Â Â Â Â openSettingsBtn.removeEventListener("click", openSettings);
Â Â Â Â closeSettingsBtn.removeEventListener("click", closeSettings);
Â Â Â Â document.removeEventListener("click", closeOnClickOutside);

Â Â Â Â // âœ… Add event listeners (only once)
Â Â Â Â openSettingsBtn.addEventListener("click", openSettings);
Â Â Â Â closeSettingsBtn.addEventListener("click", closeSettings);
Â Â Â Â document.addEventListener("click", closeOnClickOutside);

Â Â Â Â // âœ… Dark Mode Toggle (Check if the element exists first)
Â Â Â Â setupDarkModeToggle("darkModeToggle", ["darkModeToggle", "darkModeToggleThemes"]);


// âœ… Toggle Move Arrows Setting (Schema 2.5 only)
const moveArrowsToggle = document.getElementById("toggle-move-arrows");
if (moveArrowsToggle) {
Â Â Â Â console.log('ğŸ”„ Setting up move arrows toggle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for move arrows toggle');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const moveArrowsEnabled = schemaData.settings.showMoveArrows || false;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Loading move arrows setting from Schema 2.5:', moveArrowsEnabled);
Â Â Â Â 
Â Â Â Â moveArrowsToggle.checked = moveArrowsEnabled;
Â Â Â Â 
Â Â Â Â moveArrowsToggle.addEventListener("change", () => {
Â Â Â Â Â Â Â Â const enabled = moveArrowsToggle.checked;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Move arrows toggle changed:', enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saving move arrows setting');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.showMoveArrows = enabled;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Move arrows setting saved to Schema 2.5:', enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â updateMoveArrowsVisibility();
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Move arrows toggle setup completed');
}

// âœ… Toggle Three-Dot Menu Setting (Schema 2.5 only)
const threeDotsToggle = document.getElementById("toggle-three-dots");
if (threeDotsToggle) {
Â Â Â Â console.log('ğŸ”„ Setting up three dots toggle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for three dots toggle');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const threeDotsEnabled = schemaData.settings.showThreeDots || false;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Loading three dots setting from Schema 2.5:', threeDotsEnabled);
Â Â Â Â 
Â Â Â Â threeDotsToggle.checked = threeDotsEnabled;
Â Â Â Â document.body.classList.toggle("show-three-dots-enabled", threeDotsEnabled);

Â Â Â Â threeDotsToggle.addEventListener("change", () => {
Â Â Â Â Â Â Â Â const enabled = threeDotsToggle.checked;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Three dots toggle changed:', enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saving three dots setting');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.showThreeDots = enabled;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Three dots setting saved to Schema 2.5:', enabled);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â document.body.classList.toggle("show-three-dots-enabled", enabled);

Â Â Â Â Â Â Â Â // âœ… Disable/enable hover behavior for current tasks
Â Â Â Â Â Â Â Â toggleHoverTaskOptions(!enabled);

Â Â Â Â Â Â Â Â // âœ… Update task list UI
Â Â Â Â Â Â Â Â refreshTaskListUI();Â 
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Three dots toggle setup completed');
}

Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Update backup function to be Schema 2.5 only
Â Â Â Â Â Â document.getElementById("backup-mini-cycles").addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“¤ Creating backup (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const schemaData = localStorage.getItem("miniCycleData");
Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for backup');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ No Schema 2.5 data found. Cannot create backup.", "error");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // Schema 2.5 backup - everything is in one key
Â Â Â Â Â Â Â Â Â Â const backupData = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: "2.5",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â miniCycleData: schemaData,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â backupMetadata: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â version: "2.5",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â source: "miniCycle App"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const backupBlob = new Blob([JSON.stringify(backupData, null, 2)], { type: "application/json" });
Â Â Â Â Â Â Â Â Â Â const backupUrl = URL.createObjectURL(backupBlob);
Â Â Â Â Â Â Â Â Â Â const a = document.createElement("a");
Â Â Â Â Â Â Â Â Â Â a.href = backupUrl;
Â Â Â Â Â Â Â Â Â Â a.download = `mini-cycle-backup-schema25-${Date.now()}.json`;
Â Â Â Â Â Â Â Â Â Â a.click();
Â Â Â Â Â Â Â Â Â Â URL.revokeObjectURL(backupUrl);
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â showNotification("âœ… Schema 2.5 backup created successfully!", "success", 3000);
Â Â Â Â Â Â });
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Update restore function to convert legacy backups to Schema 2.5 (idempotent + cancel-safe)
Â Â Â Â Â Â Â Â (() => {
Â Â Â Â Â Â Â Â Â Â const restoreBtn = document.getElementById("restore-mini-cycles");
Â Â Â Â Â Â Â Â Â Â if (!restoreBtn) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â let fileInput = null;
Â Â Â Â Â Â Â Â Â Â let isPickerOpen = false;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const resetPicker = () => { isPickerOpen = false; };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const handleRestore = () => {
Â Â Â Â Â Â Â Â Â Â Â Â if (isPickerOpen) return;
Â Â Â Â Â Â Â Â Â Â Â Â isPickerOpen = true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Clean previous input
Â Â Â Â Â Â Â Â Â Â Â Â if (fileInput) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Fresh input
Â Â Â Â Â Â Â Â Â Â Â Â fileInput = document.createElement("input");
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.type = "file";
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.accept = "application/json,.json";
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.style.display = "none";
Â Â Â Â Â Â Â Â Â Â Â Â document.body.appendChild(fileInput);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // When picker closes (even on cancel), window regains focus
Â Â Â Â Â Â Â Â Â Â Â Â const onFocusAfterPicker = () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â resetPicker();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â window.removeEventListener("focus", onFocusAfterPicker);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Cleanup dangling input on cancel
Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (fileInput && !fileInput.files?.length) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â window.addEventListener("focus", onFocusAfterPicker, { once: true });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.addEventListener("change", (event) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const file = event.target.files[0];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!file) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (fileInput) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resetPicker();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const reader = new FileReader();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reader.onload = (e) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const backupData = JSON.parse(e.target.result);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Check if user is currently on Schema 2.5 (should always be true now)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const currentSchemaData = localStorage.getItem("miniCycleData");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!currentSchemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Cannot restore - Schema 2.5 data structure required.", "error");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Handle Schema 2.5 backup
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.schemaVersion === "2.5" && backupData.miniCycleData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", backupData.miniCycleData);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âœ… Schema 2.5 backup restored successfully!", "success", 4000);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ”„ Reloading app to apply changes...", "info", 2000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => location.reload(), 2500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Handle legacy backup - convert to Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.schemaVersion === "legacy" || backupData.miniCycleStorage) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ”„ Auto-converting legacy backup to Schema 2.5...", "info", 3000);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!backupData.miniCycleStorage) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Invalid legacy backup file format.", "error", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Temporarily restore legacy keys
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleStorage", backupData.miniCycleStorage);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("lastUsedMiniCycle", backupData.lastUsedMiniCycle || "");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.miniCycleReminders) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleReminders", backupData.miniCycleReminders);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.milestoneUnlocks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("milestoneUnlocks", backupData.milestoneUnlocks);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.darkModeEnabled !== undefined) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("darkModeEnabled", backupData.darkModeEnabled);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (backupData.currentTheme) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("currentTheme", backupData.currentTheme);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Migrate to 2.5
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const migrationResults = performSchema25Migration();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (migrationResults.success) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âœ… Legacy backup restored and converted to Schema 2.5!", "success", 4000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Migration failed during restore", "error", 4000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => location.reload(), 1000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }, 500);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return; // prevent double reload path
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Invalid backup file format.", "error", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error("Backup restore error:", error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Error restoring backup - file may be corrupted.", "error", 4000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } finally {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (fileInput) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resetPicker();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â window.removeEventListener("focus", onFocusAfterPicker);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reader.readAsText(file);
Â Â Â Â Â Â Â Â Â Â Â Â }, { once: true });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.click();
Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // Idempotent listener attachment
Â Â Â Â Â Â Â Â Â Â if (restoreBtn._restoreHandler) {
Â Â Â Â Â Â Â Â Â Â Â Â restoreBtn.removeEventListener("click", restoreBtn._restoreHandler);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â restoreBtn._restoreHandler = handleRestore;
Â Â Â Â Â Â Â Â Â Â restoreBtn.addEventListener("click", restoreBtn._restoreHandler);
Â Â Â Â Â Â Â Â })();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â 
Â Â Â Â document.getElementById("reset-recurring-default")?.addEventListener("click", resetDefaultRecurringSettings);
Â Â Â Â Â Â // âœ… Update reset recurring default for Schema 2.5 only
Â Â Â Â Â Â function resetDefaultRecurringSettings() {
Â Â Â Â Â Â Â Â Â Â console.log('ğŸ” Resetting recurring defaults (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const schemaData = localStorage.getItem("miniCycleData");
Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for reset');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ No Schema 2.5 data found. Cannot reset defaults.", "error");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const parsed = JSON.parse(schemaData);
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const defaultSettings = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â frequency: "daily",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â indefinitely: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â time: null
Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // Reset defaults in Schema 2.5
Â Â Â Â Â Â Â Â Â Â parsed.settings.defaultRecurringSettings = defaultSettings;
Â Â Â Â Â Â Â Â Â Â parsed.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(parsed));
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ” Recurring default reset to Daily Indefinitely.", "success");
Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â // âœ… Update Factory Reset for Schema 2.5 only
Â Â Â Â Â Â document.getElementById("factory-reset").addEventListener("click", async () => {
Â Â Â Â Â Â Â Â Â Â const confirmed = showConfirmationModal({
Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "Factory Reset",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: "âš ï¸ This will DELETE ALL miniCycle data, settings, and progress. Are you sure?",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Delete Everything",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmed) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Factory reset cancelled.", "info", 2000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Performing bulletproof Schema 2.5 factory reset...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Schema 2.5 - Single key cleanup
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.removeItem("miniCycleData");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Also clean up any remaining legacy keys for thorough cleanup
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const legacyKeysToRemove = [
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleStorage",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "lastUsedMiniCycle",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleReminders",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleDefaultRecurring",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "milestoneUnlocks",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "darkModeEnabled",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "currentTheme",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleNotificationPosition",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleThreeDots",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleMoveArrows",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleOnboarding",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "overdueTaskStates",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "bestRound",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "bestTime",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycleAlwaysShowRecurring",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycle_console_logs",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycle_console_capture_start",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "miniCycle_console_capture_enabled"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â legacyKeysToRemove.forEach(key => localStorage.removeItem(key));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Clean up any backup files and dynamic keys
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const allKeys = Object.keys(localStorage);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let dynamicKeysRemoved = 0;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â allKeys.forEach(key => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Backup files
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (key.startsWith('miniCycle_backup_') || key.startsWith('pre_migration_backup_')) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.removeItem(key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dynamicKeysRemoved++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Any key containing miniCycle, minicycle, or TaskCycle (case-insensitive)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const keyLower = key.toLowerCase();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (keyLower.includes('minicycle') || keyLower.includes('taskcycle')) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Removing additional key:', key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.removeItem(key);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dynamicKeysRemoved++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ§¹ Removed ${dynamicKeysRemoved} additional dynamic keys`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Optional: Clear service worker cache for complete reset
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if ('serviceWorker' in navigator) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â navigator.serviceWorker.getRegistrations().then(registrations => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â registrations.forEach(registration => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Unregistering service worker:', registration.scope);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â registration.unregister();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }).catch(err => console.warn('âš ï¸ Service worker cleanup failed:', err));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Clear any cached data in memory
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (typeof window.caches !== 'undefined') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â caches.keys().then(cacheNames => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return Promise.all(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cacheNames.map(cacheName => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (cacheName.includes('miniCycle') || cacheName.includes('taskCycle')) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Clearing cache:', cacheName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return caches.delete(cacheName);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }).catch(err => console.warn('âš ï¸ Cache cleanup failed:', err));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âœ… Factory Reset Complete. Reloading...", "success", 2000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => location.reload(), 1000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â });

Â Â Â Â }


/**
Â * Setupdownloadminicycle function - Schema 2.5 ONLY
Â *
Â * @returns {void}
Â */
function setupDownloadMiniCycle() {
Â Â document.getElementById("export-mini-cycle").addEventListener("click", () => {
Â Â Â Â console.log('ğŸ“¤ Exporting miniCycle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for export');
Â Â Â Â Â Â showNotification("âŒ No Schema 2.5 data found. Cannot export.", "error");
Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycle) {
Â Â Â Â Â Â showNotification("âš  No active miniCycle to export.");
Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Exporting cycle:', activeCycle);

Â Â Â Â const miniCycleData = {
Â Â Â Â Â Â name: activeCycle,
Â Â Â Â Â Â title: cycle.title || "New miniCycle",
Â Â Â Â Â Â tasks: cycle.tasks.map(task => {
Â Â Â Â Â Â Â Â const settings = task.recurringSettings || {};
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Add fallback time if task is recurring and doesn't use specificTime
Â Â Â Â Â Â Â Â if (task.recurring && !settings.specificTime && !settings.defaultRecurTime) {
Â Â Â Â Â Â Â Â Â Â settings.defaultRecurTime = new Date().toISOString();
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â id: task.id || `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
Â Â Â Â Â Â Â Â Â Â text: task.text || "",
Â Â Â Â Â Â Â Â Â Â completed: task.completed || false,
Â Â Â Â Â Â Â Â Â Â dueDate: task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â highPriority: task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â recurring: task.recurring || false,
Â Â Â Â Â Â Â Â Â Â recurringSettings: settings,
Â Â Â Â Â Â Â Â Â Â schemaVersion: task.schemaVersion || 2
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â }),
Â Â Â Â Â Â autoReset: cycle.autoReset || false,
Â Â Â Â Â Â cycleCount: cycle.cycleCount || 0,
Â Â Â Â Â Â deleteCheckedTasks: cycle.deleteCheckedTasks || false
Â Â Â Â };

Â Â Â Â console.log('âœ… Export data prepared');
Â Â Â Â exportMiniCycleData(miniCycleData, cycle.title || activeCycle);
Â Â });
}

function exportMiniCycleData(miniCycleData, cycleName) {
Â Â Â Â console.log('ğŸ“¤ Exporting miniCycle data (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â try {
Â Â Â Â Â Â Â Â const dataStr = JSON.stringify(miniCycleData, null, 2);
Â Â Â Â Â Â Â Â const dataBlob = new Blob([dataStr], { type: "application/json" });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const link = document.createElement("a");
Â Â Â Â Â Â Â Â link.href = URL.createObjectURL(dataBlob);
Â Â Â Â Â Â Â Â link.download = `${cycleName.replace(/[^a-z0-9]/gi, '_')}.mcyc`;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â document.body.appendChild(link);
Â Â Â Â Â Â Â Â link.click();
Â Â Â Â Â Â Â Â document.body.removeChild(link);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â URL.revokeObjectURL(link.href);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Export completed successfully');
Â Â Â Â Â Â Â Â showNotification(`âœ… "${cycleName}" exported successfully!`, "success", 3000);
Â Â Â Â Â Â Â Â 
Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â console.error('âŒ Export failed:', error);
Â Â Â Â Â Â Â Â showNotification("âŒ Export failed. Please try again.", "error", 3000);
Â Â Â Â }
}


function setupUploadMiniCycle() {
Â Â const importButtons = ["import-mini-cycle", "miniCycleUpload"];

Â Â // Shared state
Â Â let fileInput = null;
Â Â let isPickerOpen = false;

Â Â const resetPickerState = () => {
Â Â Â Â isPickerOpen = false;
Â Â };

Â Â const handleImport = () => {
Â Â Â Â if (isPickerOpen) return;
Â Â Â Â isPickerOpen = true;

Â Â Â Â // Clean previous input
Â Â Â Â if (fileInput) {
Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â fileInput = null;
Â Â Â Â }

Â Â Â Â // Fresh input
Â Â Â Â fileInput = document.createElement("input");
Â Â Â Â fileInput.type = "file";
Â Â Â Â fileInput.accept = ".mcyc";
Â Â Â Â fileInput.style.display = "none";
Â Â Â Â document.body.appendChild(fileInput);

Â Â Â Â // When the OS file dialog closes (even on cancel), window regains focus
Â Â Â Â const onFocusAfterPicker = () => {
Â Â Â Â Â Â // If change didn't fire (cancel), release the lock
Â Â Â Â Â Â resetPickerState();
Â Â Â Â Â Â window.removeEventListener("focus", onFocusAfterPicker);
Â Â Â Â Â Â // Cleanup dangling input on cancel
Â Â Â Â Â Â if (fileInput && !fileInput.files?.length) {
Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â }
Â Â Â Â };
Â Â Â Â window.addEventListener("focus", onFocusAfterPicker, { once: true });

Â Â Â Â fileInput.addEventListener("change", (event) => {
Â Â Â Â Â Â const file = event.target.files[0];
Â Â Â Â Â Â if (!file) {
Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â resetPickerState();
Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }

Â Â Â Â Â Â if (file.name.endsWith(".tcyc")) {
Â Â Â Â Â Â Â Â showNotification("âŒ miniCycle does not support .tcyc files.\nPlease save your Task Cycle as .MCYC to import into miniCycle.");
Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â resetPickerState();
Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }

Â Â Â Â Â Â const reader = new FileReader();
Â Â Â Â Â Â reader.onload = (e) => {
Â Â Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â Â Â const importedData = JSON.parse(e.target.result);

Â Â Â Â Â Â Â Â Â Â if (!importedData.name || !Array.isArray(importedData.tasks)) {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Invalid miniCycle file format.");
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â console.log("ğŸ“¥ Importing miniCycle with auto-conversion to Schema 2.5...");

Â Â Â Â Â Â Â Â Â Â // Ensure Schema 2.5 data exists
Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error("âŒ Schema 2.5 data required for import");
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Cannot import - Schema 2.5 data structure required.", "error");
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â const cycleId = `imported_${Date.now()}`;

Â Â Â Â Â Â Â Â Â Â console.log("ğŸ”„ Creating imported cycle with ID:", cycleId);

Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[cycleId] = {
Â Â Â Â Â Â Â Â Â Â Â Â id: cycleId,
Â Â Â Â Â Â Â Â Â Â Â Â title: importedData.title || importedData.name,
Â Â Â Â Â Â Â Â Â Â Â Â tasks: importedData.tasks.map((task) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â const safeSettings = task.recurringSettings || {};
Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task.recurring && !safeSettings.specificTime && !safeSettings.defaultRecurTime) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â safeSettings.defaultRecurTime = new Date().toISOString();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: task.id || `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: task.text || "",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â completed: false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDate: task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â highPriority: task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurring: task.recurring || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings: safeSettings,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: task.schemaVersion || 2
Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â }),
Â Â Â Â Â Â Â Â Â Â Â Â autoReset: importedData.autoReset !== false,
Â Â Â Â Â Â Â Â Â Â Â Â cycleCount: importedData.cycleCount || 0,
Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks: importedData.deleteCheckedTasks || false,
Â Â Â Â Â Â Â Â Â Â Â Â createdAt: Date.now(),
Â Â Â Â Â Â Â Â Â Â Â Â recurringTemplates: {}
Â Â Â Â Â Â Â Â Â Â };

Â Â Â Â Â Â Â Â Â Â // Set as active cycle and persist
Â Â Â Â Â Â Â Â Â Â fullSchemaData.appState.activeCycleId = cycleId;
Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.totalCyclesCreated++;
Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â Â Â console.log("ğŸ’¾ Import completed successfully to Schema 2.5");
Â Â Â Â Â Â Â Â Â Â showNotification(`âœ… miniCycle "${importedData.name}" imported and converted to Schema 2.5!`, "success");
Â Â Â Â Â Â Â Â Â Â location.reload();
Â Â Â Â Â Â Â Â } catch (error) {
Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Error importing miniCycle.");
Â Â Â Â Â Â Â Â Â Â console.error("Import error:", error);
Â Â Â Â Â Â Â Â } finally {
Â Â Â Â Â Â Â Â Â Â if (fileInput) {
Â Â Â Â Â Â Â Â Â Â Â Â fileInput.remove();
Â Â Â Â Â Â Â Â Â Â Â Â fileInput = null;
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â resetPickerState();
Â Â Â Â Â Â Â Â Â Â window.removeEventListener("focus", onFocusAfterPicker);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â };

Â Â Â Â Â Â reader.readAsText(file);
Â Â Â Â }, { once: true });

Â Â Â Â fileInput.click();
Â Â };

Â Â // Attach listeners idempotently
Â Â importButtons.forEach((buttonId) => {
Â Â Â Â const button = document.getElementById(buttonId);
Â Â Â Â if (!button) return;

Â Â Â Â if (button._importHandler) {
Â Â Â Â Â Â button.removeEventListener("click", button._importHandler);
Â Â Â Â }
Â Â Â Â button._importHandler = handleImport;
Â Â Â Â button.addEventListener("click", button._importHandler);
Â Â });
}



/**
Â * Setupfeedbackmodal function.
Â *
Â * @returns {void}
Â */

function setupFeedbackModal() {
Â Â Â Â const feedbackModal = document.getElementById("feedback-modal");
Â Â Â Â const openFeedbackBtn = document.getElementById("open-feedback-modal");
Â Â Â Â const closeFeedbackBtn = document.querySelector(".close-feedback-modal");
Â Â Â Â const feedbackForm = document.getElementById("feedback-form");
Â Â Â Â const feedbackText = document.getElementById("feedback-text");
Â Â Â Â const submitButton = document.getElementById("submit-feedback");
Â Â Â Â const thankYouMessage = document.getElementById("thank-you-message");

Â Â Â Â // Open Modal
Â Â Â Â openFeedbackBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â feedbackModal.style.display = "flex";
Â Â Â Â Â Â Â Â hideMainMenu();
Â Â Â Â Â Â Â Â thankYouMessage.style.display = "none"; // Hide thank you message if shown before
Â Â Â Â });

Â Â Â Â // Close Modal
Â Â Â Â closeFeedbackBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â feedbackModal.style.display = "none";
Â Â Â Â });

Â Â Â Â // Close Modal on Outside Click
Â Â Â Â window.addEventListener("click", (event) => {
Â Â Â Â Â Â Â Â if (event.target === feedbackModal) {
Â Â Â Â Â Â Â Â Â Â Â Â feedbackModal.style.display = "none";
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â // Handle Form Submission via AJAX (Prevent Page Refresh)
Â Â Â Â feedbackForm.addEventListener("submit", function (event) {
Â Â Â Â Â Â Â Â event.preventDefault(); // Prevent default form submission

Â Â Â Â Â Â Â Â // Disable button while sending
Â Â Â Â Â Â Â Â submitButton.disabled = true;
Â Â Â Â Â Â Â Â submitButton.textContent = "Sending...";

Â Â Â Â Â Â Â Â // Prepare Form Data
Â Â Â Â Â Â Â Â const formData = new FormData(feedbackForm);

Â Â Â Â Â Â Â Â // Send request to Web3Forms API
Â Â Â Â Â Â Â Â fetch("https://api.web3forms.com/submit", {
Â Â Â Â Â Â Â Â Â Â Â Â method: "POST",
Â Â Â Â Â Â Â Â Â Â Â Â body: formData,
Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â .then(response => response.json())
Â Â Â Â Â Â Â Â .then(data => {
Â Â Â Â Â Â Â Â Â Â Â Â if (data.success) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Show Thank You Message
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â thankYouMessage.style.display = "block";

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Clear Textarea
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â feedbackText.value = "";

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Hide Form After Submission
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â thankYouMessage.style.display = "none";
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â feedbackModal.style.display = "none"; // Close modal after a short delay
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }, 2000);
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Error sending feedback. Please try again.");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â .catch(error => {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âŒ Network error. Please try again later.");
Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â .finally(() => {
Â Â Â Â Â Â Â Â Â Â Â Â submitButton.disabled = false;
Â Â Â Â Â Â Â Â Â Â Â Â submitButton.textContent = "Submit";
Â Â Â Â Â Â Â Â });
Â Â Â Â });
}


document.getElementById("feedback-form").addEventListener("submit", (e) => {
Â Â Â Â const textarea = document.getElementById("feedback-text");
Â Â Â Â textarea.value = sanitizeInput(textarea.value);
});


function openFeedbackModal() {
Â Â Â Â const openFeedbackFooter = document.getElementById("open-feedback-modal-footer");
Â Â Â Â Â Â Â Â openFeedbackFooter.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â setupFeedbackModal();
Â Â Â Â Â Â Â Â feedbackModal.style.display = "flex";
Â Â Â Â Â Â Â Â thankYouMessage.style.display = "none"; // Hide thank you message if shown before
Â Â Â Â });
}

openFeedbackModal();

/**
Â * Setupusermanual function.
Â *
Â * @returns {void}
Â */

function setupUserManual() {
Â Â Â Â openUserManual.addEventListener("click", () => {
Â Â Â Â Â Â Â Â hideMainMenu(); // Hide the menu when clicking

Â Â Â Â Â Â Â Â // Disable button briefly to prevent multiple clicks
Â Â Â Â Â Â Â Â openUserManual.disabled = true;

Â Â Â Â Â Â Â Â // Redirect to the User Manual page after a short delay
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â window.location.href = "user-manual.html"; // âœ… Opens the manual page
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Re-enable button after navigation (won't matter much since page changes)
Â Â Â Â Â Â Â Â Â Â Â Â openUserManual.disabled = false;
Â Â Â Â Â Â Â Â }, 200);
Â Â Â Â });
}



/**
Â * Setupabout function.
Â *
Â * @returns {void}
Â */

function setupAbout() {
Â Â Â Â const aboutModal = document.getElementById("about-modal");
Â Â Â Â const openAboutBtn = document.getElementById("open-about-modal");
Â Â Â Â const closeAboutBtn = aboutModal.querySelector(".close-modal");

Â Â Â Â // Open Modal
Â Â Â Â openAboutBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â aboutModal.style.display = "flex";
Â Â Â Â });

Â Â Â Â // Close Modal
Â Â Â Â closeAboutBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â aboutModal.style.display = "none";
Â Â Â Â });

Â Â Â Â // Close Modal on Outside Click
Â Â Â Â window.addEventListener("click", (event) => {
Â Â Â Â Â Â Â Â if (event.target === aboutModal) {
Â Â Â Â Â Â Â Â Â Â Â Â aboutModal.style.display = "none";
Â Â Â Â Â Â Â Â }
Â Â Â Â });
}


/**
Â * Assigncyclevariables function.
Â *
Â * @returns {void}
Â */

// âœ… AFTER (Schema 2.5 Only):
function assignCycleVariables() {
Â Â Â Â console.log('ğŸ”„ Assigning cycle variables (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for assignCycleVariables');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data required');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Retrieved cycle data:', {
Â Â Â Â Â Â Â Â activeCycle: schemaData.activeCycle,
Â Â Â Â Â Â Â Â cycleCount: Object.keys(schemaData.cycles).length
Â Â Â Â });
Â Â Â Â 
Â Â Â Â return {
Â Â Â Â Â Â Â Â lastUsedMiniCycle: schemaData.activeCycle,
Â Â Â Â Â Â Â Â savedMiniCycles: schemaData.cycles
Â Â Â Â };
}

/**
Â * Updateprogressbar function.
Â *
Â * @returns {void}
Â */

function updateProgressBar() {
Â Â Â Â const totalTasks = taskList.children.length;
Â Â Â Â const completedTasks = [...taskList.children].filter(task => task.querySelector("input").checked).length;
Â Â Â Â const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
Â Â Â Â 
Â Â Â Â // âœ… Add consistent animation for all progress updates
Â Â Â Â progressBar.style.transition = "width 0.2s ease-out";
Â Â Â Â progressBar.style.width = `${progress}%`;
Â Â Â Â 
Â Â Â Â // âœ… Clear transition after animation
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â progressBar.style.transition = "";
Â Â Â Â }, 200);
Â Â Â Â 
Â Â Â Â autoSave();
}


/**
Â * Checkminicycle function.
Â *
Â * @returns {void}
Â */

function checkMiniCycle() {
Â Â Â Â const allCompleted = [...taskList.children].every(task => task.querySelector("input").checked);

Â Â Â Â // âœ… Retrieve miniCycle variables
Â Â Â Â const { lastUsedMiniCycle, savedMiniCycles } = assignCycleVariables();
Â Â Â Â let cycleData = savedMiniCycles[lastUsedMiniCycle];

Â Â Â Â if (!lastUsedMiniCycle || !cycleData) {
Â Â Â Â Â Â Â Â console.warn("âš  No active miniCycle found.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â Â updateProgressBar();

Â Â Â Â // âœ… Only trigger reset if ALL tasks are completed AND autoReset is enabled
Â Â Â Â if (allCompleted && taskList.children.length > 0) {
Â Â Â Â Â Â Â Â console.log(`âœ… All tasks completed for "${lastUsedMiniCycle}"`);

Â Â Â Â Â Â Â Â // âœ… Auto-reset: Only reset if AutoReset is enabled
Â Â Â Â Â Â Â Â if (cycleData.autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ”„ AutoReset is ON. Resetting tasks for "${lastUsedMiniCycle}"...`);
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â resetTasks(); // âœ… Then reset tasks
Â Â Â Â Â Â Â Â Â Â Â Â }, 1000);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â console.log("ran check MiniCyle function");
Â Â Â Â updateProgressBar();
Â Â Â Â updateStatsPanel();
Â Â Â Â autoSave();
Â Â Â Â console.log("ran check MiniCyle function2");
}

/**
Â * Incrementcyclecount function.
Â *
Â * @param {any} miniCycleName - Description.
Â * @param {any} savedMiniCycles - Description. * @returns {void}
Â */

function incrementCycleCount(miniCycleName, savedMiniCycles) {
Â Â Â Â console.log('ğŸ”¢ Incrementing cycle count (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for incrementCycleCount');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!cycleData) {
Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Cycle "${activeCycle}" not found in Schema 2.5`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Current cycle count:', cycleData.cycleCount || 0);
Â Â Â Â 
Â Â Â Â // Increment cycle count
Â Â Â Â cycleData.cycleCount = (cycleData.cycleCount || 0) + 1;
Â Â Â Â 
Â Â Â Â console.log('ğŸ“ˆ New cycle count:', cycleData.cycleCount);
Â Â Â Â 
Â Â Â Â // Update the full schema data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â 
Â Â Â Â // Update user progress
Â Â Â Â fullSchemaData.userProgress.cyclesCompleted = (fullSchemaData.userProgress.cyclesCompleted || 0) + 1;
Â Â Â Â 
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log(`âœ… Cycle count updated (Schema 2.5) for "${activeCycle}": ${cycleData.cycleCount}`);
Â Â Â Â console.log('ğŸ‘¥ Total user cycles completed:', fullSchemaData.userProgress.cyclesCompleted);
Â Â Â Â 
Â Â Â Â // âœ… Handle milestone rewards
Â Â Â Â handleMilestoneUnlocks(activeCycle, cycleData.cycleCount);
Â Â Â Â 
Â Â Â Â // âœ… Show animation + update stats
Â Â Â Â showCompletionAnimation();
Â Â Â Â updateStatsPanel();
}

function handleMilestoneUnlocks(miniCycleName, cycleCount) {
Â Â Â Â console.log('ğŸ† Handling milestone unlocks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Show milestone achievement message
Â Â Â Â checkForMilestone(miniCycleName, cycleCount);

Â Â Â Â // âœ… Theme unlocks
Â Â Â Â if (cycleCount >= 5) {
Â Â Â Â Â Â Â Â unlockDarkOceanTheme();
Â Â Â Â }
Â Â Â Â if (cycleCount >= 50) {
Â Â Â Â Â Â Â Â unlockGoldenGlowTheme();
Â Â Â Â }

Â Â Â Â // âœ… Game unlock
Â Â Â Â if (cycleCount >= 100) {
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for game unlock');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const hasGameUnlock = schemaData.settings.unlockedFeatures.includes("task-order-game");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!hasGameUnlock) {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("ğŸ® Game Unlocked! 'Task Order' is now available in the Games menu.", "success", 6000);
Â Â Â Â Â Â Â Â Â Â Â Â unlockMiniGame();
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Milestone unlocks processed (Schema 2.5)');
}

function unlockMiniGame() {
Â Â Â Â console.log('ğŸ® Unlocking mini game (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for unlockMiniGame');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!schemaData.settings.unlockedFeatures.includes("task-order-game")) {
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.unlockedFeatures.push("task-order-game");
Â Â Â Â Â Â Â Â fullSchemaData.userProgress.rewardMilestones.push("task-order-game-100");
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("ğŸ® Task Order Game unlocked in Schema 2.5!");
Â Â Â Â }
Â Â Â Â 
Â Â Â Â checkGamesUnlock();
}

function unlockDarkOceanTheme() {
Â Â Â Â console.log("ğŸŒŠ Unlocking Dark Ocean theme (Schema 2.5 only)...");
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for unlockDarkOceanTheme');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!schemaData.settings.unlockedThemes.includes("dark-ocean")) {
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.unlockedThemes.push("dark-ocean");
Â Â Â Â Â Â Â Â fullSchemaData.userProgress.rewardMilestones.push("dark-ocean-5");
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("ğŸ¨ Dark Ocean theme unlocked in Schema 2.5!");
Â Â Â Â Â Â Â Â refreshThemeToggles();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Show the theme option in menu
Â Â Â Â Â Â Â Â const themeContainer = document.querySelector('.theme-container');
Â Â Â Â Â Â Â Â if (themeContainer) {
Â Â Â Â Â Â Â Â Â Â Â Â themeContainer.classList.remove('hidden');
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… Show the Themes Button Immediately
Â Â Â Â Â Â Â Â const themeButton = document.getElementById("open-themes-panel");
Â Â Â Â Â Â Â Â if (themeButton) {
Â Â Â Â Â Â Â Â Â Â Â Â themeButton.style.display = "block";
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â showNotification('ğŸ‰ New theme unlocked: Dark Ocean! Check the menu to activate it.', 'success', 5000);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('â„¹ï¸ Dark Ocean theme already unlocked');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â refreshThemeToggles();
}

function unlockGoldenGlowTheme() {
Â Â Â Â console.log("ğŸŒŸ Unlocking Golden Glow theme (Schema 2.5 only)...");
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for unlockGoldenGlowTheme');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!schemaData.settings.unlockedThemes.includes("golden-glow")) {
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.settings.unlockedThemes.push("golden-glow");
Â Â Â Â Â Â Â Â fullSchemaData.userProgress.rewardMilestones.push("golden-glow-50");
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("ğŸ¨ Golden Glow theme unlocked in Schema 2.5!");
Â Â Â Â Â Â Â Â refreshThemeToggles();

Â Â Â Â Â Â Â Â // Show the theme container (if hidden)
Â Â Â Â Â Â Â Â const themeContainer = document.querySelector('.theme-container');
Â Â Â Â Â Â Â Â if (themeContainer) {
Â Â Â Â Â Â Â Â Â Â Â Â themeContainer.classList.remove('hidden');
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // Show the theme toggle if it exists
Â Â Â Â Â Â Â Â const themeButton = document.getElementById("open-themes-panel");
Â Â Â Â Â Â Â Â if (themeButton) {
Â Â Â Â Â Â Â Â Â Â Â Â themeButton.style.display = "block";
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â showNotification("ğŸŒŸ New theme unlocked: Golden Glow! Check the themes menu to activate it.", "success", 5000);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.log('â„¹ï¸ Golden Glow theme already unlocked');
Â Â Â Â }
}



function initializeThemesPanel() {
Â Â Â Â console.log("ğŸŒˆ Initializing Theme Panel");

Â Â Â Â const existingContainer = document.querySelector('.theme-container');
Â Â Â Â if (existingContainer) return; // Prevent duplicates

Â Â Â Â const themeContainer = document.createElement('div');
Â Â Â Â themeContainer.className = 'theme-container';
Â Â Â Â themeContainer.id = 'theme-container';

Â Â Â Â const themeOptionContainer = document.createElement('div');
Â Â Â Â themeOptionContainer.className = 'theme-option-container';
Â Â Â Â themeOptionContainer.id = 'theme-option-container'; // ğŸ‘ˆ We'll update this later

Â Â Â Â themeContainer.appendChild(themeOptionContainer);

Â Â Â Â // Inject into modal
Â Â Â Â const themeSection = document.getElementById("theme-options-section");
Â Â Â Â themeSection.appendChild(themeContainer);

Â Â Â Â // Setup toggle logic
Â Â Â Â refreshThemeToggles(); // â¬… Run this on load
}

// âœ… Rebuild toggles based on unlocked themes (Schema 2.5 only)
function refreshThemeToggles() {
Â Â Â Â console.log('ğŸ¨ Refreshing theme toggles (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const container = document.getElementById("theme-option-container");
Â Â Â Â if (!container) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Theme option container not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â container.innerHTML = ""; // ğŸ§¹ Clear current options

Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for refreshThemeToggles');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const unlockedThemes = schemaData.settings.unlockedThemes || [];
Â Â Â Â const currentTheme = schemaData.settings.theme || 'default';
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Theme data from Schema 2.5:', {
Â Â Â Â Â Â Â Â unlockedThemes,
Â Â Â Â Â Â Â Â currentTheme,
Â Â Â Â Â Â Â Â unlockedCount: unlockedThemes.length
Â Â Â Â });

Â Â Â Â const themeList = [
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â id: "DarkOcean",
Â Â Â Â Â Â Â Â Â Â class: "dark-ocean",
Â Â Â Â Â Â Â Â Â Â label: "Dark Ocean Theme ğŸŒŠ",
Â Â Â Â Â Â Â Â Â Â unlockKey: "dark-ocean"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â id: "GoldenGlow",
Â Â Â Â Â Â Â Â Â Â class: "golden-glow",
Â Â Â Â Â Â Â Â Â Â label: "Golden Glow Theme ğŸŒŸ",
Â Â Â Â Â Â Â Â Â Â unlockKey: "golden-glow"
Â Â Â Â Â Â Â Â }
Â Â Â Â ];

Â Â Â Â themeList.forEach(theme => {
Â Â Â Â Â Â Â Â if (!unlockedThemes.includes(theme.unlockKey)) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ”’ Theme ${theme.unlockKey} not unlocked, skipping`);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â console.log(`ğŸ¨ Adding theme toggle for: ${theme.label}`);

Â Â Â Â Â Â Â Â const label = document.createElement("label");
Â Â Â Â Â Â Â Â label.className = "custom-checkbox";
Â Â Â Â Â Â Â Â label.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â <input type="checkbox" id="toggle${theme.id}Theme" class="theme-toggle">
Â Â Â Â Â Â Â Â Â Â Â Â <span class="checkmark"></span>
Â Â Â Â Â Â Â Â Â Â Â Â ${theme.label}
Â Â Â Â Â Â Â Â `;

Â Â Â Â Â Â Â Â container.appendChild(label);

Â Â Â Â Â Â Â Â const checkbox = label.querySelector("input");
Â Â Â Â Â Â Â Â checkbox.checked = currentTheme === theme.class;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log(`ğŸ”˜ Theme ${theme.class} checked:`, checkbox.checked);

Â Â Â Â Â Â Â Â checkbox.addEventListener("change", function () {
Â Â Â Â Â Â Â Â Â Â Â Â if (this.checked) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ¨ Applying theme: ${theme.class}`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".theme-toggle").forEach(cb => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (cb !== this) cb.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â applyTheme(theme.class);
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¨ Applying default theme');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â applyTheme("default");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â });
Â Â Â Â 
Â Â Â Â console.log('âœ… Theme toggles refreshed successfully');
}

// âœ… Close Themes Modal when clicking outside of the modal content
window.addEventListener("click", (event) => {
Â Â Â Â const themesModal = document.getElementById("themes-modal");
Â Â Â Â 

Â Â Â Â // Only close if you click on the background (not inside modal)
Â Â Â Â if (event.target === themesModal) {
Â Â Â Â Â Â Â Â themesModal.style.display = "none";
Â Â Â Â }
});

/**
Â * Showcompletionanimation function.
Â *
Â * @returns {void}
Â */

function showCompletionAnimation() {
Â Â Â Â const animation = document.createElement("div");
Â Â Â Â animation.classList.add("mini-cycle-complete-animation");
Â Â //Â  animation.innerHTML = "âœ… miniCycle Completed!";Â 
Â Â animation.innerHTML = "âœ”";Â 

Â Â Â Â document.body.appendChild(animation);

Â Â Â Â // âœ… Remove the animation after 1.5 seconds
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â animation.remove();
Â Â Â Â }, 1500);
}

/**
Â * Checkformilestone function.
Â *
Â * @param {any} miniCycleName - Description.
Â * @param {any} cycleCount - Description. * @returns {void}
Â */

function checkForMilestone(miniCycleName, cycleCount) {
Â Â Â Â const milestoneLevels = [10, 25, 50, 100, 200, 500, 1000];

Â Â Â Â if (milestoneLevels.includes(cycleCount)) {
Â Â Â Â Â Â Â Â showMilestoneMessage(miniCycleName, cycleCount);
Â Â Â Â }
}

/**
Â * Displays a milestone achievement message when a user reaches a specific cycle count.
Â *
Â * @param {string} miniCycleName - The name of the miniCycle.
Â * @param {number} cycleCount - The number of cycles completed.
Â */

function showMilestoneMessage(miniCycleName, cycleCount) {
Â Â Â Â const message = `ğŸ‰ You've completed ${cycleCount} cycles for "${miniCycleName}"! Keep going! ğŸš€`;

Â Â Â Â // âœ… Create a notification-like popup
Â Â Â Â const milestonePopup = document.createElement("div");
Â Â Â Â milestonePopup.classList.add("mini-cycle-milestone");
Â Â Â Â milestonePopup.textContent = message;

Â Â Â Â document.body.appendChild(milestonePopup);

Â Â Â Â // âœ… Automatically remove the message after 3 seconds
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â milestonePopup.remove();
Â Â Â Â }, 3000);
}

Â Â Â Â /***********************
Â *Â 
Â *Â 
Â * Rearrange Management Logic
Â *Â 
Â *Â 
Â ************************/


/**
Â * Draganddrop function.
Â *
Â * @param {any} taskElement - Description. * @returns {void}
Â */

function DragAndDrop(taskElement) {
Â 

Â Â Â Â // Prevent text selection on mobile
Â Â Â Â taskElement.style.userSelect = "none";
Â Â Â Â taskElement.style.webkitUserSelect = "none";
Â Â Â Â taskElement.style.msUserSelect = "none";
Â Â Â Â let readyToDrag = false;Â 
Â Â Â Â let touchStartX = 0;
Â Â Â Â let touchStartY = 0;
Â Â Â Â let holdTimeout = null;
Â Â Â Â let isDragging = false;
Â Â Â Â let isLongPress = false;
Â Â Â Â let isTap = false;
Â Â Â Â let preventClick = false;
Â Â Â Â const moveThreshold = 15; // ğŸš€ Movement threshold for long press

Â Â Â Â // ğŸ“± **Touch-based Drag for Mobile**
Â Â Â Â taskElement.addEventListener("touchstart", (event) => {
Â Â Â Â Â Â Â Â if (event.target.closest(".task-options")) return;
Â Â Â Â Â Â Â Â isLongPress = false;
Â Â Â Â Â Â Â Â isDragging = false;
Â Â Â Â Â Â Â Â isTap = true;Â 
Â Â Â Â Â Â Â Â readyToDrag = false;Â 
Â Â Â Â Â Â Â Â touchStartX = event.touches[0].clientX;
Â Â Â Â Â Â Â Â touchStartY = event.touches[0].clientY;
Â Â Â Â Â Â Â Â preventClick = false;

Â Â Â Â Â Â Â Â // âœ… NEW FIX: Remove `.long-pressed` from all other tasks before long press starts
Â Â Â Â Â Â Â Â document.querySelectorAll(".task").forEach(task => {
Â Â Â Â Â Â Â Â Â Â Â Â if (task !== taskElement) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("long-pressed");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hideTaskButtons(task);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â holdTimeout = setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â isLongPress = true;
Â Â Â Â Â Â Â Â Â Â Â Â isTap = false;
Â Â Â Â Â Â Â Â Â Â Â Â draggedTask = taskElement;
Â Â Â Â Â Â Â Â Â Â Â Â isDragging = true;
Â Â Â Â Â Â Â Â Â Â Â Â taskElement.classList.add("dragging", "long-pressed");

Â Â Â Â Â Â Â Â Â Â Â Â event.preventDefault();

Â Â Â Â Â Â Â Â Â Â Â Â console.log("ğŸ“± Long Press Detected - Showing Task Options", taskElement);

Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Ensure task options remain visible
Â Â Â Â Â Â Â Â Â Â Â Â revealTaskButtons(taskElement);

Â Â Â Â Â Â Â Â }, 500); // Long-press delay (500ms)
Â Â Â Â });

Â Â Â Â taskElement.addEventListener("touchmove", (event) => {
Â Â Â Â Â Â Â Â const touchMoveX = event.touches[0].clientX;
Â Â Â Â Â Â Â Â const touchMoveY = event.touches[0].clientY;
Â Â Â Â Â Â Â Â const deltaX = Math.abs(touchMoveX - touchStartX);
Â Â Â Â Â Â Â Â const deltaY = Math.abs(touchMoveY - touchStartY);

Â Â Â Â Â Â Â Â // âœ… Cancel long press if moving too much
Â Â Â Â Â Â Â Â if (deltaX > moveThreshold || deltaY > moveThreshold) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(holdTimeout);
Â Â Â Â Â Â Â Â Â Â Â Â isLongPress = false;
Â Â Â Â Â Â Â Â Â Â Â Â isTap = false; // âœ… Prevent accidental taps after dragging
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… Allow normal scrolling if moving vertically
Â Â Â Â Â Â Â Â if (deltaY > deltaX) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(holdTimeout);
Â Â Â Â Â Â Â Â Â Â Â Â isTap = false;
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â if (isLongPress && readyToDrag && !isDragging) {
Â Â Â Â Â Â Â Â Â Â Â Â taskElement.setAttribute("draggable", "true");
Â Â Â Â Â Â Â Â Â Â Â Â isDragging = true;

Â Â Â Â Â Â Â Â Â Â Â Â if (event.cancelable) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â event.preventDefault();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â if (isDragging && draggedTask) {
Â Â Â Â Â Â Â Â Â Â Â Â if (event.cancelable) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â event.preventDefault();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â const movingTask = document.elementFromPoint(event.touches[0].clientX, event.touches[0].clientY);
Â Â Â Â Â Â Â Â Â Â Â Â if (movingTask) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â handleRearrange(movingTask, event);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â taskElement.addEventListener("touchend", () => {
Â Â Â Â Â Â Â Â clearTimeout(holdTimeout);

Â Â Â Â Â Â Â Â if (isTap) {
Â Â Â Â Â Â Â Â Â Â Â Â preventClick = true;
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â preventClick = false;Â 
Â Â Â Â Â Â Â Â Â Â Â Â }, 100);
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â if (draggedTask) {
Â Â Â Â Â Â Â Â Â Â Â Â draggedTask.classList.remove("dragging", "rearranging");
Â Â Â Â Â Â Â Â Â Â Â Â draggedTask = null;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â isDragging = false;

Â Â Â Â Â Â Â Â // âœ… Ensure task options remain open only when a long press is detected
Â Â Â Â Â Â Â Â if (isLongPress) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log("âœ… Long Press Completed - Keeping Task Options Open", taskElement);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â taskElement.classList.remove("long-pressed");
Â Â Â Â });

Â Â Â Â // ğŸ–±ï¸ **Mouse-based Drag for Desktop**
Â Â Â Â taskElement.addEventListener("dragstart", (event) => {
Â Â Â Â Â Â Â Â if (event.target.closest(".task-options")) return;
Â Â Â Â Â Â Â Â draggedTask = taskElement;
Â Â Â Â Â Â Â Â event.dataTransfer.setData("text/plain", "");

Â Â Â Â Â Â Â Â // âœ… NEW: Add dragging class for desktop as well
Â Â Â Â Â Â Â Â taskElement.classList.add("dragging");

Â Â Â Â Â Â Â Â // âœ… Hide ghost image on desktop
Â Â Â Â Â Â Â Â if (!isTouchDevice()) {
Â Â Â Â Â Â Â Â Â Â Â Â const transparentPixel = new Image();
Â Â Â Â Â Â Â Â Â Â Â Â transparentPixel.src = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
Â Â Â Â Â Â Â Â Â Â Â Â event.dataTransfer.setDragImage(transparentPixel, 0, 0);
Â Â Â Â Â Â Â Â }
Â Â Â Â });

}


let rearrangeTimeout; // Prevents excessive reordering calls

/**
Â * Handles the rearrangement of tasks when dragged.
Â *
Â * @param {HTMLElement} target - The task element being moved.
Â * @param {DragEvent | TouchEvent} event - The event triggering the rearrangement.
Â */

const REARRANGE_DELAY = 75; // ms delay to smooth reordering

function handleRearrange(target, event) {
Â Â if (!target || !draggedTask || target === draggedTask) return;

Â Â clearTimeout(rearrangeTimeout);

Â Â rearrangeTimeout = setTimeout(() => {
Â Â Â Â if (!document.contains(target) || !document.contains(draggedTask)) return;

Â Â Â Â const parent = draggedTask.parentNode;
Â Â Â Â if (!parent || !target.parentNode) return;

Â Â Â Â const bounding = target.getBoundingClientRect();
Â Â Â Â const offset = event.clientY - bounding.top;

Â Â Â Â // ğŸ§  Snapshot only if enough time has passed
Â Â Â Â const now = Date.now();
Â Â Â Â if (now - lastReorderTime > REORDER_SNAPSHOT_INTERVAL) {
Â Â Â Â Â Â pushUndoSnapshot();
Â Â Â Â Â Â lastReorderTime = now;
Â Â Â Â Â Â didDragReorderOccur = true;
Â Â Â Â }

Â Â Â Â const isLastTask = !target.nextElementSibling;
Â Â Â Â const isFirstTask = !target.previousElementSibling;

Â Â Â Â document.querySelectorAll(".drop-target").forEach(el => el.classList.remove("drop-target"));

Â Â Â Â if (isLastTask && target.nextSibling !== draggedTask) {
Â Â Â Â Â Â parent.appendChild(draggedTask);
Â Â Â Â Â Â draggedTask.classList.add("drop-target");
Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â if (isFirstTask && target.previousSibling !== draggedTask) {
Â Â Â Â Â Â parent.insertBefore(draggedTask, parent.firstChild);
Â Â Â Â Â Â draggedTask.classList.add("drop-target");
Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â if (offset > bounding.height / 3) {
Â Â Â Â Â Â if (target.nextSibling !== draggedTask) {
Â Â Â Â Â Â Â Â parent.insertBefore(draggedTask, target.nextSibling);
Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â if (target.previousSibling !== draggedTask) {
Â Â Â Â Â Â Â Â parent.insertBefore(draggedTask, target);
Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â draggedTask.classList.add("drop-target");
Â Â }, REARRANGE_DELAY);
}



/**
Â * Setuprearrange function.
Â *
Â * @returns {void}
Â */

function setupRearrange() {
Â Â if (window.rearrangeInitialized) return;
Â Â window.rearrangeInitialized = true;

Â Â document.addEventListener("dragover", (event) => {
Â Â Â Â event.preventDefault();
Â Â Â Â requestAnimationFrame(() => {
Â Â Â Â Â Â const movingTask = event.target.closest(".task");
Â Â Â Â Â Â if (movingTask) {
Â Â Â Â Â Â Â Â handleRearrange(movingTask, event);
Â Â Â Â Â Â Â Â // âŒ Don't save yet â€” just rearrange visually
Â Â Â Â Â Â }
Â Â Â Â });
Â Â });

Â Â document.addEventListener("drop", (event) => {
Â Â Â Â event.preventDefault();
Â Â Â Â if (!draggedTask) return;

Â Â Â Â if (didDragReorderOccur) {
Â Â Â Â Â Â saveCurrentTaskOrder();
Â Â Â Â Â Â autoSave();
Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â checkCompleteAllButton();

Â Â Â Â Â Â document.getElementById("undo-btn").hidden = false;
Â Â Â Â Â Â document.getElementById("redo-btn").hidden = true;

Â Â Â Â Â Â console.log("ğŸ” Drag reorder completed and saved with undo snapshot.");
Â Â Â Â }

Â Â Â Â cleanupDragState();
Â Â Â Â lastReorderTime = 0;
Â Â didDragReorderOccur = false;
Â Â });
}



/**
Â * Cleanupdragstate function.
Â *
Â * @returns {void}
Â */

function cleanupDragState() {
Â Â Â Â if (draggedTask) {
Â Â Â Â Â Â Â Â draggedTask.classList.remove("dragging", "rearranging");
Â Â Â Â Â Â Â Â draggedTask = null;
Â Â Â Â }

Â Â Â Â lastRearrangeTarget = null;
Â Â Â Â document.querySelectorAll(".drop-target").forEach(el => el.classList.remove("drop-target"));
}



/**
Â * Dragendcleanup function.
Â *
Â * @returns {void}
Â */

function dragEndCleanup () {
Â Â Â Â document.addEventListener("drop", cleanupDragState);
Â Â Â Â document.addEventListener("dragover", () => {
Â Â Â Â Â Â Â Â document.querySelectorAll(".rearranging").forEach(task => task.classList.remove("rearranging"));
Â Â Â Â });
Â Â Â Â 
Â Â Â Â 
Â Â Â Â }
/**
Â * Updatemovearrowsvisibility function.
Â *
Â * @returns {void}
Â */
function updateMoveArrowsVisibility() {
Â Â Â Â console.log('ğŸ”„ Updating move arrows visibility (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Try Schema 2.5 first
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â let showArrows = false;
Â Â Â Â 
Â Â Â Â if (schemaData) {
Â Â Â Â Â Â Â Â showArrows = schemaData.settings.showMoveArrows || false;
Â Â Â Â } else {
Â Â Â Â Â Â Â Â // âœ… Fallback to legacy (this shouldn't happen in Schema 2.5 only app)
Â Â Â Â Â Â Â Â showArrows = localStorage.getItem("miniCycleMoveArrows") === "true";
Â Â Â Â }

Â Â Â Â document.querySelectorAll(".move-btn").forEach(button => {
Â Â Â Â Â Â Â Â button.style.visibility = showArrows ? "visible" : "hidden";
Â Â Â Â Â Â Â Â button.style.opacity = showArrows ? "1" : "0";
Â Â Â Â });

Â Â Â Â // âœ… Ensure `.task-options` remains interactive
Â Â Â Â document.querySelectorAll(".task-options").forEach(options => {
Â Â Â Â Â Â Â Â options.style.pointerEvents = "auto"; // ğŸ”¥ Fixes buttons becoming unclickable
Â Â Â Â });

Â Â Â Â console.log("âœ… Move Arrows Toggled (Schema 2.5)");
Â Â Â Â 
Â Â Â Â toggleArrowVisibility();
Â Â Â Â dragEndCleanup();
}

/**
Â * Togglearrowvisibility function.
Â *
Â * @returns {void}
Â */
function toggleArrowVisibility() {
Â Â Â Â console.log('ğŸ”„ Toggling arrow visibility (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Try Schema 2.5 first
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â let showArrows = false;
Â Â Â Â 
Â Â Â Â if (schemaData) {
Â Â Â Â Â Â Â Â showArrows = schemaData.settings.showMoveArrows || false;
Â Â Â Â } else {
Â Â Â Â Â Â Â Â // âœ… Fallback to legacy (this shouldn't happen in Schema 2.5 only app)
Â Â Â Â Â Â Â Â showArrows = localStorage.getItem("miniCycleMoveArrows") === "true";
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const allTasks = document.querySelectorAll(".task");

Â Â Â Â allTasks.forEach((task, index) => {
Â Â Â Â Â Â Â Â const upButton = task.querySelector('.move-up');
Â Â Â Â Â Â Â Â const downButton = task.querySelector('.move-down');
Â Â Â Â Â Â Â Â const taskOptions = task.querySelector('.task-options'); // âœ… Select task options
Â Â Â Â Â Â Â Â const taskButtons = task.querySelectorAll('.task-btn'); // âœ… Select all task buttons

Â Â Â Â Â Â Â Â if (upButton) {
Â Â Â Â Â Â Â Â Â Â Â Â upButton.style.visibility = (showArrows && index !== 0) ? "visible" : "hidden";
Â Â Â Â Â Â Â Â Â Â Â Â upButton.style.opacity = (showArrows && index !== 0) ? "1" : "0";
Â Â Â Â Â Â Â Â Â Â Â Â upButton.style.pointerEvents = showArrows ? "auto" : "none";Â 
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (downButton) {
Â Â Â Â Â Â Â Â Â Â Â Â downButton.style.visibility = (showArrows && index !== allTasks.length - 1) ? "visible" : "hidden";
Â Â Â Â Â Â Â Â Â Â Â Â downButton.style.opacity = (showArrows && index !== allTasks.length - 1) ? "1" : "0";
Â Â Â Â Â Â Â Â Â Â Â Â downButton.style.pointerEvents = showArrows ? "auto" : "none";Â 
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… Ensure task options remain interactive
Â Â Â Â Â Â Â Â if (taskOptions) {
Â Â Â Â Â Â Â Â Â Â Â Â taskOptions.style.pointerEvents = "auto";Â Â 
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // âœ… Ensure individual buttons remain interactive
Â Â Â Â Â Â Â Â taskButtons.forEach(button => {
Â Â Â Â Â Â Â Â Â Â Â Â button.style.pointerEvents = "auto";
Â Â Â Â Â Â Â Â });
Â Â Â Â });

Â Â Â Â console.log(`âœ… Move arrows and buttons are now ${showArrows ? "enabled" : "disabled"} (Schema 2.5)`);
}
Â Â Â Â 
Â Â Â Â /***********************
Â *Â 
Â *Â 
Â * Task Management
Â *Â 
Â *Â 
Â ************************/
Â Â Â Â /**
Â Â Â Â Â * Adds a new task to the list.
Â Â Â Â Â * @param {string} taskText - The task description.
Â Â Â Â Â * @param {boolean} [completed=false] - Whether the task starts as completed.
Â Â Â Â Â * @param {boolean} [shouldSave=true] - If true, the task is saved.
Â Â Â Â Â * @param {string|null} [dueDate=null] - Optional due date.
Â Â Â Â Â * @param {boolean} [highPriority=false] - If true, the task is marked as high priority.
Â Â Â Â Â * @param {boolean} [isLoading=false] - If true, task is loaded from storage.
Â Â Â Â Â * @param {boolean} [remindersEnabled=false] - If true, reminders are turned on.
Â Â Â Â Â */


Â Â Â Â 
function addTask(taskText, completed = false, shouldSave = true, dueDate = null, highPriority = null, isLoading = false, remindersEnabled = false, recurring = false, taskId = null, recurringSettings = {}) {
Â Â Â Â Â 
Â Â Â Â if (typeof taskText !== "string") {
Â Â Â Â Â Â Â Â console.error("âŒ Error: taskText is not a string", taskText);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // â›‘ï¸ Sanitize input early to avoid unsafe values spreading
Â Â Â Â let taskTextTrimmed = sanitizeInput(taskText.trim());
Â Â Â Â if (!taskTextTrimmed) {
Â Â Â Â Â Â Â Â console.warn("âš  Skipping empty or unsafe task.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (taskTextTrimmed.length > TASK_LIMIT) {
Â Â Â Â Â Â Â Â showNotification(`Task must be ${TASK_LIMIT} characters or less.`);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â console.log('ğŸ“ Adding task (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for addTask');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle, settings, reminders } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â console.error("âŒ No active cycle found in Schema 2.5 for addTask");
Â Â Â Â Â Â Â Â throw new Error('No active cycle found');
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Active cycle found:', activeCycle);

Â Â Â Â const cycleTasks = currentCycle.tasks || [];
Â Â Â Â 
Â Â Â Â // âœ… Get settings from Schema 2.5
Â Â Â Â const autoResetEnabled = currentCycle.autoReset || false;
Â Â Â Â const remindersEnabledGlobal = reminders?.enabled === true;
Â Â Â Â 
Â Â Â Â // âœ… Use the passed-in taskId if it exists, otherwise generate a new one
Â Â Â Â const assignedTaskId = taskId || `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
Â Â Â Â 
Â Â Â Â console.log('ğŸ†” Assigned task ID:', assignedTaskId);
Â Â Â Â 
Â Â Â Â // âœ… Get required DOM elements
Â Â Â Â const taskList = document.getElementById("taskList");
Â Â Â Â const taskInput = document.getElementById("taskInput");
Â Â Â Â 
Â Â Â Â // âœ… Create Task Element
Â Â Â Â const taskItem = document.createElement("li");
Â Â Â Â taskItem.classList.add("task");
Â Â Â Â taskItem.setAttribute("draggable", "true");
Â Â Â Â taskItem.dataset.taskId = assignedTaskId;
Â Â Â Â 
Â Â Â Â if (highPriority) {
Â Â Â Â Â Â Â Â taskItem.classList.add("high-priority");
Â Â Â Â }

Â Â Â Â const hasValidRecurringSettings = recurring && recurringSettings && Object.keys(recurringSettings).length > 0;
Â Â Â Â if (hasValidRecurringSettings) {
Â Â Â Â Â Â Â Â taskItem.classList.add("recurring");
Â Â Â Â Â Â Â Â taskItem.setAttribute("data-recurring-settings", JSON.stringify(recurringSettings));
Â Â Â Â }

Â Â Â Â // âœ… Three Dots Menu from Schema 2.5 settings
Â Â Â Â const showThreeDots = settings.showThreeDots || false;
Â Â Â Â if (showThreeDots) {
Â Â Â Â Â Â Â Â const threeDotsButton = document.createElement("button");
Â Â Â Â Â Â Â Â threeDotsButton.classList.add("three-dots-btn");
Â Â Â Â Â Â Â Â threeDotsButton.innerHTML = "â‹®";
Â Â Â Â Â Â Â Â threeDotsButton.addEventListener("click", (event) => {
Â Â Â Â Â Â Â Â Â Â Â Â event.stopPropagation();
Â Â Â Â Â Â Â Â Â Â Â Â revealTaskButtons(taskItem);
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â taskItem.appendChild(threeDotsButton);
Â Â Â Â }

Â Â Â Â // âœ… Create Button Container
Â Â Â Â const buttonContainer = document.createElement("div");
Â Â Â Â buttonContainer.classList.add("task-options");

Â Â Â Â // âœ… Create or update task in Schema 2.5
Â Â Â Â let existingTask = cycleTasks.find(task => task.id === assignedTaskId);
Â Â Â Â if (!existingTask) {
Â Â Â Â Â Â Â Â console.log('ğŸ“‹ Creating new task in Schema 2.5');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â existingTask = {
Â Â Â Â Â Â Â Â Â Â Â Â id: assignedTaskId,
Â Â Â Â Â Â Â Â Â Â Â Â text: taskTextTrimmed,
Â Â Â Â Â Â Â Â Â Â Â Â completed,
Â Â Â Â Â Â Â Â Â Â Â Â dueDate,
Â Â Â Â Â Â Â Â Â Â Â Â highPriority,
Â Â Â Â Â Â Â Â Â Â Â Â remindersEnabled,
Â Â Â Â Â Â Â Â Â Â Â Â recurring,
Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings,
Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â currentCycle.tasks.push(existingTask);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Save recurring template in Schema 2.5
Â Â Â Â Â Â Â Â if (recurring && recurringSettings) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ” Saving recurring template');
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (!currentCycle.recurringTemplates) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates = {};
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates[assignedTaskId] = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: assignedTaskId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: taskTextTrimmed,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings: structuredClone(recurringSettings),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â highPriority: highPriority || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDate: dueDate || null,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â remindersEnabled: remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lastTriggeredTimestamp: null,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Save to Schema 2.5
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Task saved to Schema 2.5');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const deleteCheckedEnabled = currentCycle.deleteCheckedTasks || false;
Â Â Â Â const showRecurring = !autoResetEnabled && deleteCheckedEnabled;

Â Â Â Â // âœ… Task Buttons (Including Reminder Button)
Â Â Â Â const buttons = [
Â Â Â Â Â Â Â Â { class: "move-up", icon: "â–²", show: true },
Â Â Â Â Â Â Â Â { class: "move-down", icon: "â–¼", show: true },
Â Â Â Â Â Â Â Â { class: "recurring-btn", icon: "<i class='fas fa-repeat'></i>", show: showRecurring || (settings.alwaysShowRecurring || false) },
Â Â Â Â Â Â Â Â { class: "set-due-date", icon: "<i class='fas fa-calendar-alt'></i>", show: !autoResetEnabled },
Â Â Â Â Â Â Â Â { class: "enable-task-reminders", icon: "<i class='fas fa-bell'></i>", show: remindersEnabled || remindersEnabledGlobal, toggle: true },
Â Â Â Â Â Â Â Â { class: "priority-btn", icon: "<i class='fas fa-exclamation-triangle'></i>", show: true },
Â Â Â Â Â Â Â Â { class: "edit-btn", icon: "<i class='fas fa-edit'></i>", show: true },
Â Â Â Â Â Â Â Â { class: "delete-btn", icon: "<i class='fas fa-trash'></i>", show: true }
Â Â Â Â ];
Â Â Â Â 
Â Â Â Â buttons.forEach(({ class: btnClass, icon, toggle = false, show }) => {
Â Â Â Â Â Â Â Â const button = document.createElement("button");
Â Â Â Â Â Â Â Â button.classList.add("task-btn", btnClass);
Â Â Â Â Â Â Â Â button.innerHTML = icon;
Â Â Â Â Â Â Â Â button.setAttribute("type", "button");
Â Â Â Â Â Â Â Â if (!show) button.classList.add("hidden");

Â Â Â Â Â Â Â Â // âŒ¨ï¸ Keyboard: Enter/Space Activation
Â Â Â Â Â Â Â Â button.setAttribute("tabindex", "0");
Â Â Â Â Â Â Â Â button.addEventListener("keydown", (e) => {
Â Â Â Â Â Â Â Â Â Â Â Â if (e.key === "Enter" || e.key === " ") {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â e.preventDefault();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â button.click();
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const focusable = Array.from(buttonContainer.querySelectorAll("button.task-btn"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const currentIndex = focusable.indexOf(e.target);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const nextIndex = e.key === "ArrowRight"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ? (currentIndex + 1) % focusable.length
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â : (currentIndex - 1 + focusable.length) % focusable.length;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â focusable[nextIndex].focus();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â e.preventDefault();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // ARIA label setup
Â Â Â Â Â Â Â Â const ariaLabels = {
Â Â Â Â Â Â Â Â Â Â Â Â "move-up": "Move task up",
Â Â Â Â Â Â Â Â Â Â Â Â "move-down": "Move task down",
Â Â Â Â Â Â Â Â Â Â Â Â "recurring-btn": "Toggle recurring task",
Â Â Â Â Â Â Â Â Â Â Â Â "set-due-date": "Set due date",
Â Â Â Â Â Â Â Â Â Â Â Â "enable-task-reminders": "Toggle reminders for this task",
Â Â Â Â Â Â Â Â Â Â Â Â "priority-btn": "Mark task as high priority",
Â Â Â Â Â Â Â Â Â Â Â Â "edit-btn": "Edit task",
Â Â Â Â Â Â Â Â Â Â Â Â "delete-btn": "Delete task"
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â button.setAttribute("aria-label", ariaLabels[btnClass] || "Task action");
Â Â Â Â 
Â Â Â Â Â Â Â Â // ARIA toggle state setup
Â Â Â Â Â Â Â Â if (btnClass === "enable-task-reminders") {
Â Â Â Â Â Â Â Â Â Â Â Â const isActive = remindersEnabled === true;
Â Â Â Â Â Â Â Â Â Â Â Â button.classList.toggle("reminder-active", isActive);
Â Â Â Â Â Â Â Â Â Â Â Â button.setAttribute("aria-pressed", isActive.toString());
Â Â Â Â Â Â Â Â } else if (["recurring-btn", "priority-btn"].includes(btnClass)) {
Â Â Â Â Â Â Â Â Â Â Â Â const isActive = btnClass === "recurring-btn" ? !!recurring : !!highPriority;
Â Â Â Â Â Â Â Â Â Â Â Â button.classList.toggle("active", isActive);
Â Â Â Â Â Â Â Â Â Â Â Â button.setAttribute("aria-pressed", isActive.toString());
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… In addTask() function, replace the incomplete recurring button handler:
Â Â Â Â Â Â Â Â if (btnClass === "recurring-btn") {
Â Â Â Â Â Â Â Â Â Â Â Â button.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const task = currentCycle.tasks.find(t => t.id === assignedTaskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!task) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!(showRecurring || (settings.alwaysShowRecurring || false))) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const isNowRecurring = !task.recurring;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring = isNowRecurring;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â button.classList.toggle("active", isNowRecurring);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â button.setAttribute("aria-pressed", isNowRecurring.toString());
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (isNowRecurring) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const defaultSettings = settings.defaultRecurringSettings || {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â frequency: "daily",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â indefinitely: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â time: null
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurringSettings = normalizeRecurringSettings(structuredClone(defaultSettings));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.setAttribute("data-recurring-settings", JSON.stringify(task.recurringSettings));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.classList.add("recurring");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.schemaVersion = 2;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Create recurring template
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!currentCycle.recurringTemplates) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates = {};
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.recurringTemplates[assignedTaskId] = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â id: assignedTaskId,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â text: task.text,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurring: true,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â recurringSettings: structuredClone(task.recurringSettings),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â highPriority: task.highPriority || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDate: task.dueDate || null,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â remindersEnabled: task.remindersEnabled || false,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â lastTriggeredTimestamp: null,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â schemaVersion: 2
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const rs = task.recurringSettings || {};
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const frequency = rs.frequency || "daily";
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const pattern = rs.indefinitely ? "Indefinitely" : "Limited";
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const notificationContent = createRecurringNotificationWithTip(assignedTaskId, frequency, pattern);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const notification = showNotificationWithTip(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â notificationContent,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "recurring",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 20000,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "recurring-cycle-explanation"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â initializeRecurringNotificationListeners(notification);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… FIXED: Proper cleanup when turning off recurring
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurring = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.recurringSettings = {};
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.schemaVersion = 2;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.removeAttribute("data-recurring-settings");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.classList.remove("recurring");
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… IMPORTANT: Only remove from templates, keep task in main array
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (currentCycle.recurringTemplates?.[assignedTaskId]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â delete currentCycle.recurringTemplates[assignedTaskId];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… CRITICAL: Ensure the task stays in the main tasks array
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskExists = currentCycle.tasks.find(t => t.id === assignedTaskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!taskExists) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Task missing from main array, re-adding:', assignedTaskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.tasks.push(task);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("â†©ï¸ Recurring turned off for this task.", "info", 2000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… CRITICAL: Save to Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringPanelButtonVisibility();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringPanel?.();
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â else if (btnClass === "enable-task-reminders") {
Â Â Â Â Â Â Â Â Â Â Â Â button.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const isActive = button.classList.toggle("reminder-active");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â button.setAttribute("aria-pressed", isActive.toString());

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â saveTaskReminderState(assignedTaskId, isActive);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoSaveReminders();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â startReminders();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const undoBtn = document.getElementById("undo-btn");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const redoBtn = document.getElementById("redo-btn");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (undoBtn) undoBtn.hidden = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (redoBtn) redoBtn.hidden = true;

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`Reminders ${isActive ? "enabled" : "disabled"} for task.`, "info", 1500);
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â button.addEventListener("click", handleTaskButtonClick);
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â buttonContainer.appendChild(button);
Â Â Â Â });

Â Â Â Â // âœ… Continue with rest of DOM creation for Schema 2.5
Â Â Â Â console.log(`ğŸ“Œ Loading Task (Schema 2.5): ${taskTextTrimmed}, Reminder Enabled: ${remindersEnabled}`);

Â Â Â Â // âœ… Checkbox for Completion
Â Â Â Â const checkbox = document.createElement("input");
Â Â Â Â checkbox.type = "checkbox";
Â Â Â Â checkbox.setAttribute("id", `checkbox-${assignedTaskId}`);
Â Â Â Â checkbox.setAttribute("name", `task-complete-${assignedTaskId}`);
Â Â Â Â checkbox.checked = completed;
Â Â Â Â checkbox.setAttribute("aria-label", `Mark task "${taskTextTrimmed}" as complete`);
Â Â Â Â checkbox.setAttribute("role", "checkbox");
Â Â Â Â checkbox.setAttribute("aria-checked", checkbox.checked);
Â Â Â Â 
Â Â Â Â safeAddEventListener(checkbox, "change", () => {
Â Â Â Â Â Â Â Â pushUndoSnapshot();
Â Â Â Â Â Â Â Â handleTaskCompletionChange(checkbox);
Â Â Â Â Â Â Â Â checkMiniCycle();
Â Â Â Â Â Â Â Â autoSave();
Â Â Â Â Â Â Â Â triggerLogoBackground(checkbox.checked ? 'green' : 'default', 300);

Â Â Â Â Â Â Â Â const undoBtn = document.getElementById("undo-btn");
Â Â Â Â Â Â Â Â const redoBtn = document.getElementById("redo-btn");
Â Â Â Â Â Â Â Â if (undoBtn) undoBtn.hidden = false;
Â Â Â Â Â Â Â Â if (redoBtn) redoBtn.hidden = true;

Â Â Â Â Â Â Â Â console.log("âœ… Task completion toggled â€” undo snapshot pushed.");
Â Â Â Â });
Â Â Â Â 
Â Â Â Â safeAddEventListener(checkbox, "keydown", (e) => {
Â Â Â Â Â Â Â Â if (e.key === "Enter") {
Â Â Â Â Â Â Â Â Â Â Â Â e.preventDefault();
Â Â Â Â Â Â Â Â Â Â Â Â checkbox.checked = !checkbox.checked;
Â Â Â Â Â Â Â Â Â Â Â Â checkbox.dispatchEvent(new Event("change"));
Â Â Â Â Â Â Â Â }
Â Â Â Â });

Â Â Â Â // âœ… Ensure `.task-text` Exists
Â Â Â Â const taskLabel = document.createElement("span");
Â Â Â Â taskLabel.classList.add("task-text");
Â Â Â Â taskLabel.textContent = taskTextTrimmed;
Â Â Â Â taskLabel.setAttribute("tabindex", "0");
Â Â Â Â taskLabel.setAttribute("role", "text");
Â Â Â Â 
Â Â Â Â // ğŸ” Add blue recurring icon if this task is recurring
Â Â Â Â if (recurring) {
Â Â Â Â Â Â Â Â const icon = document.createElement("span");
Â Â Â Â Â Â Â Â icon.className = "recurring-indicator";
Â Â Â Â Â Â Â Â icon.innerHTML = `<i class="fas fa-sync-alt"></i>`;
Â Â Â Â Â Â Â Â taskLabel.appendChild(icon);
Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â // âœ… Due Date Input (Hidden by Default)
Â Â Â Â const dueDateInput = document.createElement("input");
Â Â Â Â dueDateInput.type = "date";
Â Â Â Â dueDateInput.classList.add("due-date");
Â Â Â Â dueDateInput.setAttribute("aria-describedby", `task-desc-${assignedTaskId}`);
Â Â Â Â taskLabel.id = `task-desc-${assignedTaskId}`;Â Â Â 

Â Â Â Â if (dueDate) {
Â Â Â Â Â Â Â Â dueDateInput.value = dueDate;
Â Â Â Â Â Â Â Â if (!autoResetEnabled) {
Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.classList.remove("hidden");
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.classList.add("hidden");
Â Â Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â Â Â dueDateInput.classList.add("hidden");
Â Â Â Â }
Â Â Â Â 
Â Â Â Â dueDateInput.addEventListener("change", () => {
Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â // Update task in Schema 2.5
Â Â Â Â Â Â Â Â const taskToUpdate = currentCycle.tasks.find(t => t.id === assignedTaskId);
Â Â Â Â Â Â Â Â if (taskToUpdate) {
Â Â Â Â Â Â Â Â Â Â Â Â taskToUpdate.dueDate = dueDateInput.value;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â Â Â checkCompleteAllButton();

Â Â Â Â Â Â Â Â showNotification("ğŸ“… Due date updated", "info", 1500);
Â Â Â Â });

Â Â Â Â const dueDateButton = buttonContainer.querySelector(".set-due-date");
Â Â Â Â if (dueDateButton) {
Â Â Â Â Â Â Â Â dueDateButton.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.classList.toggle("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â dueDateButton.classList.toggle("active", !dueDateInput.classList.contains("hidden"));
Â Â Â Â Â Â Â Â });
Â Â Â Â }

Â Â Â Â // âœ… Toggle Completion on Click (excluding buttons)
Â Â Â Â taskItem.addEventListener("click", (event) => {
Â Â Â Â Â Â Â Â if (event.target === checkbox || buttonContainer.contains(event.target) || event.target === dueDateInput) return;
Â Â Â Â Â Â Â Â checkbox.checked = !checkbox.checked;
Â Â Â Â Â Â Â Â checkbox.dispatchEvent(new Event("change"));
Â Â Â Â Â Â Â Â checkbox.setAttribute("aria-checked", checkbox.checked);
Â Â Â Â 
Â Â Â Â Â Â Â Â checkMiniCycle();
Â Â Â Â Â Â Â Â autoSave();
Â Â Â Â Â Â Â Â triggerLogoBackground(checkbox.checked ? 'green' : 'default', 300);
Â Â Â Â });

Â Â Â Â const taskContent = document.createElement("div");
Â Â Â Â taskContent.classList.add("task-content");
Â Â Â Â taskContent.appendChild(checkbox);
Â Â Â Â taskContent.appendChild(taskLabel);

Â Â Â Â taskItem.appendChild(buttonContainer);

Â Â Â Â // âœ… Ensure Priority Button Reflects Saved State
Â Â Â Â const priorityButton = buttonContainer.querySelector(".priority-btn");
Â Â Â Â if (highPriority) {
Â Â Â Â Â Â Â Â priorityButton.classList.add("priority-active");
Â Â Â Â Â Â Â Â priorityButton.setAttribute("aria-pressed", "true");
Â Â Â Â }
Â Â Â Â 
Â Â Â Â taskItem.appendChild(taskContent);
Â Â Â Â taskItem.appendChild(dueDateInput);
Â Â Â Â taskList.appendChild(taskItem);
Â Â Â Â 
Â Â Â Â // âœ… Clear input
Â Â Â Â if (taskInput) taskInput.value = "";

Â Â Â Â // âœ… Scroll to new task with proper reference
Â Â Â Â const taskListContainer = document.querySelector(".task-list-container");
Â Â Â Â if (taskListContainer && taskList) {
Â Â Â Â Â Â Â Â taskListContainer.scrollTo({
Â Â Â Â Â Â Â Â Â Â Â Â top: taskList.scrollHeight,
Â Â Â Â Â Â Â Â Â Â Â Â behavior: "smooth"
Â Â Â Â Â Â Â Â });
Â Â Â Â }

Â Â Â Â setTimeout(() => {Â 
Â Â Â Â Â Â Â Â if (completed) {
Â Â Â Â Â Â Â Â Â Â Â Â taskItem.classList.remove("overdue-task");
Â Â Â Â Â Â Â Â }
Â Â Â Â }, 300);

Â Â Â Â checkCompleteAllButton();
Â Â Â Â updateProgressBar();
Â Â Â Â updateStatsPanel();
Â Â Â Â if (shouldSave) autoSave();

Â Â Â Â if (!isLoading) setTimeout(() => { remindOverdueTasks(); }, 1000);

Â Â Â Â DragAndDrop(taskItem);
Â Â Â Â updateMoveArrowsVisibility();

Â Â Â Â const threeDotsEnabled = settings.showThreeDots || false;
Â Â Â Â if (!threeDotsEnabled) {
Â Â Â Â Â Â Â Â taskItem.addEventListener("mouseenter", showTaskOptions);
Â Â Â Â Â Â Â Â taskItem.addEventListener("mouseleave", hideTaskOptions);
Â Â Â Â }

Â Â Â Â safeAddEventListener(taskItem, "focus", () => {
Â Â Â Â Â Â Â Â const options = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â if (options) {
Â Â Â Â Â Â Â Â Â Â Â Â options.style.opacity = "1";
Â Â Â Â Â Â Â Â Â Â Â Â options.style.visibility = "visible";
Â Â Â Â Â Â Â Â Â Â Â Â options.style.pointerEvents = "auto";
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â attachKeyboardTaskOptionToggle(taskItem);
Â Â Â Â 
Â Â Â Â console.log('âœ… Task creation completed (Schema 2.5)');
}
Â Â Â Â 



function toggleHoverTaskOptions(enableHover) {
Â Â document.querySelectorAll(".task").forEach(taskItem => {
Â Â Â Â if (enableHover) {
Â Â Â Â Â Â if (!taskItem.classList.contains("hover-enabled")) {
Â Â Â Â Â Â Â Â taskItem.addEventListener("mouseenter", showTaskOptions);
Â Â Â Â Â Â Â Â taskItem.addEventListener("mouseleave", hideTaskOptions);
Â Â Â Â Â Â Â Â taskItem.classList.add("hover-enabled");
Â Â Â Â Â Â }
Â Â Â Â } else {
Â Â Â Â Â Â if (taskItem.classList.contains("hover-enabled")) {
Â Â Â Â Â Â Â Â taskItem.removeEventListener("mouseenter", showTaskOptions);
Â Â Â Â Â Â Â Â taskItem.removeEventListener("mouseleave", hideTaskOptions);
Â Â Â Â Â Â Â Â taskItem.classList.remove("hover-enabled");
Â Â Â Â Â Â }
Â Â Â Â }
Â Â });
}



document.addEventListener("click", (e) => {
Â Â const target = e.target.closest(".open-recurring-settings");
Â Â if (!target) return;

Â Â const taskId = target.dataset.taskId;
Â Â if (!taskId) return;

Â Â // ğŸ¯ Use your centralized panel-opening logic
Â Â openRecurringSettingsPanelForTask(taskId);
});

/**
Â * âœ… Sanitize user input to prevent XSS attacks or malformed content.
Â * @param {string} input - The user input to be sanitized.
Â * @returns {string} - Cleaned and safe string, trimmed and limited in length.
Â */
function sanitizeInput(input) {
Â Â Â Â if (typeof input !== "string") return "";
Â Â Â Â const temp = document.createElement("div");
Â Â Â Â temp.textContent = input; // Set as raw text (sanitized)
Â Â Â Â return temp.textContent.trim().substring(0, TASK_LIMIT); // <-- use textContent here too
Â Â }

Â Â Â Â /**
Â * âŒ¨ï¸ Accessibility Helper: Toggles visibility of task buttons when task item is focused or blurred.
Â *Â 
Â * When navigating with the keyboard (e.g., using Tab), this ensures that the task option buttons
Â * (edit, delete, reminders, etc.) are shown while the task is focused and hidden when it loses focus.
Â *Â 
Â * This provides a keyboard-accessible experience similar to mouse hover.
Â *
Â * @param {HTMLElement} taskItem - The task <li> element to attach listeners to.
Â */
Â Â Â Â function attachKeyboardTaskOptionToggle(taskItem) {
Â Â Â Â Â Â /**
Â Â Â Â Â Â Â * âŒ¨ï¸ Show task buttons only when focus is inside a real action element.
Â Â Â Â Â Â Â * Prevent buttons from appearing when clicking the checkbox or task text.
Â Â Â Â Â Â Â */
Â Â Â Â Â Â safeAddEventListener(taskItem, "focusin", (e) => {
Â Â Â Â Â Â Â Â const target = e.target;
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Skip if focusing on safe elements that shouldn't trigger button reveal
Â Â Â Â Â Â Â Â if (
Â Â Â Â Â Â Â Â Â Â target.classList.contains("task-text") ||
Â Â Â Â Â Â Â Â Â Â target.type === "checkbox" ||
Â Â Â Â Â Â Â Â Â Â target.closest(".focus-safe")
Â Â Â Â Â Â Â Â ) {
Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â const options = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â if (options) {
Â Â Â Â Â Â Â Â Â Â options.style.opacity = "1";
Â Â Â Â Â Â Â Â Â Â options.style.visibility = "visible";
Â Â Â Â Â Â Â Â Â Â options.style.pointerEvents = "auto";
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â /**
Â Â Â Â Â Â Â * âŒ¨ï¸ Hide task buttons when focus moves outside the entire task
Â Â Â Â Â Â Â */
Â Â Â Â Â Â safeAddEventListener(taskItem, "focusout", (e) => {
Â Â Â Â Â Â Â Â if (taskItem.contains(e.relatedTarget)) return;
Â Â Â Â 
Â Â Â Â Â Â Â Â const options = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â if (options) {
Â Â Â Â Â Â Â Â Â Â options.style.opacity = "0";
Â Â Â Â Â Â Â Â Â Â options.style.visibility = "hidden";
Â Â Â Â Â Â Â Â Â Â options.style.pointerEvents = "none";
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â });
Â Â Â Â }



Â Â Â Â /**
Â * Updatereminderbuttons function.
Â *
Â * @returns {void}
Â */

Â Â 

Â Â Â Â 
Â Â Â Â function updateReminderButtons() {
Â Â Â Â Â Â Â Â console.log("ğŸ” Running updateReminderButtons() (Schema 2.5 only)...");
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateReminderButtons');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â const { cycles, activeCycle, reminders } = schemaData;
Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â const reminderSettings = reminders || {};
Â Â Â Â Â Â Â Â const remindersGloballyEnabled = reminderSettings.enabled === true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Reminder settings from Schema 2.5:', {
Â Â Â Â Â Â Â Â Â Â Â Â globallyEnabled: remindersGloballyEnabled,
Â Â Â Â Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â Â Â Â Â hasCycle: !!currentCycle
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â document.querySelectorAll(".task").forEach(taskItem => {
Â Â Â Â Â Â Â Â Â Â const buttonContainer = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â Â Â let reminderButton = buttonContainer.querySelector(".enable-task-reminders");
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â const taskId = taskItem.dataset.taskId;
Â Â Â Â Â Â Â Â Â Â if (!taskId) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn("âš  Skipping task with missing ID:", taskItem);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â // âœ… Get task data from Schema 2.5
Â Â Â Â Â Â Â Â Â Â const taskData = currentCycle?.tasks?.find(t => t.id === taskId);
Â Â Â Â Â Â Â Â Â Â const isActive = taskData?.remindersEnabled === true;
Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ” Task ${taskId}: reminders enabled = ${isActive}`);
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â if (remindersGloballyEnabled) {
Â Â Â Â Â Â Â Â Â Â Â Â if (!reminderButton) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Create Reminder Button
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton = document.createElement("button");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.classList.add("task-btn", "enable-task-reminders");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.innerHTML = "<i class='fas fa-bell'></i>";
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Add click event
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const nowActive = reminderButton.classList.toggle("reminder-active");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.setAttribute("aria-pressed", nowActive.toString());
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â saveTaskReminderState(taskId, nowActive);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoSaveReminders();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â buttonContainer.insertBefore(reminderButton, buttonContainer.children[2]);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(" Â  âœ… Reminder Button Created & Inserted");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Ensure correct state and make it visible
Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.classList.toggle("reminder-active", isActive);
Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.setAttribute("aria-pressed", isActive.toString());
Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.classList.remove("hidden");
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â console.log(` Â  ğŸ”„ Reminder Button Visible - Active: ${isActive}`);
Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â // âŒ Hide button if reminders are disabled globally
Â Â Â Â Â Â Â Â Â Â Â Â if (reminderButton) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.classList.add("hidden"); // Don't remove it; just hide for layout consistency
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.classList.remove("reminder-active");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â reminderButton.setAttribute("aria-pressed", "false");
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(" Â  ğŸ”• Reminder Button Hidden (Global toggle OFF)");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log("âœ… Finished updateReminderButtons() (Schema 2.5).");
Â Â Â Â }
Â Â Â Â 

Â Â Â Â 
Â Â Â Â 

Â Â Â Â /**
Â * Showtaskoptions function.
Â *
Â * @param {any} event - Description. * @returns {void}
Â */

function revealTaskButtons(taskItem) {
Â Â const taskOptions = taskItem.querySelector(".task-options");
Â Â if (!taskOptions) return;

Â Â // ğŸ§¹ Hide all other task option menus
Â Â document.querySelectorAll(".task-options").forEach(opts => {
Â Â Â Â if (opts !== taskOptions) {
Â Â Â Â Â Â opts.style.visibility = "hidden";
Â Â Â Â Â Â opts.style.opacity = "0";
Â Â Â Â Â Â opts.style.pointerEvents = "none";

Â Â Â Â Â Â // Optional: hide all child buttons too
Â Â Â Â Â Â opts.querySelectorAll(".task-btn").forEach(btn => {
Â Â Â Â Â Â Â Â btn.style.visibility = "hidden";
Â Â Â Â Â Â Â Â btn.style.opacity = "0";
Â Â Â Â Â Â Â Â btn.style.pointerEvents = "none";
Â Â Â Â Â Â });
Â Â Â Â }
Â Â });

Â Â // âœ… Show this task's options
Â Â taskOptions.style.visibility = "visible";
Â Â taskOptions.style.opacity = "1";
Â Â taskOptions.style.pointerEvents = "auto";

Â Â const reminderSettings = JSON.parse(localStorage.getItem("miniCycleReminders")) || {};
Â Â const remindersEnabledGlobal = reminderSettings.enabled === true;
Â Â const autoResetEnabled = toggleAutoReset.checked;

Â Â const { lastUsedMiniCycle, savedMiniCycles } = assignCycleVariables();
Â Â const cycleData = savedMiniCycles?.[lastUsedMiniCycle] ?? {};
Â Â const deleteCheckedEnabled = cycleData.deleteCheckedTasks;

Â Â const alwaysShow = JSON.parse(localStorage.getItem("miniCycleAlwaysShowRecurring")) === true;
Â Â const showRecurring = alwaysShow || (!autoResetEnabled && deleteCheckedEnabled);

Â Â taskOptions.querySelectorAll(".task-btn").forEach(btn => {
Â Â Â Â const isReminderBtn = btn.classList.contains("enable-task-reminders");
Â Â Â Â const isRecurringBtn = btn.classList.contains("recurring-btn");
Â Â Â Â const isDueDateBtn = btn.classList.contains("set-due-date");

Â Â Â Â const shouldShow =
Â Â Â Â Â Â !btn.classList.contains("hidden") ||
Â Â Â Â Â Â (isReminderBtn && remindersEnabledGlobal) ||
Â Â Â Â Â Â (isRecurringBtn && showRecurring) ||
Â Â Â Â Â Â (isDueDateBtn && !autoResetEnabled);

Â Â Â Â if (shouldShow) {
Â Â Â Â Â Â btn.classList.remove("hidden");
Â Â Â Â Â Â btn.style.visibility = "visible";
Â Â Â Â Â Â btn.style.opacity = "1";
Â Â Â Â Â Â btn.style.pointerEvents = "auto";
Â Â Â Â }
Â Â });

Â Â updateMoveArrowsVisibility();
}

Â Â Â Â function hideTaskButtons(taskItem) {

Â Â Â Â Â Â if (taskItem.classList.contains("rearranging")) {
Â Â Â Â Â Â Â Â console.log("â³ Skipping hide during task rearrangement");
Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â const taskOptions = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â if (!taskOptions) return;
Â Â Â Â 
Â Â Â Â Â Â Â Â taskOptions.style.visibility = "hidden";
Â Â Â Â Â Â Â Â taskOptions.style.opacity = "0";
Â Â Â Â Â Â Â Â taskOptions.style.pointerEvents = "none";
Â Â Â Â 
Â Â Â Â Â Â Â Â taskItem.querySelectorAll(".task-btn").forEach(btn => {
Â Â Â Â Â Â Â Â Â Â Â Â btn.style.visibility = "hidden";
Â Â Â Â Â Â Â Â Â Â Â Â btn.style.opacity = "0";
Â Â Â Â Â Â Â Â Â Â Â Â btn.style.pointerEvents = "none";
Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â // Keep layout and interactivity clean
Â Â Â Â Â Â Â Â updateMoveArrowsVisibility();
Â Â Â Â }




Â Â Â Â function showTaskOptions(event) {
Â Â Â Â Â Â Â Â const taskElement = event.currentTarget;
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Only allow on desktop or if long-pressed on mobile
Â Â Â Â Â Â Â Â const isMobile = isTouchDevice();
Â Â Â Â Â Â Â Â const allowShow = !isMobile || taskElement.classList.contains("long-pressed");
Â Â Â Â 
Â Â Â Â Â Â Â Â if (allowShow) {
Â Â Â Â Â Â Â Â Â Â Â Â revealTaskButtons(taskElement);
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 

Â Â Â Â function hideTaskOptions(event) {
Â Â Â Â Â Â Â Â const taskElement = event.currentTarget;
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Only hide if not long-pressed on mobile (so buttons stay open during drag)
Â Â Â Â Â Â Â Â const isMobile = isTouchDevice();
Â Â Â Â Â Â Â Â const allowHide = !isMobile || !taskElement.classList.contains("long-pressed");
Â Â Â Â 
Â Â Â Â Â Â Â Â if (allowHide) {
Â Â Â Â Â Â Â Â Â Â Â Â hideTaskButtons(taskElement);
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â 
/**
Â * Handles the change event when a task's completion status is toggled.
Â *
Â * @param {HTMLInputElement} checkbox - The checkbox element of the task.
Â */
function handleTaskCompletionChange(checkbox) {
Â Â Â Â const taskItem = checkbox.closest(".task");

Â Â Â Â Â if (checkbox.checked) {
Â Â Â Â Â Â Â Â taskItem.classList.remove("overdue-task");
Â Â Â Â } else {
Â Â Â Â Â Â Â Â checkOverdueTasks(taskItem);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… ADD THIS: Force help window update
Â Â Â Â if (window.helpWindowManager && typeof window.helpWindowManager.updateConstantMessage === 'function') {
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â window.helpWindowManager.updateConstantMessage();
Â Â Â Â Â Â Â Â }, 100);
Â Â Â Â }
}
Â Â Â Â 


Â Â Â Â /**
Â * Istouchdevice function.
Â *
Â * @returns {void}
Â */

function isTouchDevice() {
Â Â Â Â Â Â Â Â let hasTouchEvents = "ontouchstart" in window;
Â Â Â Â Â Â Â Â let touchPoints = navigator.maxTouchPoints || navigator.msMaxTouchPoints;
Â Â Â Â Â Â Â Â let isFinePointer = window.matchMedia("(pointer: fine)").matches;

Â Â Â Â Â Â Â Â console.log(`touch detected: hasTouchEvents=${hasTouchEvents}, maxTouchPoints=${touchPoints}, isFinePointer=${isFinePointer}`);

Â Â Â Â Â Â Â Â if (isFinePointer) return false;

Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return hasTouchEvents || touchPoints > 0;
Â Â Â Â }
Â Â Â Â 
Â 
Â Â Â Â 

/**
Â * Handles button clicks for task-related actions, such as moving, editing, deleting, or changing priority.
Â *
Â * @param {Event} event - The event triggered by clicking a task button.
Â */

function handleTaskButtonClick(event) {
Â Â Â Â event.stopPropagation(); // âœ… Prevents click from affecting the whole task

Â Â Â Â const button = event.currentTarget;
Â Â Â Â const taskItem = button.closest(".task");

Â Â Â Â if (!taskItem) return;

Â Â Â Â // âœ… Ensure `.task-options` stays interactive
Â Â Â Â const taskOptions = taskItem.querySelector(".task-options");
Â Â Â Â if (taskOptions) {
Â Â Â Â Â Â Â Â taskOptions.style.pointerEvents = "auto"; // ğŸ”¥ FIXES MOBILE CLICK ISSUE
Â Â Â Â }

Â Â Â Â let shouldSave = false;
Â Â Â Â if (button.classList.contains("move-up")) {
Â Â Â Â Â Â Â Â const prevTask = taskItem.previousElementSibling;
Â Â Â Â Â Â Â Â if (prevTask) {
Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ” Save undo snapshot BEFORE reordering
Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â if (isTouchDevice()) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.classList.add("rearranging");
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â taskItem.parentNode.insertBefore(taskItem, prevTask);
Â Â Â Â Â Â Â Â Â Â Â Â revealTaskButtons(taskItem);
Â Â Â Â Â Â Â Â Â Â Â Â toggleArrowVisibility();

Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ’¾ Save the new task order to localStorage
Â Â Â Â Â Â Â Â Â Â Â Â saveCurrentTaskOrder();

Â Â Â Â Â Â Â Â Â Â Â Â shouldSave = false; // Already saved manually
Â Â Â Â Â Â Â Â }
Â Â Â Â } else if (button.classList.contains("move-down")) {
Â Â Â Â Â Â Â Â const nextTask = taskItem.nextElementSibling;
Â Â Â Â Â Â Â Â if (nextTask) {
Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ” Save undo snapshot BEFORE reordering
Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â if (isTouchDevice()) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.classList.add("rearranging");
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â taskItem.parentNode.insertBefore(taskItem, nextTask.nextSibling);
Â Â Â Â Â Â Â Â Â Â Â Â revealTaskButtons(taskItem);
Â Â Â Â Â Â Â Â Â Â Â Â toggleArrowVisibility();

Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ’¾ Save the new task order to localStorage
Â Â Â Â Â Â Â Â Â Â Â Â saveCurrentTaskOrder();

Â Â Â Â Â Â Â Â Â Â Â Â shouldSave = false; // Already saved manually
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â else if (button.classList.contains("edit-btn")) {
Â Â Â Â Â Â Â Â const taskLabel = taskItem.querySelector("span");
Â Â Â Â Â Â Â Â const oldText = taskLabel.textContent.trim();

Â Â Â Â Â Â Â Â showPromptModal({
Â Â Â Â Â Â Â Â Â Â Â Â title: "Edit Task Name",
Â Â Â Â Â Â Â Â Â Â Â Â message: "Rename this task:",
Â Â Â Â Â Â Â Â Â Â Â Â placeholder: "Enter new task name",
Â Â Â Â Â Â Â Â Â Â Â Â defaultValue: oldText,
Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Save",
Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â Â Â Â Â required: true,
Â Â Â Â Â Â Â Â Â Â Â Â callback: (newText) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (newText && newText.trim() !== oldText) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const cleanText = sanitizeInput(newText.trim());

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // ğŸ” Save snapshot BEFORE changing text
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskLabel.textContent = cleanText;

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Update task object with Schema 2.5 only
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskId = taskItem.dataset.taskId;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for edit task');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const task = cycles[activeCycle]?.tasks?.find(t => t.id === taskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (task) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.text = cleanText;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`Task renamed to "${cleanText}"`, "info", 1500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkCompleteAllButton();

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â shouldSave = false; // Already saved
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â }
Â Â Â Â else if (button.classList.contains("delete-btn")) {
Â Â Â Â Â Â Â Â const taskId = taskItem.dataset.taskId;
Â Â Â Â Â Â Â Â const taskName = taskItem.querySelector(".task-text")?.textContent || "Task";
Â Â Â Â 
Â Â Â Â Â Â Â Â showConfirmationModal({
Â Â Â Â Â Â Â Â Â Â Â Â title: "Delete Task",
Â Â Â Â Â Â Â Â Â Â Â Â message: `Are you sure you want to delete "${taskName}"?`,
Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Delete",
Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â Â Â Â Â callback: (confirmDelete) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmDelete) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`"${taskName}" has not been deleted.`, "show", 2500);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log("âŒ Task not deleted.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Push undo snapshot BEFORE deletion
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â pushUndoSnapshot();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for delete task');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (currentCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove task from Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currentCycle.tasks = currentCycle.tasks.filter(task => task.id !== taskId);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove from recurring templates if it exists
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (currentCycle.recurringTemplates?.[taskId]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â delete currentCycle.recurringTemplates[taskId];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Remove from DOM
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskItem.remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateProgressBar();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleArrowVisibility();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`"${taskName}" has been deleted.`, "info", 2000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log(`ğŸ—‘ï¸ Deleted task: "${taskName}"`);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â shouldSave = false; // Already saved manually
Â Â Â Â }
Â Â Â Â else if (button.classList.contains("priority-btn")) {
Â Â Â Â Â Â Â Â // ğŸ” Save snapshot BEFORE changing priority
Â Â Â Â Â Â Â Â pushUndoSnapshot();
Â Â Â Â 
Â Â Â Â Â Â Â Â taskItem.classList.toggle("high-priority");
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Reflect priority visually
Â Â Â Â Â Â Â Â if (taskItem.classList.contains("high-priority")) {
Â Â Â Â Â Â Â Â Â Â Â Â button.classList.add("priority-active");
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â button.classList.remove("priority-active");
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Update task object in storage - Schema 2.5 only
Â Â Â Â Â Â Â Â const taskId = taskItem.dataset.taskId;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for priority task');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â const task = cycles[activeCycle]?.tasks?.find(t => t.id === taskId);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (task) {
Â Â Â Â Â Â Â Â Â Â Â Â task.highPriority = taskItem.classList.contains("high-priority");
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycles[activeCycle];
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â showNotification(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â `Priority ${task.highPriority ? "enabled" : "removed"}.`,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.highPriority ? "error" : "info",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 1500
Â Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â shouldSave = false; // Already saved manually
Â Â Â Â }

Â Â Â Â if (shouldSave) autoSave();
Â Â Â Â console.log("âœ… Task button clicked:", button.className);
}

function saveCurrentTaskOrder() {
Â Â Â Â const taskElements = document.querySelectorAll("#taskList .task");
Â Â Â Â const newOrderIds = Array.from(taskElements).map(task => task.dataset.taskId);

Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveCurrentTaskOrder');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!currentCycle || !Array.isArray(currentCycle.tasks)) return;

Â Â Â Â // Reorder task array based on current DOM order
Â Â Â Â const reorderedTasks = newOrderIds.map(id =>
Â Â Â Â Â Â Â Â currentCycle.tasks.find(task => task.id === id)
Â Â Â Â ).filter(Boolean); // filters out any nulls

Â Â Â Â currentCycle.tasks = reorderedTasks;

Â Â Â Â // âœ… Save to Schema 2.5
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle] = currentCycle;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
}
































/**
Â * Resettasks function.
Â *
Â * @returns {void}
Â */

function resetTasks() {
Â Â Â Â if (isResetting) return;
Â Â Â Â isResetting = true;

Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â console.log('ğŸ”„ Resetting tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for resetTasks');
Â Â Â Â Â Â Â Â isResetting = false;
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];
Â Â Â Â const taskElements = [...taskList.querySelectorAll(".task")];

Â Â Â Â if (!activeCycle || !cycleData) {
Â Â Â Â Â Â Â Â console.error("âŒ No active cycle found in Schema 2.5 for resetTasks");
Â Â Â Â Â Â Â Â isResetting = false;
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Resetting tasks for cycle:', activeCycle);

Â Â Â Â // âœ… ANIMATION: Show progress bar becoming full first
Â Â Â Â progressBar.style.width = "100%";
Â Â Â Â progressBar.style.transition = "width 0.2s ease-out";
Â Â Â Â 
Â Â Â Â // âœ… Wait for animation, then reset tasks
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ§¹ Removing recurring tasks and resetting non-recurring tasks');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // ğŸ§¹ Remove recurring tasks
Â Â Â Â Â Â Â Â removeRecurringTasksFromCycle(taskElements, cycleData);

Â Â Â Â Â Â Â Â // â™»ï¸ Reset non-recurring tasks
Â Â Â Â Â Â Â Â taskElements.forEach(taskEl => {
Â Â Â Â Â Â Â Â Â Â Â Â const isRecurring = taskEl.classList.contains("recurring");
Â Â Â Â Â Â Â Â Â Â Â Â if (isRecurring) return;

Â Â Â Â Â Â Â Â Â Â Â Â const checkbox = taskEl.querySelector("input[type='checkbox']");
Â Â Â Â Â Â Â Â Â Â Â Â const dueDateInput = taskEl.querySelector(".due-date");

Â Â Â Â Â Â Â Â Â Â Â Â if (checkbox) checkbox.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â taskEl.classList.remove("overdue-task");

Â Â Â Â Â Â Â Â Â Â Â Â if (dueDateInput) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.value = "";
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â // âœ… Increment cycle count in Schema 2.5
Â Â Â Â Â Â Â Â incrementCycleCount(activeCycle, cycles);

Â Â Â Â Â Â Â Â // âœ… Animate progress bar reset with different timing
Â Â Â Â Â Â Â Â progressBar.style.transition = "width 0.3s ease-in";
Â Â Â Â Â Â Â Â progressBar.style.width = "0%";
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Reset transition after animation completes
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â progressBar.style.transition = "";
Â Â Â Â Â Â Â Â }, 50);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Task reset animation completed');
Â Â Â Â Â Â Â Â 
Â Â Â Â }, 100); // Wait for fill animation to complete

Â Â Â Â // âœ… Show cycle completion message in help window instead of separate element
Â Â Â Â if (helpWindowManager) {
Â Â Â Â Â Â Â Â helpWindowManager.showCycleCompleteMessage();
Â Â Â Â }

Â Â Â Â // âœ… Set isResetting to false after help window message duration
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â isResetting = false;
Â Â Â Â Â Â Â Â console.log('ğŸ”“ Reset lock released');
Â Â Â Â }, 2000);

Â Â Â Â // âœ… Handle recurring tasks and cleanup (keep existing timing)
Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Running post-reset cleanup tasks');
Â Â Â Â Â Â Â Â watchRecurringTasks();
Â Â Â Â Â Â Â Â autoSave();
Â Â Â Â Â Â Â Â updateStatsPanel();
Â Â Â Â Â Â Â Â console.log('âœ… Reset tasks completed successfully');
Â Â Â Â }, 1000);
}

// ...existing code...


Â Â Â Â Â Â Â Â Â Â // âœ… Remove the old cycle message display logic
Â Â Â Â Â Â Â Â Â Â // cycleMessage.style.visibility = "visible";
Â Â Â Â Â Â Â Â Â Â // cycleMessage.style.opacity = "1";
Â Â Â Â Â Â Â Â Â Â // setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â // Â  Â  cycleMessage.style.opacity = "0";
Â Â Â Â Â Â Â Â Â Â // Â  Â  cycleMessage.style.visibility = "hidden";
Â Â Â Â Â Â Â Â Â Â // Â  Â  isResetting = false;
Â Â Â Â Â Â Â Â Â Â // }, 2000);

/**
Â * Checkcompleteallbutton function.
Â *
Â * @returns {void}
Â */

function checkCompleteAllButton() {
Â Â Â Â const isAutoMode = document.body.classList.contains('auto-cycle-mode');
Â Â Â Â 
Â Â Â Â if (taskList.children.length > 0 && !isAutoMode) {
Â Â Â Â Â Â Â Â completeAllButton.style.display = "block";
Â Â Â Â } else {
Â Â Â Â Â Â Â Â completeAllButton.style.display = "none";
Â Â Â Â }
}
Â Â Â Â 
/**
Â * Temporarily changes the logo background color to indicate an action, then resets it.
Â *
Â * @param {string} [color='green'] - The temporary background color for the logo.
Â * @param {number} [duration=300] - The duration (in milliseconds) before resetting the background.
Â */

function triggerLogoBackground(color = 'green', duration = 300) {
Â Â Â Â // Target the specific logo image (not the app name)
Â Â Â Â const logo = document.querySelector('.header-branding .header-logo');

Â Â Â Â console.log('ğŸ” Logo element found:', logo); // Debug log
Â Â Â Â console.log('ğŸ¨ Applying color:', color); // Debug log

Â Â Â Â if (logo) {
Â Â Â Â Â Â Â Â // Clear any existing timeout
Â Â Â Â Â Â Â Â if (logoTimeoutId) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(logoTimeoutId);
Â Â Â Â Â Â Â Â Â Â Â Â logoTimeoutId = null;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â // Apply background color
Â Â Â Â Â Â Â Â logo.style.setProperty('background-color', color, 'important');
Â Â Â Â Â Â Â Â logo.style.setProperty('border-radius', '6px', 'important');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Background applied:', logo.style.backgroundColor); // Debug log
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Remove background after duration
Â Â Â Â Â Â Â Â logoTimeoutId = setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â logo.style.backgroundColor = '';
Â Â Â Â Â Â Â Â Â Â Â Â logo.style.borderRadius = '';
Â Â Â Â Â Â Â Â Â Â Â Â logoTimeoutId = null;Â 
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Background cleared'); // Debug log
Â Â Â Â Â Â Â Â }, duration);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.error('âŒ Logo element not found!');
Â Â Â Â }
}
/**
Â * Savetoggleautoreset function.
Â *
Â * @returns {void}
Â */
function saveToggleAutoReset() {
Â Â Â Â console.log('âš™ï¸ Setting up toggle auto reset (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â const deleteCheckedTasksContainer = document.getElementById("deleteCheckedTasksContainer");
Â Â Â Â const deleteCheckedTasks = document.getElementById("deleteCheckedTasks");
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for saveToggleAutoReset');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Setting up toggles for cycle:', activeCycle);
Â Â Â Â 
Â Â Â Â // âœ… Ensure AutoReset reflects the correct state from Schema 2.5
Â Â Â Â if (activeCycle && currentCycle) {
Â Â Â Â Â Â Â Â toggleAutoReset.checked = currentCycle.autoReset || false;
Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = currentCycle.deleteCheckedTasks || false;
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto reset state:', currentCycle.autoReset);
Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Delete checked tasks state:', currentCycle.deleteCheckedTasks);
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found, defaulting to false');
Â Â Â Â Â Â Â Â toggleAutoReset.checked = false;
Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Show "Delete Checked Tasks" only when Auto Reset is OFF
Â Â Â Â deleteCheckedTasksContainer.style.display = toggleAutoReset.checked ? "none" : "block";

Â Â Â Â // âœ… Remove previous event listeners before adding new ones to prevent stacking
Â Â Â Â toggleAutoReset.removeEventListener("change", handleAutoResetChange);
Â Â Â Â deleteCheckedTasks.removeEventListener("change", handleDeleteCheckedTasksChange);

Â Â Â Â // âœ… Define event listener functions for Schema 2.5
Â Â Â Â function handleAutoResetChange(event) {
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto reset toggle changed:', event.target.checked);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle available for auto reset change');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].autoReset = event.target.checked;

Â Â Â Â Â Â Â Â // âœ… If Auto Reset is turned ON, automatically uncheck "Delete Checked Tasks"
Â Â Â Â Â Â Â Â if (event.target.checked) {
Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].deleteCheckedTasks = false;
Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = false; // âœ… Update UI
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto reset ON - disabling delete checked tasks');
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â // âœ… Show/Hide "Delete Checked Tasks" toggle dynamically
Â Â Â Â Â Â Â Â deleteCheckedTasksContainer.style.display = event.target.checked ? "none" : "block";

Â Â Â Â Â Â Â Â // âœ… Only trigger miniCycle reset if AutoReset is enabled
Â Â Â Â Â Â Â Â if (event.target.checked) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto reset enabled - checking cycle state');
Â Â Â Â Â Â Â Â Â Â Â Â checkMiniCycle();
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â refreshTaskListUI();
Â Â Â Â Â Â Â Â updateRecurringButtonVisibility();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Auto reset settings saved to Schema 2.5');
Â Â Â Â }

Â Â Â Â function handleDeleteCheckedTasksChange(event) {
Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Delete checked tasks toggle changed:', event.target.checked);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle available for delete checked tasks change');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].deleteCheckedTasks = event.target.checked;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â refreshTaskListUI();
Â Â Â Â Â Â Â Â console.log('âœ… Delete checked tasks setting saved to Schema 2.5');
Â Â Â Â }

Â Â Â Â // âœ… Add new event listeners
Â Â Â Â toggleAutoReset.addEventListener("change", handleAutoResetChange);
Â Â Â Â deleteCheckedTasks.addEventListener("change", handleDeleteCheckedTasksChange);
Â Â Â Â 
Â Â Â Â console.log('âœ… Toggle auto reset setup completed');
}




Â Â Â Â /**
Â * Checkduedates function.
Â *
Â * @returns {void}
Â */

function checkDueDates() {
Â Â Â Â console.log('ğŸ“… Setting up due date checks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // Make sure we only attach the listener once
Â Â Â Â if (!toggleAutoReset.dataset.listenerAdded) {
Â Â Â Â Â Â Â Â toggleAutoReset.dataset.listenerAdded = true;

Â Â Â Â Â Â Â Â toggleAutoReset.addEventListener("change", function () {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ”„ Auto reset toggle changed for due dates:', this.checked);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â let autoReset = this.checked;
Â Â Â Â Â Â Â Â Â Â Â Â updateDueDateVisibility(autoReset);
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for checkDueDates');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (activeCycle && cycles[activeCycle]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ’¾ Updating auto reset setting in Schema 2.5');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].autoReset = autoReset;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('âœ… Auto reset setting saved to Schema 2.5');
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for due date settings');
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â }

Â Â Â Â // âœ… Prevent duplicate event listeners before adding a new one
Â Â Â Â document.removeEventListener("change", handleDueDateChange);
Â Â Â Â document.addEventListener("change", handleDueDateChange);
Â Â Â Â 
Â Â Â Â console.log('âœ… Due date check setup completed');
}
Â Â Â Â 
Â Â Â Â // âœ… Function to handle due date changes (placed outside to avoid re-declaration)
Â Â Â Â function handleDueDateChange(event) {
Â Â Â Â Â Â Â Â if (!event.target.classList.contains("due-date")) return;
Â Â Â Â 
Â Â Â Â Â Â Â Â let taskItem = event.target.closest(".task");
Â Â Â Â Â Â Â Â let taskId = taskItem.dataset.taskId;
Â Â Â Â Â Â Â Â let dueDateValue = event.target.value;
Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“… Handling due date change (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for handleDueDateChange');
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â const { cycles, activeCycle, reminders } = schemaData;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error("âŒ Error: Active cycle not found in Schema 2.5.");
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ” Finding task for due date update:', taskId);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const task = cycles[activeCycle].tasks?.find(t => t.id === taskId);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!task) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn(`âš ï¸ Task with ID "${taskId}" not found in active cycle`);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ï¿½ Updating due date:', {
Â Â Â Â Â Â Â Â Â Â Â Â taskId,
Â Â Â Â Â Â Â Â Â Â Â Â taskText: task.text,
Â Â Â Â Â Â Â Â Â Â Â Â oldDueDate: task.dueDate,
Â Â Â Â Â Â Â Â Â Â Â Â newDueDate: dueDateValue
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Update task due date
Â Â Â Â Â Â Â Â task.dueDate = dueDateValue;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Update the full schema data
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycles[activeCycle];
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log(`âœ… Due date updated (Schema 2.5): "${task.text}" â†’ ${dueDateValue || 'cleared'}`);
Â Â Â Â 
Â Â Â Â Â Â Â Â checkOverdueTasks(taskItem);
Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Load Due Date Notification Setting from Schema 2.5
Â Â Â Â Â Â Â Â const remindersSettings = reminders || {};
Â Â Â Â Â Â Â Â const dueDatesRemindersEnabled = remindersSettings.dueDatesReminders;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“¢ Due date reminders enabled:', dueDatesRemindersEnabled);
Â Â Â Â 
Â Â Â Â Â Â Â Â if (!dueDatesRemindersEnabled) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('â­ï¸ Skipping due date notification - reminders disabled');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â 
Â Â Â Â Â Â Â Â if (dueDateValue) {
Â Â Â Â Â Â Â Â Â Â Â Â const today = new Date().setHours(0, 0, 0, 0);
Â Â Â Â Â Â Â Â Â Â Â Â const selectedDate = new Date(dueDateValue).setHours(0, 0, 0, 0);
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â if (selectedDate > today) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskText = task.text;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification(`ğŸ“… Task "${taskText}" is due soon!`, "default");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“¢ Due date notification shown for:', taskText);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â 
Â Â Â Â // âœ… Apply initial visibility state on load
Â Â Â Â let autoReset = toggleAutoReset.checked;
Â Â Â Â updateDueDateVisibility(autoReset);
Â Â Â Â 
Â Â Â Â 

/**
Â * Updates the visibility of due date fields and related UI elements based on Auto Reset settings.
Â *
Â * @param {boolean} autoReset - Whether Auto Reset is enabled.
Â */
Â Â Â Â function updateDueDateVisibility(autoReset) {
Â Â Â Â Â Â Â Â const dueDatesRemindersOption = document.getElementById("dueDatesReminders").parentNode; // Get the label container
Â Â Â Â Â Â Â Â if (dueDatesRemindersOption) {
Â Â Â Â Â Â Â Â Â Â Â Â dueDatesRemindersOption.style.display = autoReset ? "none" : "block";
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 

Â Â Â Â Â Â Â Â // Toggle visibility of "Set Due Date" buttons
Â Â Â Â Â Â Â Â document.querySelectorAll(".set-due-date").forEach(button => {
Â Â Â Â Â Â Â Â Â Â Â Â button.classList.toggle("hidden", autoReset);
Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â if (autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Auto Reset ON = hide all due dates
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".due-date").forEach(input => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â input.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Remove overdue visual styling
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".overdue-task").forEach(task => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("overdue-task");
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â // Auto Reset OFF = show due dates ONLY if they have a value
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".due-date").forEach(input => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (input.value) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â input.classList.remove("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â input.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Dynamically add the "Set Due Date" button to tasks that donâ€™t have it
Â Â Â Â Â Â Â Â Â Â Â Â document.querySelectorAll(".task").forEach(taskItem => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let buttonContainer = taskItem.querySelector(".task-options");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let existingDueDateButton = buttonContainer.querySelector(".set-due-date");
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!existingDueDateButton) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const dueDateButton = document.createElement("button");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateButton.classList.add("task-btn", "set-due-date");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateButton.innerHTML = "<i class='fas fa-calendar-alt'></i>";
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateButton.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const dueDateInput = taskItem.querySelector(".due-date");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput.classList.toggle("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â buttonContainer.insertBefore(dueDateButton, buttonContainer.children[2]); // Insert in correct position
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Recheck and reapply overdue classes as needed
Â Â Â Â Â Â Â Â Â Â Â Â checkOverdueTasks();
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â 
Â Â Â Â 
Â Â Â Â 



Â Â Â Â 


Â if (!deleteCheckedTasks.dataset.listenerAdded) {
Â Â Â Â deleteCheckedTasks.addEventListener("change", (event) => {
Â Â Â Â Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Delete checked tasks toggle changed (Schema 2.5 only)...');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for deleteCheckedTasks toggle');
Â Â Â Â Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!activeCycle || !currentCycle) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for delete checked tasks toggle');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Update Schema 2.5
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle].deleteCheckedTasks = event.target.checked;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â Â Â Â Â // âœ… Update recurring button visibility in real-time
Â Â Â Â Â Â Â Â updateRecurringButtonVisibility();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Delete checked tasks setting saved (Schema 2.5)');
Â Â Â Â });

Â Â Â Â deleteCheckedTasks.dataset.listenerAdded = true;Â 
}

/**
Â * Closes the menu when clicking outside of it.
Â * Ensures the menu only closes when clicking outside both the menu and menu button.
Â *
Â * @param {MouseEvent} event - The click event that triggers the check.
Â */

function closeMenuOnClickOutside(event) {
Â Â Â Â if (!menu.contains(event.target) && !menuButton.contains(event.target)) {
Â Â Â Â Â Â Â Â menu.classList.remove("visible"); // Hide the menu
Â Â Â Â Â Â Â Â document.removeEventListener("click", closeMenuOnClickOutside); // âœ… Remove listener after closing
Â Â Â Â }
}



/**
Â * Hidemainmenu function.
Â *
Â * @returns {void}
Â */

function hideMainMenu() {
Â Â Â Â const menu = document.querySelector(".menu-container");
Â Â Â Â menu.classList.remove("visible");
}



// âœ… Function to complete all tasks and handle reset
function handleCompleteAllTasks() {
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â console.log('âœ”ï¸ Handling complete all tasks (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for handleCompleteAllTasks');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const cycleData = cycles[activeCycle];

Â Â Â Â // âœ… Ensure there's an active miniCycle
Â Â Â Â if (!activeCycle || !cycleData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for complete all tasks');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â console.log('ğŸ“Š Processing complete all tasks for cycle:', activeCycle);

Â Â Â Â // âœ… Only show alert if tasks will be reset (not deleted)
Â Â Â Â if (!cycleData.deleteCheckedTasks) {
Â Â Â Â Â Â Â Â const hasDueDates = [...taskList.querySelectorAll(".due-date")].some(
Â Â Â Â Â Â Â Â Â Â Â Â dueDateInput => dueDateInput.value
Â Â Â Â Â Â Â Â );

Â Â Â Â Â Â Â Â if (hasDueDates) {
Â Â Â Â Â Â Â Â Â Â Â Â showConfirmationModal({
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "Reset Tasks with Due Dates",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â message: "âš ï¸ This will complete all tasks and reset them to an uncompleted state.<br><br>Any assigned Due Dates will be cleared.<br><br>Proceed?",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â confirmText: "Reset Tasks",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cancelText: "Cancel",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â callback: (confirmed) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!confirmed) return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (cycleData.deleteCheckedTasks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const checkedTasks = document.querySelectorAll(".task input:checked");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (checkedTasks.length === 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš ï¸ No tasks were selected for deletion.", "default", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkedTasks.forEach(checkbox => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â const taskId = checkbox.closest(".task").dataset.taskId;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Remove from Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â cycleData.tasks = cycleData.tasks.filter(t => t.id !== taskId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkbox.closest(".task").remove();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // âœ… Use autoSave() instead of direct save
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â autoSave();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskList.querySelectorAll(".task input").forEach(task => task.checked = true);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â checkMiniCycle();
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!cycleData.autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(resetTasks, 1000);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â if (cycleData.deleteCheckedTasks) {
Â Â Â Â Â Â Â Â const checkedTasks = document.querySelectorAll(".task input:checked");
Â Â Â Â Â Â Â Â if (checkedTasks.length === 0) {
Â Â Â Â Â Â Â Â Â Â Â Â showNotification("âš ï¸ No tasks were selected for deletion.", "default", 3000);
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Deleting checked tasks from Schema 2.5');

Â Â Â Â Â Â Â Â checkedTasks.forEach(checkbox => {
Â Â Â Â Â Â Â Â Â Â Â Â const taskId = checkbox.closest(".task").dataset.taskId;
Â Â Â Â Â Â Â Â Â Â Â Â // Remove from Schema 2.5
Â Â Â Â Â Â Â Â Â Â Â Â cycleData.tasks = cycleData.tasks.filter(t => t.id !== taskId);
Â Â Â Â Â Â Â Â Â Â Â Â checkbox.closest(".task").remove();
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Update Schema 2.5 data
Â Â Â Â Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â Â Â Â Â fullSchemaData.data.cycles[activeCycle] = cycleData;
Â Â Â Â Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â } else {
Â Â Â Â Â Â Â Â // âœ… If "Delete Checked Tasks" is OFF, just mark all as complete
Â Â Â Â Â Â Â Â console.log('âœ”ï¸ Marking all tasks as complete');
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â taskList.querySelectorAll(".task input").forEach(task => task.checked = true);
Â Â Â Â Â Â Â Â checkMiniCycle();

Â Â Â Â Â Â Â Â // âœ… Only call resetTasks() if autoReset is OFF
Â Â Â Â Â Â Â Â if (!cycleData.autoReset) {
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(resetTasks, 1000);
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Complete all tasks handled (Schema 2.5)');
}

// âœ… Use the new function with safe listener
safeAddEventListener(completeAllButton, "click", handleCompleteAllTasks);


/***********************
Â *Â 
Â *Â 
Â * Add Event Listeners
Â *Â 
Â *Â 
Â ************************/
// ğŸŸ¢ Add Task Button (Click)
safeAddEventListener(addTaskButton, "click", () => {
Â Â Â Â const taskText = taskInput.value ? taskInput.value.trim() : "";
Â Â Â Â if (!taskText) {
Â Â Â Â Â Â Â Â console.warn("âš  Cannot add an empty task.");
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â pushUndoSnapshot();Â 
Â Â Â Â addTask(taskText);
Â Â Â Â taskInput.value = "";
});

// ğŸŸ¢ Task Input (Enter Key)
safeAddEventListener(taskInput, "keypress", function (event) {
Â Â Â Â if (event.key === "Enter") {
Â Â Â Â Â Â Â Â event.preventDefault();
Â Â Â Â Â Â Â Â const taskText = taskInput.value ? taskInput.value.trim() : "";
Â Â Â Â Â Â Â Â if (!taskText) {
Â Â Â Â Â Â Â Â Â Â Â Â console.warn("âš  Cannot add an empty task.");
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â pushUndoSnapshot();Â 
Â Â Â Â Â Â Â Â addTask(taskText);
Â Â Â Â Â Â Â Â taskInput.value = "";
Â Â Â Â }
});

function syncCurrentSettingsToStorage() {
Â Â Â Â console.log('âš™ï¸ Syncing current settings to storage (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for syncCurrentSettingsToStorage');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const toggleAutoReset = document.getElementById("toggleAutoReset");
Â Â Â Â const deleteCheckedTasks = document.getElementById("deleteCheckedTasks");
Â Â Â Â 
Â Â Â Â if (!activeCycle || !cycles[activeCycle]) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for settings sync');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (!toggleAutoReset || !deleteCheckedTasks) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Settings toggles not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Syncing settings:', {
Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â autoReset: toggleAutoReset.checked,
Â Â Â Â Â Â Â Â deleteCheckedTasks: deleteCheckedTasks.checked
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Update Schema 2.5 data
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle].autoReset = toggleAutoReset.checked;
Â Â Â Â fullSchemaData.data.cycles[activeCycle].deleteCheckedTasks = deleteCheckedTasks.checked;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Settings synced to Schema 2.5 successfully');
}


// ğŸŸ¢ Menu Button (Click) - âœ… FIXED: ES5 compatible function expression
safeAddEventListener(menuButton, "click", function(event) {
Â Â Â Â event.stopPropagation();
Â Â Â Â syncCurrentSettingsToStorage(); // âœ… Now supports both schemas
Â Â Â Â saveToggleAutoReset(); // âœ… Already updated with Schema 2.5 support
Â Â Â Â menu.classList.toggle("visible");

Â Â Â Â if (menu.classList.contains("visible")) {
Â Â Â Â Â Â Â Â document.addEventListener("click", closeMenuOnClickOutside);
Â Â Â Â }
});



safeAddEventListenerById("reset-notification-position", "click", () => {
Â Â Â Â console.log('ğŸ”„ Resetting notification position (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for reset notification position');
Â Â Â Â Â Â Â Â showNotification("âŒ Schema 2.5 data required.", "error", 2000);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â 
Â Â Â Â // Reset notification position in Schema 2.5
Â Â Â Â fullSchemaData.settings.notificationPosition = { x: 0, y: 0 };
Â Â Â Â fullSchemaData.settings.notificationPositionModified = false;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Notification position reset in Schema 2.5');
Â Â Â Â 
Â Â Â Â // Reset UI position
Â Â Â Â resetNotificationPosition();
Â Â Â Â 
Â Â Â Â showNotification("ğŸ”„ Notification position reset (Schema 2.5).", "success", 2000);
});

document.getElementById("open-reminders-modal")?.addEventListener("click", () => {
Â Â Â Â console.log('ğŸ”” Opening reminders modal (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // Load current settings from Schema 2.5 before opening
Â Â Â Â loadRemindersSettings(); // This function already has Schema 2.5 support
Â Â Â Â document.getElementById("reminders-modal").style.display = "flex";
Â Â Â Â hideMainMenu();
Â Â Â Â 
Â Â Â Â console.log('âœ… Reminders modal opened');
});

// âœ… Updated reset onboarding with Schema 2.5 only
safeAddEventListenerById("reset-onboarding", "click", () => {
Â Â Â Â console.log('ğŸ¯ Resetting onboarding (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for reset onboarding');
Â Â Â Â Â Â Â Â showNotification("âŒ Schema 2.5 data required.", "error", 2000);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â 
Â Â Â Â // Clear onboarding flag in Schema 2.5
Â Â Â Â fullSchemaData.settings.onboardingCompleted = false;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Onboarding flag reset in Schema 2.5');
Â Â Â Â 
Â Â Â Â showNotification("âœ… Onboarding will show again next time you open the app (Schema 2.5).", "success", 3000);
});
Â 



// ğŸŸ¢ Safe Global Click for Hiding Task Buttons
safeAddEventListener(document, "click", (event) => {
Â Â Â Â let isTaskOrOptionsClick = event.target.closest(".task, .task-options");
Â Â Â Â let isModalClick = event.target.closest(".modal, .mini-modal-overlay, .settings-modal, .notification");
Â Â Â Â 
Â Â Â Â if (!isTaskOrOptionsClick && !isModalClick) {
Â Â Â Â Â Â Â Â console.log("âœ… Clicking outside - closing task buttons");

Â Â Â Â Â Â Â Â document.querySelectorAll(".task-options").forEach(action => {
Â Â Â Â Â Â Â Â Â Â Â Â action.style.opacity = "0";
Â Â Â Â Â Â Â Â Â Â Â Â action.style.visibility = "hidden";
Â Â Â Â Â Â Â Â Â Â Â Â action.style.pointerEvents = "none";
Â Â Â Â Â Â Â Â });

Â Â Â Â Â Â Â Â document.querySelectorAll(".task").forEach(task => {
Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("long-pressed");
Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("draggable");
Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("dragging");
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â // Only remove selected class if not in recurring panel
Â Â Â Â Â Â Â Â Â Â Â Â if (!document.getElementById("recurring-panel-overlay")?.classList.contains("hidden")) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Keep selections in recurring panel
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â task.classList.remove("selected");
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â }
});

// ğŸŸ¢ Safe Global Click for Deselecting miniCycle in Switch Modal
safeAddEventListener(document, "click", (event) => {
Â Â Â Â const switchModalContent = document.querySelector(".mini-cycle-switch-modal-content");
Â Â Â Â const selectedCycle = document.querySelector(".mini-cycle-switch-item.selected");
Â Â Â Â const switchItemsRow = document.getElementById("switch-items-row");
Â Â Â Â const previewWindow = document.querySelector(".switch-preview-window");

Â Â Â Â if (
Â Â Â Â Â Â Â Â switchModalContent?.contains(event.target) &&
Â Â Â Â Â Â Â Â selectedCycle &&
Â Â Â Â Â Â Â Â !event.target.classList.contains("mini-cycle-switch-item") &&
Â Â Â Â Â Â Â Â !previewWindow?.contains(event.target)
Â Â Â Â ) {
Â Â Â Â Â Â Â Â selectedCycle.classList.remove("selected");
Â Â Â Â Â Â Â Â if (switchItemsRow) {
Â Â Â Â Â Â Â Â Â Â Â Â switchItemsRow.style.display = "none";
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Clear preview content
Â Â Â Â Â Â Â Â if (previewWindow) {
Â Â Â Â Â Â Â Â Â Â Â Â previewWindow.innerHTML = '<p style="color: #888; font-style: italic;">Select a miniCycle to preview</p>';
Â Â Â Â Â Â Â Â }
Â Â Â Â }
});




// âœ… Modal Utility Functions
function closeAllModals() {
Â Â Â Â // Close Schema 2.5 and legacy modals
Â Â Â Â const modalSelectors = [
Â Â Â Â Â Â Â Â "[data-modal]",
Â Â Â Â Â Â Â Â ".settings-modal",
Â Â Â Â Â Â Â Â ".mini-cycle-switch-modal",
Â Â Â Â Â Â Â Â "#feedback-modal",
Â Â Â Â Â Â Â Â "#about-modal",Â 
Â Â Â Â Â Â Â Â "#themes-modal",
Â Â Â Â Â Â Â Â "#games-panel",
Â Â Â Â Â Â Â Â "#reminders-modal",
Â Â Â Â Â Â Â Â "#testing-modal",
Â Â Â Â Â Â Â Â "#recurring-panel-overlay",
Â Â Â Â Â Â Â Â "#storage-viewer-overlay",
Â Â Â Â Â Â Â Â ".mini-modal-overlay",
Â Â Â Â Â Â Â Â ".miniCycle-overlay",
Â Â Â Â Â Â Â Â ".onboarding-modal"
Â Â Â Â ];
Â Â Â Â 
Â Â Â Â modalSelectors.forEach(selector => {
Â Â Â Â Â Â Â Â document.querySelectorAll(selector).forEach(modal => {
Â Â Â Â Â Â Â Â Â Â Â Â // Special handling for different modal types
Â Â Â Â Â Â Â Â Â Â Â Â if (modal.dataset.modal !== undefined || modal.classList.contains("menu-container")) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â modal.classList.remove("visible");
Â Â Â Â Â Â Â Â Â Â Â Â } else if (modal.id === "recurring-panel-overlay" || modal.id === "storage-viewer-overlay") {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â modal.classList.add("hidden");
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â modal.style.display = "none";
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â });

Â Â Â Â // Close task options
Â Â Â Â document.querySelectorAll(".task-options").forEach(action => {
Â Â Â Â Â Â Â Â action.style.opacity = "0";
Â Â Â Â Â Â Â Â action.style.visibility = "hidden";
Â Â Â Â Â Â Â Â action.style.pointerEvents = "none";
Â Â Â Â });

Â Â Â Â // Reset task states
Â Â Â Â document.querySelectorAll(".task").forEach(task => {
Â Â Â Â Â Â Â Â task.classList.remove("long-pressed", "draggable", "dragging", "selected");
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Clear any active selections in recurring panels
Â Â Â Â document.querySelectorAll(".recurring-task-item.selected").forEach(item => {
Â Â Â Â Â Â Â Â item.classList.remove("selected");
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // Hide recurring settings panel if open
Â Â Â Â const recurringSettingsPanel = document.getElementById("recurring-settings-panel");
Â Â Â Â if (recurringSettingsPanel) {
Â Â Â Â Â Â Â Â recurringSettingsPanel.classList.add("hidden");
Â Â Â Â }
}


// âœ… ESC key listener to close modals and reset task UI
safeAddEventListener(document, "keydown", (e) => {
Â Â Â Â if (e.key === "Escape") {
Â Â Â Â Â Â Â Â e.preventDefault();
Â Â Â Â Â Â Â Â closeAllModals();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Also clear any notification focus
Â Â Â Â Â Â Â Â const notifications = document.querySelectorAll(".notification");
Â Â Â Â Â Â Â Â notifications.forEach(notification => {
Â Â Â Â Â Â Â Â Â Â Â Â if (notification.querySelector(".close-btn")) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â notification.querySelector(".close-btn").click();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Return focus to task input
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â const taskInput = document.getElementById("taskInput");
Â Â Â Â Â Â Â Â Â Â Â Â if (taskInput && document.activeElement !== taskInput) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â taskInput.focus();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }, 100);
Â Â Â Â }
});



// Update your existing HelpWindowManager class to show mode descriptions:
class HelpWindowManager {
Â Â Â Â constructor() {
Â Â Â Â Â Â Â Â this.helpWindow = document.getElementById('help-window');
Â Â Â Â Â Â Â Â this.isVisible = false;
Â Â Â Â Â Â Â Â this.currentMessage = null;
Â Â Â Â Â Â Â Â this.isShowingCycleComplete = false;
Â Â Â Â Â Â Â Â this.isShowingModeDescription = false;
Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = null;
Â Â Â Â Â Â Â Â this.initialized = false; // âœ… Prevent double initialization
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.init();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â init() {
Â Â Â Â Â Â Â Â if (!this.helpWindow || this.initialized) {
Â Â Â Â Â Â Â Â Â Â Â Â if (this.initialized) console.warn('âš ï¸ HelpWindowManager already initialized');
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.initialized = true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Start showing initial message after a delay
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â this.showConstantMessage();
Â Â Â Â Â Â Â Â }, 3000);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… IMPROVED: Multiple event listeners for better coverage
Â Â Â Â Â Â Â Â this.setupEventListeners();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â setupEventListeners() {
Â Â Â Â // âœ… More aggressive event listening
Â Â Â Â document.addEventListener('change', (e) => {
Â Â Â Â Â Â Â Â console.log("ğŸ“¡ Change event detected:", e.target); // Debug log
Â Â Â Â Â Â Â Â if (e.target.type === 'checkbox' && e.target.closest('.task')) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log("ğŸ“‹ Task checkbox change detected"); // Debug log
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â Â Â Â Â }, 50);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // âœ… ADDITIONAL: Listen for click events on tasks
Â Â Â Â document.addEventListener('click', (e) => {
Â Â Â Â Â Â Â Â if (e.target.closest('.task')) {
Â Â Â Â Â Â Â Â Â Â Â Â console.log("ğŸ“‹ Task click detected"); // Debug log
Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â Â Â Â Â }, 100);
Â Â Â Â Â Â Â Â }
Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… ADDITIONAL: Listen for task list mutations (task additions/deletions)
Â Â Â Â Â Â Â Â const taskList = document.getElementById('taskList');
Â Â Â Â Â Â Â Â if (taskList) {
Â Â Â Â Â Â Â Â Â Â Â Â const observer = new MutationObserver((mutations) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â let shouldUpdate = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â mutations.forEach(mutation => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Check if tasks were added or removed
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (mutation.type === 'childList' &&Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â shouldUpdate = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (shouldUpdate) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ Help window: Task list changed');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }, 200);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â observer.observe(taskList, {Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â childList: true,Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â subtree: true // âœ… Also watch for changes in child elements
Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… ADDITIONAL: Listen for custom events that might affect task status
Â Â Â Â Â Â Â Â document.addEventListener('taskCompleted', () => {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ Help window: Custom taskCompleted event');
Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â document.addEventListener('tasksReset', () => {
Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ“ Help window: Custom tasksReset event');
Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â });
Â Â Â Â }
Â 
Â Â Â Â 
Â Â Â Â showConstantMessage() {
Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â this.show();
Â Â Â Â }
Â Â Â Â 
Â Â Â Â updateConstantMessage() {
Â Â Â Â Â Â Â Â // Don't update if showing cycle completion message or mode description
Â Â Â Â Â Â Â Â if (this.isShowingCycleComplete || this.isShowingModeDescription) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const message = this.getCurrentStatusMessage();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (message !== this.currentMessage) {
Â Â Â Â Â Â Â Â Â Â Â Â this.currentMessage = message;
Â Â Â Â Â Â Â Â Â Â Â Â if (this.isVisible) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â this.updateContent(message);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… New method to show mode description temporarily
Â Â Â Â showModeDescription(mode) {
Â Â Â Â Â Â Â Â if (!this.helpWindow) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Clear any existing timeout
Â Â Â Â Â Â Â Â if (this.modeDescriptionTimeout) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(this.modeDescriptionTimeout);
Â Â Â Â Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = null;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.isShowingModeDescription = true;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const modeDescriptions = {
Â Â Â Â Â Â Â Â Â Â Â Â 'auto-cycle': {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "ğŸ”„ Auto Cycle Mode",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â description: "Tasks automatically reset when all are completed."
Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â 'manual-cycle': {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "âœ”ï¸ Manual Cycle Mode",Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â description: "Tasks only reset when you click the Complete button."
Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â 'todo-mode': {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â title: "âœ“ To-Do Mode",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â description: "Completed tasks are removed when you click Complete."
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const modeInfo = modeDescriptions[mode] || modeDescriptions['auto-cycle'];
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.helpWindow.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â <div class="mode-help-content">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <h4 style="margin: 0 0 8px 0; color: var(--accent-color, #007bff);">${modeInfo.title}</h4>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <p style="margin: 0; line-height: 1.4;">${modeInfo.description}</p>
Â Â Â Â Â Â Â Â Â Â Â Â </div>
Â Â Â Â Â Â Â Â `;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Show the help window if it's not already visible
Â Â Â Â Â Â Â Â if (!this.isVisible) {
Â Â Â Â Â Â Â Â Â Â Â Â this.show();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Auto-hide after 30 seconds and return to normal message
Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â this.isShowingModeDescription = false;
Â Â Â Â Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = null;
Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â }, 30000); // 30 seconds
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log(`ğŸ“– Showing mode description for: ${mode}`);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Method to show cycle completion message (keep existing)
Â Â Â Â showCycleCompleteMessage() {
Â Â Â Â Â Â Â Â if (!this.helpWindow) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Clear mode description if showing
Â Â Â Â Â Â Â Â if (this.modeDescriptionTimeout) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(this.modeDescriptionTimeout);
Â Â Â Â Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = null;
Â Â Â Â Â Â Â Â Â Â Â Â this.isShowingModeDescription = false;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.isShowingCycleComplete = true;
Â Â Â Â Â Â Â Â this.helpWindow.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â <p>âœ… Cycle Complete! Tasks reset.</p>
Â Â Â Â Â Â Â Â `;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Auto-hide after 2 seconds and return to normal message
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â this.isShowingCycleComplete = false;
Â Â Â Â Â Â Â Â Â Â Â Â this.updateConstantMessage();
Â Â Â Â Â Â Â Â }, 2000);
Â Â Â Â }
Â Â Â Â 
Â // In the getCurrentStatusMessage() method, around line 4400:
getCurrentStatusMessage() {
Â Â Â Â const totalTasks = document.querySelectorAll('.task').length;
Â Â Â Â const completedTasks = document.querySelectorAll('.task input:checked').length;
Â Â Â Â const remaining = totalTasks - completedTasks;
Â Â Â Â 
Â Â Â Â // âœ… Get cycle count from Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â let cycleCount = 0;
Â Â Â Â 
Â Â Â Â if (schemaData) {
Â Â Â Â Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â Â Â Â Â cycleCount = currentCycle?.cycleCount || 0;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Return different constant messages based on state
Â Â Â Â if (totalTasks === 0) {
Â Â Â Â Â Â Â Â return `ğŸ“ Add your first task to get started! â€¢ ${cycleCount} cycle${cycleCount === 1 ? '' : 's'} completed`;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (remaining === 0 && totalTasks > 0) {
Â Â Â Â Â Â Â Â return `ğŸ‰ All tasks complete! â€¢ ${cycleCount} cycle${cycleCount === 1 ? '' : 's'} completed`;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â if (cycleCount === 0) {
Â Â Â Â Â Â Â Â return `ğŸ“‹ ${remaining} task${remaining === 1 ? '' : 's'} remaining â€¢ Complete your first cycle!`;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // Show progress and cycle count
Â Â Â Â return `ğŸ“‹ ${remaining} task${remaining === 1 ? '' : 's'} remaining â€¢ ${cycleCount} cycle${cycleCount === 1 ? '' : 's'} completed`;
}
Â Â Â Â 
Â Â Â Â updateContent(message) {
Â Â Â Â Â Â Â Â if (!this.helpWindow) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.helpWindow.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â <p>${message}</p>
Â Â Â Â Â Â Â Â `;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â show() {
Â Â Â Â Â Â Â Â if (!this.helpWindow || this.isVisible) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â const message = this.currentMessage || this.getCurrentStatusMessage();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (!this.isShowingModeDescription && !this.isShowingCycleComplete) {
Â Â Â Â Â Â Â Â Â Â Â Â this.helpWindow.innerHTML = `
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â <p>${message}</p>
Â Â Â Â Â Â Â Â Â Â Â Â `;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.helpWindow.classList.remove('hide');
Â Â Â Â Â Â Â Â this.helpWindow.classList.add('show');
Â Â Â Â Â Â Â Â this.helpWindow.style.display = 'flex';
Â Â Â Â Â Â Â Â this.isVisible = true;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â hide() {
Â Â Â Â Â Â Â Â if (!this.helpWindow || !this.isVisible) return;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â this.helpWindow.classList.remove('show');
Â Â Â Â Â Â Â Â this.helpWindow.classList.add('hide');
Â Â Â Â Â Â Â Â this.isVisible = false;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â this.helpWindow.style.display = 'none';
Â Â Â Â Â Â Â Â }, 300);
Â Â Â Â }
Â Â Â Â 
Â Â Â Â destroy() {
Â Â Â Â Â Â Â Â // Clear any active timeouts
Â Â Â Â Â Â Â Â if (this.modeDescriptionTimeout) {
Â Â Â Â Â Â Â Â Â Â Â Â clearTimeout(this.modeDescriptionTimeout);
Â Â Â Â Â Â Â Â Â Â Â Â this.modeDescriptionTimeout = null;
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}

// Initialize help window manager (keep this part the same)
let helpWindowManager;

setTimeout(() => {
Â Â Â Â helpWindowManager = new HelpWindowManager();
}, 500);

// âœ… Updated setupModeSelector to show help descriptions on mode change
function setupModeSelector() {
Â Â Â Â console.log('ğŸ¯ Setting up mode selectors...');
Â Â Â Â 
Â Â Â Â const modeSelector = document.getElementById('mode-selector');
Â Â Â Â const mobileModeSelector = document.getElementById('mobile-mode-selector');
Â Â Â Â const toggleAutoReset = document.getElementById('toggleAutoReset');
Â Â Â Â const deleteCheckedTasks = document.getElementById('deleteCheckedTasks');
Â Â Â Â 
Â Â Â Â console.log('ğŸ” Element detection:', {
Â Â Â Â Â Â Â Â modeSelector: !!modeSelector,
Â Â Â Â Â Â Â Â mobileModeSelector: !!mobileModeSelector,
Â Â Â Â Â Â Â Â toggleAutoReset: !!toggleAutoReset,
Â Â Â Â Â Â Â Â deleteCheckedTasks: !!deleteCheckedTasks
Â Â Â Â });
Â Â Â Â 
Â Â Â Â if (!modeSelector || !mobileModeSelector || !toggleAutoReset || !deleteCheckedTasks) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Mode selector elements not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
// âœ… Function to sync both selectors with toggles (Schema 2.5 only)
function syncModeFromToggles() {
Â Â Â Â console.log('ğŸ”„ Syncing mode from toggles (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for syncModeFromToggles');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â let autoReset = false;
Â Â Â Â let deleteChecked = false;
Â Â Â Â 
Â Â Â Â if (currentCycle) {
Â Â Â Â Â Â Â Â autoReset = currentCycle.autoReset || false;
Â Â Â Â Â Â Â Â deleteChecked = currentCycle.deleteCheckedTasks || false;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Mode settings from Schema 2.5:', {
Â Â Â Â Â Â Â Â Â Â Â Â activeCycle,
Â Â Â Â Â Â Â Â Â Â Â Â autoReset,
Â Â Â Â Â Â Â Â Â Â Â Â deleteChecked
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… CRITICAL FIX: Update DOM to match data
Â Â Â Â Â Â Â Â toggleAutoReset.checked = autoReset;
Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = deleteChecked;
Â Â Â Â } else {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found, using DOM state as fallback');
Â Â Â Â Â Â Â Â // âœ… Fallback to DOM state only if no saved data exists
Â Â Â Â Â Â Â Â autoReset = toggleAutoReset.checked;
Â Â Â Â Â Â Â Â deleteChecked = deleteCheckedTasks.checked;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ”„ Syncing mode from data source:', { autoReset, deleteChecked });
Â Â Â Â 
Â Â Â Â let mode = 'auto-cycle';
Â Â Â Â 
Â Â Â Â // âœ… FIXED: Check deleteChecked FIRST before other conditions
Â Â Â Â if (deleteChecked) {
Â Â Â Â Â Â Â Â mode = 'todo-mode';
Â Â Â Â } else if (autoReset && !deleteChecked) {
Â Â Â Â Â Â Â Â mode = 'auto-cycle';
Â Â Â Â } else if (!autoReset && !deleteChecked) {
Â Â Â Â Â Â Â Â mode = 'manual-cycle';Â Â 
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“ Setting both selectors to:', mode);
Â Â Â Â 
Â Â Â Â // Update both selectors
Â Â Â Â modeSelector.value = mode;
Â Â Â Â mobileModeSelector.value = mode;
Â Â Â Â 
Â Â Â Â // Update body classes
Â Â Â Â document.body.className = document.body.className.replace(/\b(auto-cycle-mode|manual-cycle-mode|todo-mode)\b/g, '');
Â Â Â Â document.body.classList.add(mode + '-mode');
Â Â Â Â 
Â Â Â Â // âœ… FIXED: Update container visibility based on mode, not just autoReset
Â Â Â Â const deleteContainer = document.getElementById('deleteCheckedTasksContainer');
Â Â Â Â if (deleteContainer) {
Â Â Â Â Â Â Â Â // Show delete container in manual-cycle and todo-mode, hide in auto-cycle
Â Â Â Â Â Â Â Â const shouldShow = (mode === 'manual-cycle' || mode === 'todo-mode');
Â Â Â Â Â Â Â Â deleteContainer.style.display = shouldShow ? 'block' : 'none';
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('âœ… Mode selectors synced to Schema 2.5:', mode);
}
Â Â Â Â 
Â Â Â Â // âœ… Function to sync toggles from either selector
Â Â Â Â function syncTogglesFromMode(selectedMode) {
Â Â Â Â Â Â Â Â console.log('ğŸ”„ Syncing toggles from mode selector:', selectedMode);
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â switch(selectedMode) {
Â Â Â Â Â Â Â Â Â Â Â Â case 'auto-cycle':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleAutoReset.checked = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â case 'manual-cycle':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleAutoReset.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â Â Â Â Â case 'todo-mode':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â toggleAutoReset.checked = false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â deleteCheckedTasks.checked = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Keep both selectors in sync
Â Â Â Â Â Â Â Â modeSelector.value = selectedMode;
Â Â Â Â Â Â Â Â mobileModeSelector.value = selectedMode;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… UPDATE STORAGE FIRST before dispatching events
Â Â Â Â Â Â Â Â updateStorageFromToggles();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… THEN trigger change events (but prevent them from updating storage again)
Â Â Â Â Â Â Â Â console.log('ğŸ”” Dispatching change events to update storage...');
Â Â Â Â Â Â Â Â toggleAutoReset.dispatchEvent(new Event('change'));
Â Â Â Â Â Â Â Â deleteCheckedTasks.dispatchEvent(new Event('change'));
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // Update UI
Â Â Â Â Â Â Â Â syncModeFromToggles();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â if (typeof updateRecurringButtonVisibility === 'function') {
Â Â Â Â Â Â Â Â Â Â Â Â updateRecurringButtonVisibility();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â // âœ… Show mode description in help window
Â Â Â Â Â Â Â Â if (helpWindowManager && typeof helpWindowManager.showModeDescription === 'function') {
Â Â Â Â Â Â Â Â Â Â Â Â helpWindowManager.showModeDescription(selectedMode);
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â console.log('âœ… Toggles synced from mode selector');
Â Â Â Â }
Â Â Â Â 
Â Â Â Â // âœ… Add this helper function to update storage from current toggle states
function updateStorageFromToggles() {
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateStorageFromToggles');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â if (!currentCycle) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ No active cycle found for storage update');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â const toggleAutoReset = document.getElementById('toggleAutoReset');
Â Â Â Â const deleteCheckedTasks = document.getElementById('deleteCheckedTasks');
Â Â Â Â 
Â Â Â Â // Update Schema 2.5
Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.data.cycles[activeCycle].autoReset = toggleAutoReset.checked;
Â Â Â Â fullSchemaData.data.cycles[activeCycle].deleteCheckedTasks = deleteCheckedTasks.checked;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));
Â Â Â Â 
Â Â Â Â console.log('âœ… Storage updated from toggles (Schema 2.5)');
}Â 
Â Â Â Â // âœ… Set up event listeners for both selectors
Â Â Â Â console.log('ğŸ“¡ Setting up event listeners for both selectors...');
Â Â Â Â 
Â Â Â Â modeSelector.addEventListener('change', (e) => {
Â Â Â Â Â Â Â Â console.log('ğŸ¯ Desktop mode selector changed:', e.target.value);
Â Â Â Â Â Â Â Â syncTogglesFromMode(e.target.value);
Â Â Â Â Â Â Â Â showNotification(`Switched to ${getModeName(e.target.value)}`, 'info', 2000);
Â Â Â Â });
Â Â Â Â 
Â Â Â Â mobileModeSelector.addEventListener('change', (e) => {
Â Â Â Â Â Â Â Â console.log('ğŸ“± Mobile mode selector changed:', e.target.value);
Â Â Â Â Â Â Â Â syncTogglesFromMode(e.target.value);
Â Â Â Â Â Â Â Â showNotification(`Switched to ${getModeName(e.target.value)}`, 'info', 2000);
Â Â Â Â });
Â Â Â Â 
Â Â Â Â toggleAutoReset.addEventListener('change', (e) => {
Â Â Â Â Â Â Â Â console.log('ğŸ”˜ Auto Reset toggle changed:', e.target.checked);
Â Â Â Â Â Â Â Â syncModeFromToggles();
Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â });
Â Â Â Â 
Â Â Â Â deleteCheckedTasks.addEventListener('change', (e) => {
Â Â Â Â Â Â Â Â console.log('ğŸ—‘ï¸ Delete Checked Tasks toggle changed:', e.target.checked);
Â Â Â Â Â Â Â Â syncModeFromToggles();
Â Â Â Â Â Â Â Â Â checkCompleteAllButton();
Â Â Â Â });
Â Â Â Â 
Â Â Â Â // âœ… Initialize on load
Â Â Â Â console.log('ğŸš€ Initializing mode selectors...');
Â Â Â Â syncModeFromToggles();
Â Â Â Â 
Â Â Â Â console.log('âœ… Mode selectors setup complete');
}


// âœ… Updated updateCycleModeDescription to Schema 2.5 only
function updateCycleModeDescription() {
Â Â Â Â console.log('ğŸ“ Updating cycle mode description (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.error('âŒ Schema 2.5 data required for updateCycleModeDescription');
Â Â Â Â Â Â Â Â throw new Error('Schema 2.5 data not found');
Â Â Â Â }

Â Â Â Â const { cycles, activeCycle } = schemaData;
Â Â Â Â const currentCycle = cycles[activeCycle];
Â Â Â Â 
Â Â Â Â let autoReset = false;
Â Â Â Â let deleteChecked = false;
Â Â Â Â 
Â Â Â Â if (currentCycle) {
Â Â Â Â Â Â Â Â autoReset = currentCycle.autoReset || false;
Â Â Â Â Â Â Â Â deleteChecked = currentCycle.deleteCheckedTasks || false;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â console.log('ğŸ“Š Mode settings:', { autoReset, deleteChecked });
Â Â Â Â 
Â Â Â Â const descriptionBox = document.getElementById("mode-description");
Â Â Â Â if (!descriptionBox) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Mode description box not found');
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â let modeTitle = "";
Â Â Â Â let modeDetail = "";
Â Â Â Â let currentMode = "";

Â Â Â Â if (deleteChecked) {
Â Â Â Â Â Â Â Â currentMode = "todo-mode";
Â Â Â Â Â Â Â Â modeTitle = "To-Do List Mode";
Â Â Â Â Â Â Â Â modeDetail = `This mode will not complete any cycles.<br>
Â Â Â Â Â Â Â Â Instead, it will delete all tasks when <br> you hit the complete button.<br>
Â Â Â Â Â Â Â Â This will reveal a recurring option in the <br> task options menu.`;
Â Â Â Â } else if (autoReset) {
Â Â Â Â Â Â Â Â currentMode = "auto-cycle";
Â Â Â Â Â Â Â Â modeTitle = "Auto Cycle Mode";
Â Â Â Â Â Â Â Â modeDetail = `Tasks will automatically reset when<br>all are completed. This is the traditional<br>miniCycle experience.`;
Â Â Â Â } else {
Â Â Â Â Â Â Â Â currentMode = "manual-cycle";
Â Â Â Â Â Â Â Â modeTitle = "Manual Cycle Mode";
Â Â Â Â Â Â Â Â modeDetail = `Tasks will only reset when you<br>manually click the complete button.<br>Gives you more control over timing.`;
Â Â Â Â }

Â Â Â Â descriptionBox.innerHTML = `<strong>${modeTitle}:</strong><br>${modeDetail}`;
Â Â Â Â 
Â Â Â Â console.log('âœ… Mode description updated:', currentMode);
}






/*****SPEACIAL EVENT LISTENERS *****/

document.addEventListener("dragover", (event) => {
Â Â event.preventDefault();
Â Â requestAnimationFrame(() => {
Â Â Â Â Â Â const movingTask = event.target.closest(".task");
Â Â Â Â Â Â if (movingTask) {
Â Â Â Â Â Â Â Â Â Â handleRearrange(movingTask, event);
Â Â Â Â Â Â }
Â Â Â Â Â Â autoSave();
Â Â });
});
document.addEventListener("touchstart", () => {
Â Â Â Â hasInteracted = true;
}, { once: true });



document.addEventListener("touchstart", () => {}, { passive: true });





/***********************
Â *Â 
Â *Â 
Â * STATS PANEL - MOVED TO MODULE
Â *Â 
Â * Stats panel functionality including swipe detection, view switching,
Â * event handlers, and all related code has been moved to:
Â * utilities/statsPanel.js (StatsPanelManager class)
Â *Â 
Â * Global functions are available through module initialization:
Â * - window.showStatsPanel()
Â * - window.showTaskView()Â 
Â * - window.updateStatsPanel()
Â *Â 
Â ************************/

// âœ… Theme-related functions that were accidentally removed during stats panel extraction

function setupThemesPanel() {
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â console.log('ğŸ¨ Setting up themes panel (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Schema 2.5 data not yet available for setupThemesPanel - deferring setup');
Â Â Â Â Â Â Â Â // Defer setup until data is available
Â Â Â Â Â Â Â Â setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â const retryData = loadMiniCycleData();
Â Â Â Â Â Â Â Â Â Â Â Â if (retryData) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.log('ğŸ¨ Retrying setupThemesPanel with loaded data...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â setupThemesPanelWithData(retryData);
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â console.warn('âš ï¸ Schema 2.5 data still not available for setupThemesPanel');
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }, 1000);
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â setupThemesPanelWithData(schemaData);
}

function setupThemesPanelWithData(schemaData) {
Â Â Â Â const { settings } = schemaData;
Â Â Â Â const unlockedThemes = settings.unlockedThemes || [];
Â Â Â Â const hasUnlockedThemes = unlockedThemes.length > 0;
Â Â Â Â 
Â Â Â Â const themeButton = document.getElementById("open-themes-panel");
Â Â Â Â const themesModal = document.getElementById("themes-modal");
Â Â Â Â const closeThemesBtn = document.getElementById("close-themes-btn");
Â Â 
Â Â Â Â // âœ… Show the button if ANY theme is unlocked
Â Â Â Â if (hasUnlockedThemes && themeButton) {
Â Â Â Â Â Â themeButton.style.display = "block";
Â Â Â Â }
Â Â 
Â Â Â Â // âœ… Open modal
Â Â Â Â if (themeButton) {
Â Â Â Â Â Â Â Â themeButton.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â themesModal.style.display = "flex";
Â Â Â Â Â Â Â Â Â Â hideMainMenu(); // Hide the main menu when opening
Â Â Â Â Â Â Â Â });
Â Â Â Â }
Â Â 
Â Â Â Â // âœ… Close modal
Â Â Â Â if (closeThemesBtn) {
Â Â Â Â Â Â Â Â closeThemesBtn.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â themesModal.style.display = "none";
Â Â Â Â Â Â Â Â });
Â Â Â Â }
Â Â 
Â Â Â Â // âœ… Setup dark mode toggle inside themes modal
Â Â Â Â setupDarkModeToggle("darkModeToggleThemes", ["darkModeToggle", "darkModeToggleThemes"]);
Â Â Â Â 
Â Â Â Â console.log('âœ… Themes panel setup completed (Schema 2.5)');
}

// âœ… Quick dark toggle functionality
document.getElementById("quick-dark-toggle")?.addEventListener("click", () => {
Â Â Â Â const isDark = document.body.classList.toggle("dark-mode");
Â Â Â Â 
Â Â Â Â // âœ… Schema 2.5 only
Â Â Â Â console.log('ğŸŒ™ Quick dark toggle (Schema 2.5 only)...');
Â Â Â Â 
Â Â Â Â const schemaData = loadMiniCycleData();
Â Â Â Â if (!schemaData) {
Â Â Â Â Â Â Â Â console.warn('âš ï¸ Schema 2.5 data not available for dark toggle - using fallback');
Â Â Â Â Â Â Â Â // Still update the UI but skip the data persistence
Â Â Â Â Â Â Â Â const settingsToggle = document.getElementById("darkModeToggle");
Â Â Â Â Â Â Â Â const themeToggle = document.getElementById("darkModeToggleThemes");
Â Â Â Â Â Â Â Â if (settingsToggle) settingsToggle.checked = isDark;
Â Â Â Â Â Â Â Â if (themeToggle) themeToggle.checked = isDark;

Â Â Â Â Â Â Â Â const quickToggle = document.getElementById("quick-dark-toggle");
Â Â Â Â Â Â Â Â quickToggle.textContent = isDark ? "â˜€ï¸" : "ğŸŒ™";
Â Â Â Â Â Â Â Â return;
Â Â Â Â }

Â Â Â Â const fullSchemaData = JSON.parse(localStorage.getItem("miniCycleData"));
Â Â Â Â fullSchemaData.settings.darkMode = isDark;
Â Â Â Â fullSchemaData.metadata.lastModified = Date.now();
Â Â Â Â localStorage.setItem("miniCycleData", JSON.stringify(fullSchemaData));

Â Â Â Â // âœ… ADD THIS LINE
Â Â Â Â if (typeof updateThemeColor === 'function') {
Â Â Â Â Â Â Â Â updateThemeColor();
Â Â Â Â }

Â Â Â Â // Sync toggle states in settings panel
Â Â Â Â const settingsToggle = document.getElementById("darkModeToggle");
Â Â Â Â const themeToggle = document.getElementById("darkModeToggleThemes");
Â Â Â Â if (settingsToggle) settingsToggle.checked = isDark;
Â Â Â Â if (themeToggle) themeToggle.checked = isDark;

Â Â Â Â // Update icon
Â Â Â Â const quickToggle = document.getElementById("quick-dark-toggle");
Â Â Â Â quickToggle.textContent = isDark ? "â˜€ï¸" : "ğŸŒ™";
Â Â Â Â 
Â Â Â Â console.log('âœ… Quick dark toggle completed (Schema 2.5)');
});

// âœ… Initialize themes panel (moved to DOMContentLoaded for proper timing)
// setupThemesPanel(); // Moved to initialization sequence

updateCycleModeDescription();
Â setTimeout(updateCycleModeDescription, 10000);












(function boot() {
Â Â function start() {
Â Â Â Â try {
Â Â Â Â Â Â // --- sync init ---
Â Â Â Â Â Â fixTaskValidationIssues();
Â Â Â Â Â Â setupMainMenu();
Â Â Â Â Â Â setupSettingsMenu();
Â Â Â Â Â Â setupAbout();
Â Â Â Â Â Â setupUserManual();
Â Â Â Â Â Â setupFeedbackModal();
Â Â Â Â Â Â // Add themes panel setup after other modal setups
Â Â Â Â Â Â // setupTestingModal(); // Removed duplicate - already called in main boot function
Â Â Â Â Â Â initializeThemesPanel();
Â Â Â Â Â Â initializeModeSelector();
Â Â Â Â Â Â setupRecurringPanel();
Â Â Â Â Â Â attachRecurringSummaryListeners();
Â Â Â Â Â Â updateNavDots();
Â Â Â Â Â Â loadMiniCycle();
Â Â Â Â Â Â initializeDefaultRecurringSettings();
Â Â Â Â Â Â setupMiniCycleTitleListener();
Â Â Â Â Â Â setupDownloadMiniCycle();
Â Â Â Â Â Â setupUploadMiniCycle();
Â Â Â Â Â Â setupRearrange();
Â Â Â Â Â Â dragEndCleanup();
Â Â Â Â Â Â updateMoveArrowsVisibility();
Â Â Â Â Â Â checkDueDates();
Â Â Â Â Â Â loadAlwaysShowRecurringSetting();
Â Â Â Â Â Â updateCycleModeDescription();
Â Â Â Â Â Â Â Â Â setupThemesPanel();Â 

Â Â Â Â Â Â // --- timers / async kickoffs ---
Â Â Â Â Â Â setTimeout(remindOverdueTasks, 2000);
Â Â Â Â Â Â setTimeout(function(){ updateReminderButtons(); startReminders(); }, 200);

Â Â Â Â Â Â // only on modern browsers
Â Â Â Â Â Â if (supportsModern()) setTimeout(autoRedetectOnVersionChange, 10000);

Â Â Â Â Â Â // focus once window is loaded
Â Â Â Â Â Â window.addEventListener('load', function () {
Â Â Â Â Â Â Â Â var el = document.getElementById('taskInput');
Â Â Â Â Â Â Â Â if (el) { try { el.focus(); } catch(_){} }
Â Â Â Â Â Â });

Â Â Â Â Â Â // Initialize stats panel manager
Â Â Â Â Â Â if (window.statsPanelManager) {
Â Â Â Â Â Â Â Â console.log('ğŸ“Š Initializing stats panel event handlers...');
Â Â Â Â Â Â Â Â window.statsPanelManager.init();
Â Â Â Â Â Â Â Â // Update stats panel now that it's ready
Â Â Â Â Â Â Â Â window.updateStatsPanel();
Â Â Â Â Â Â }

Â Â Â Â Â Â // âœ… Setup navigation dot click handlers
Â Â Â Â Â Â document.querySelectorAll(".dot").forEach((dot, index) => {
Â Â Â Â Â Â Â Â dot.addEventListener("click", () => {
Â Â Â Â Â Â Â Â Â Â if (index === 0) {
Â Â Â Â Â Â Â Â Â Â Â Â if (window.showTaskView) window.showTaskView();
Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â if (window.showStatsPanel) window.showStatsPanel();
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â });

Â Â Â Â Â Â // ready signal
Â Â Â Â Â Â window.AppReady = true;
Â Â Â Â Â Â document.dispatchEvent(new Event('app:ready'));
Â Â Â Â Â Â console.log('âœ… miniCycle app is fully initialized and ready.');
Â Â Â Â } catch (err) {
Â Â Â Â Â Â console.error('ğŸš¨ Boot error:', err);
Â Â Â Â Â Â if (typeof showNotification === 'function') {
Â Â Â Â Â Â Â Â showNotification('âš ï¸ App failed to finish booting. Some features may be unavailable.', 'warning', 6000);
Â Â Â Â Â Â }
Â Â Â Â }
Â Â }

Â Â if (document.readyState === 'loading') {
Â Â Â Â document.addEventListener('DOMContentLoaded', start);
Â Â } else {
Â Â Â Â start();
Â Â }

Â Â function supportsModern() {
Â Â Â Â try { new Function('()=>{}'); } catch(_) { return false; }
Â Â Â Â return !!(window.Promise && window.fetch);
Â Â }
})();

});
